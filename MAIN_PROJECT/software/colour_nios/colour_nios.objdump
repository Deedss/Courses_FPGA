
colour_nios.elf:     file format elf32-littlenios2
colour_nios.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00008020

Program Header:
    LOAD off    0x00001000 vaddr 0x00008000 paddr 0x00008000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00008020 paddr 0x00008020 align 2**12
         filesz 0x00003a84 memsz 0x00003a84 flags r-x
    LOAD off    0x00004aa4 vaddr 0x0000baa4 paddr 0x0000bc74 align 2**12
         filesz 0x000001d0 memsz 0x000001d0 flags rw-
    LOAD off    0x00004e44 vaddr 0x0000be44 paddr 0x0000be44 align 2**12
         filesz 0x00000000 memsz 0x000007e4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00008000  00008000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00008020  00008020  00004c74  2**0
                  CONTENTS
  2 .text         000039c4  00008020  00008020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000c0  0000b9e4  0000b9e4  000049e4  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       000001d0  0000baa4  0000bc74  00004aa4  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000007e4  0000be44  0000be44  00004e44  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  0000c628  0000c628  00004c74  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  00004c74  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000430  00000000  00000000  00004c98  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00008e45  00000000  00000000  000050c8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00002513  00000000  00000000  0000df0d  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000308a  00000000  00000000  00010420  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000b94  00000000  00000000  000134ac  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001f60  00000000  00000000  00014040  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000041dd  00000000  00000000  00015fa0  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  0001a180  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000660  00000000  00000000  0001a190  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0001c4fa  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  0001c4fd  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001c509  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001c50a  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  0001c50b  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  0001c516  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  0001c521  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000004  00000000  00000000  0001c52c  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 0000003a  00000000  00000000  0001c530  2**0
                  CONTENTS, READONLY
 26 .jdi          00004c49  00000000  00000000  0001c56a  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     00057e98  00000000  00000000  000211b3  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00008000 l    d  .entry	00000000 .entry
00008020 l    d  .exceptions	00000000 .exceptions
00008020 l    d  .text	00000000 .text
0000b9e4 l    d  .rodata	00000000 .rodata
0000baa4 l    d  .rwdata	00000000 .rwdata
0000be44 l    d  .bss	00000000 .bss
0000c628 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../colour_nios_bsp//obj/HAL/src/crt0.o
00008058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 snprintf.c
00000000 l    df *ABS*	00000000 strcat.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00008794 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 vfprintf.c
00008d48 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 fvwrite_small_str.c
00000000 l    df *ABS*	00000000 impure.c
0000baec l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0000bbcc l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0000b898 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
0000be94 g     O .bss	00000004 aux_status_register
0000961c g     F .text	0000002c alt_main
00008540 g     F .text	00000080 _puts_r
0000bc74 g       *ABS*	00000000 __flash_rwdata_start
00009d7c g     F .text	00000108 Check_for_Master_Boot_Record
0000b788 g     F .text	000000d8 alt_up_sd_card_fclose
000084f4 g     F .text	0000004c printf
0000be70 g     O .bss	00000004 current_sector_modified
0000945c g     F .text	00000060 memmove
00008684 g     F .text	000000b8 snprintf
00009acc g     F .text	00000068 alt_up_sd_card_is_Present
00008080 g     F .text	00000060 grayScale
00009bb4 g     F .text	0000001c Save_Modified_Sector
0000b984 g     F .text	00000008 altera_nios2_gen2_irq_init
000093b4 g     F .text	000000a8 __sfvwrite_small_str
00008000 g     F .entry	0000000c __reset
0000be78 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
00008020 g       *ABS*	00000000 __flash_exceptions_start
0000be5c g     O .bss	00000004 errno
0000be64 g     O .bss	00000004 alt_argv
00013c50 g       *ABS*	00000000 _gp
0000b14c g     F .text	00000194 alt_up_sd_card_fopen
0000b0c4 g     F .text	00000088 alt_up_sd_card_find_first
0000be84 g     O .bss	00000004 command_argument_register
0000bbf8 g     O .rwdata	00000030 alt_fd_list
0000a370 g     F .text	000000c8 find_first_empty_record_in_root_directory
0000b90c g     F .text	00000074 alt_find_dev
0000b9bc g     F .text	00000028 memcpy
0000bea0 g     O .bss	0000000a Blue
000085c0 g     F .text	00000014 puts
0000a130 g     F .text	000000a4 find_first_empty_cluster
00009a64 g     F .text	00000068 alt_up_sd_card_open_dev
000084b8 g     F .text	0000003c _printf_r
00008000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
000083fc g     F .text	00000064 .hidden __udivsi3
00009808 g     F .text	00000058 get_dir_divider_location
000096d8 g     F .text	00000054 filename_to_upper_case
0000b2e0 g     F .text	00000038 alt_up_sd_card_set_attributes
0000a438 g     F .text	00000178 Read_File_Record_At_Offset
0000bc5c g     O .rwdata	00000004 alt_max_fd
0000a868 g     F .text	00000264 find_file_in_directory
0000ae50 g     F .text	00000050 alt_up_sd_card_is_FAT16
0000bac8 g     O .rwdata	00000024 sobel_h
0000bc50 g     O .rwdata	00000004 _global_impure_ptr
0000a5b0 g     F .text	000002b8 get_home_directory_cluster_for_file
0000c628 g       *ABS*	00000000 __bss_end
0000be6c g     O .bss	00000004 current_sector_index
0000be44 g     O .bss	00000004 SWITCHES
00008068 g     F .text	0000000c greenFilter
00009cf0 g     F .text	0000008c mark_cluster
0000bc28 g     O .rwdata	00000028 alt_dev_null
0000994c g     F .text	00000098 convert_filename_to_name_extension
0000b894 g     F .text	00000004 alt_dcache_flush_all
0000be98 g     O .bss	00000004 is_sd_card_formated_as_FAT16
0000be48 g     O .bss	00000004 B
0000a1d4 g     F .text	0000019c find_first_empty_record_in_a_subdirectory
0000bc74 g       *ABS*	00000000 __ram_rwdata_end
0000bc60 g     O .rwdata	00000008 alt_dev_list
00009648 g     F .text	00000060 write
0000be74 g     O .bss	00000004 device_pointer
0000baa4 g       *ABS*	00000000 __ram_rodata_end
0000bc58 g     O .rwdata	00000004 jtag_uart_0
0000873c g     F .text	0000003c strcat
00008460 g     F .text	00000058 .hidden __umodsi3
0000c628 g       *ABS*	00000000 end
00010000 g       *ABS*	00000000 __alt_stack_pointer
000085d4 g     F .text	000000b0 _snprintf_r
0000b860 g     F .text	00000034 altera_avalon_jtag_uart_write
00008db4 g     F .text	0000052c ___vfprintf_internal_r
00008020 g     F .text	0000003c _start
000096c8 g     F .text	00000010 alt_sys_init
0000beaa g     O .bss	00000200 buffer
00009514 g     F .text	00000028 .hidden __mulsi3
0000baa4 g       *ABS*	00000000 __ram_rwdata_start
0000b9e4 g       *ABS*	00000000 __ram_rodata_start
0000be4c g     O .bss	00000004 G
0000be9c g     O .bss	00000004 initialized
0000c0c0 g     O .bss	00000014 search_data
00008074 g     F .text	0000000c blueFilter
0000b98c g     F .text	00000030 memcmp
0000c628 g       *ABS*	00000000 __alt_stack_base
0000c0d4 g     O .bss	00000054 boot_sector_data
0000805c g     F .text	0000000c redFilter
0000b8a0 g     F .text	0000006c alt_dev_llist_insert
00008800 g     F .text	0000052c ___svfprintf_internal_r
0000be50 g     O .bss	00000002 sd_fileh
0000c0aa g     O .bss	0000000a Red
000092fc g     F .text	000000b8 __sfvwrite_small_dev
0000be44 g       *ABS*	00000000 __bss_start
000080e4 g     F .text	00000220 main
0000be60 g     O .bss	00000004 alt_envp
0000b318 g     F .text	00000040 alt_up_sd_card_get_attributes
00009b34 g     F .text	00000080 Write_Sector_Data
0000b4e0 g     F .text	000002a8 alt_up_sd_card_write
0000bc70 g     O .rwdata	00000004 alt_errno
00008304 g     F .text	00000084 .hidden __divsi3
0000c0b4 g     O .bss	0000000a Green
0000be90 g     O .bss	00000004 status_register
0000be88 g     O .bss	00000004 command_register
0000b9e4 g       *ABS*	00000000 __flash_rodata_start
000096a8 g     F .text	00000020 alt_irq_init
00009c70 g     F .text	00000080 get_cluster_flag
0000aacc g     F .text	00000164 Write_File_Record_At_Offset
0000be54 g     O .bss	00000004 R
000094bc g     F .text	00000058 _write_r
00009e84 g     F .text	000002ac Check_for_DOS_FAT
0000ac30 g     F .text	00000188 create_file
0000bc54 g     O .rwdata	00000004 _impure_ptr
0000be8c g     O .bss	00000004 CSD_register_w0
0000be68 g     O .bss	00000004 alt_argc
0000be58 g     O .bss	00000004 WRITE_SD
000080e0 g     F .text	00000004 Sobel
0000bc68 g     O .rwdata	00000008 alt_fs_list
0000972c g     F .text	000000dc check_file_name_for_FAT16_compliance
00008d2c g     F .text	0000001c __vfprintf_internal_unused
0000be80 g     O .bss	00000004 buffer_memory
00008020 g       *ABS*	00000000 __ram_exceptions_start
0000be7c g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
0000bc74 g       *ABS*	00000000 _edata
0000c628 g       *ABS*	00000000 _end
0000c128 g     O .bss	00000500 active_files
00008020 g       *ABS*	00000000 __ram_exceptions_end
000099e4 g     F .text	00000080 copy_file_record_name_to_string
0000adb8 g     F .text	00000098 Look_for_FAT16
0000aea0 g     F .text	00000224 alt_up_sd_card_find_next
00008388 g     F .text	00000074 .hidden __modsi3
00009bd0 g     F .text	000000a0 Read_Sector_Data
00010000 g       *ABS*	00000000 __alt_data_end
0000800c g       .entry	00000000 _exit
0000b358 g     F .text	00000188 alt_up_sd_card_read
00008778 g     F .text	0000001c strlen
0000baa4 g     O .rwdata	00000024 sobel_v
0000b980 g     F .text	00000004 alt_icache_flush_all
000092e0 g     F .text	0000001c __vfprintf_internal
0000953c g     F .text	000000e0 alt_load
00009860 g     F .text	000000ec match_file_record_to_name_ext



Disassembly of section .entry:

00008000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    8000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    8004:	08600814 	ori	at,at,32800
    jmp r1
    8008:	0800683a 	jmp	at

0000800c <_exit>:
	...

Disassembly of section .text:

00008020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    8020:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
    8024:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
    8028:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
    802c:	d68f1414 	ori	gp,gp,15440
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    8030:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    8034:	10af9114 	ori	r2,r2,48708

    movhi r3, %hi(__bss_end)
    8038:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    803c:	18f18a14 	ori	r3,r3,50728

    beq r2, r3, 1f
    8040:	10c00326 	beq	r2,r3,8050 <_start+0x30>

0:
    stw zero, (r2)
    8044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    8048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    804c:	10fffd36 	bltu	r2,r3,8044 <_gp+0xffff43f4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    8050:	000953c0 	call	953c <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    8054:	000961c0 	call	961c <alt_main>

00008058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    8058:	003fff06 	br	8058 <_gp+0xffff4408>

0000805c <redFilter>:
    805c:	20000015 	stw	zero,0(r4)
    8060:	28000015 	stw	zero,0(r5)
    8064:	f800283a 	ret

00008068 <greenFilter>:
    8068:	20000015 	stw	zero,0(r4)
    806c:	28000015 	stw	zero,0(r5)
    8070:	f800283a 	ret

00008074 <blueFilter>:
	*B = 0;
	return;
}

void blueFilter(uint *R, uint *G){
	*R = 0;
    8074:	20000015 	stw	zero,0(r4)
	*G = 0;
    8078:	28000015 	stw	zero,0(r5)
    807c:	f800283a 	ret

00008080 <grayScale>:
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    8080:	defffc04 	addi	sp,sp,-16
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	// Calculating Average Gray
	*R = *G = *B = (*R + *B + *G) / 3;
    8084:	28800017 	ldw	r2,0(r5)
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    8088:	dc000015 	stw	r16,0(sp)
    808c:	2021883a 	mov	r16,r4
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	// Calculating Average Gray
	*R = *G = *B = (*R + *B + *G) / 3;
    8090:	31000017 	ldw	r4,0(r6)
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    8094:	dc400115 	stw	r17,4(sp)
    8098:	2823883a 	mov	r17,r5
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	// Calculating Average Gray
	*R = *G = *B = (*R + *B + *G) / 3;
    809c:	2085883a 	add	r2,r4,r2
    80a0:	81000017 	ldw	r4,0(r16)
    80a4:	014000c4 	movi	r5,3
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    80a8:	dc800215 	stw	r18,8(sp)
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	// Calculating Average Gray
	*R = *G = *B = (*R + *B + *G) / 3;
    80ac:	1109883a 	add	r4,r2,r4
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    80b0:	3025883a 	mov	r18,r6
    80b4:	dfc00315 	stw	ra,12(sp)
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	// Calculating Average Gray
	*R = *G = *B = (*R + *B + *G) / 3;
    80b8:	00083fc0 	call	83fc <__udivsi3>
    80bc:	90800015 	stw	r2,0(r18)
    80c0:	88800015 	stw	r2,0(r17)
    80c4:	80800015 	stw	r2,0(r16)
	/* Calculating by Luminosity */
//	*R = 0.2989 * *R;
//  *G = 0.5870 * *G;
//	*B = 0.1140 * *B;
	return;
}
    80c8:	dfc00317 	ldw	ra,12(sp)
    80cc:	dc800217 	ldw	r18,8(sp)
    80d0:	dc400117 	ldw	r17,4(sp)
    80d4:	dc000017 	ldw	r16,0(sp)
    80d8:	dec00404 	addi	sp,sp,16
    80dc:	f800283a 	ret

000080e0 <Sobel>:

void Sobel(int image[640][480], int out[640][480]){
    80e0:	f800283a 	ret

000080e4 <main>:
}


int main()
{
	printf("SD Card Access Test\n");
    80e4:	01000074 	movhi	r4,1
	return;
}


int main()
{
    80e8:	defff904 	addi	sp,sp,-28
	printf("SD Card Access Test\n");
    80ec:	212e7904 	addi	r4,r4,-17948
	return;
}


int main()
{
    80f0:	dfc00615 	stw	ra,24(sp)
    80f4:	dd400515 	stw	r21,20(sp)
    80f8:	dd000415 	stw	r20,16(sp)
    80fc:	dcc00315 	stw	r19,12(sp)
    8100:	dc800215 	stw	r18,8(sp)
    8104:	dc400115 	stw	r17,4(sp)
    8108:	dc000015 	stw	r16,0(sp)
	printf("SD Card Access Test\n");
    810c:	00085c00 	call	85c0 <puts>

  alt_up_sd_card_dev *sd_card_dev = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
    8110:	01000074 	movhi	r4,1
    8114:	212e7e04 	addi	r4,r4,-17928
    8118:	0009a640 	call	9a64 <alt_up_sd_card_open_dev>

  if(sd_card_dev != 0)
    811c:	10001a26 	beq	r2,zero,8188 <main+0xa4>
  {
	  printf("SD Card dev %d\n", sd_card_dev);
    8120:	01000074 	movhi	r4,1
    8124:	100b883a 	mov	r5,r2
    8128:	212e8904 	addi	r4,r4,-17884
    812c:	00084f40 	call	84f4 <printf>
	  if(alt_up_sd_card_is_Present())
    8130:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    8134:	10001426 	beq	r2,zero,8188 <main+0xa4>
	  {
		  if(alt_up_sd_card_is_FAT16())
    8138:	000ae500 	call	ae50 <alt_up_sd_card_is_FAT16>
    813c:	10000326 	beq	r2,zero,814c <main+0x68>
			  printf("Card is FAT16\n");
    8140:	01000074 	movhi	r4,1
    8144:	212e8d04 	addi	r4,r4,-17868
    8148:	00000206 	br	8154 <main+0x70>
		  else
			  printf("Card is not FAT16\n");
    814c:	01000074 	movhi	r4,1
    8150:	212e9104 	addi	r4,r4,-17852
    8154:	00085c00 	call	85c0 <puts>

		  sd_fileh = alt_up_sd_card_fopen("file.txt", true);
    8158:	01000074 	movhi	r4,1
    815c:	01400044 	movi	r5,1
    8160:	212e9604 	addi	r4,r4,-17832
    8164:	000b14c0 	call	b14c <alt_up_sd_card_fopen>

		  if (sd_fileh < 0)
    8168:	117fffcc 	andi	r5,r2,65535
    816c:	2960001c 	xori	r5,r5,32768
		  if(alt_up_sd_card_is_FAT16())
			  printf("Card is FAT16\n");
		  else
			  printf("Card is not FAT16\n");

		  sd_fileh = alt_up_sd_card_fopen("file.txt", true);
    8170:	d0a0800d 	sth	r2,-32256(gp)

		  if (sd_fileh < 0)
    8174:	29600004 	addi	r5,r5,-32768
    8178:	2800030e 	bge	r5,zero,8188 <main+0xa4>
			  printf("Problem creating file. Error %i", sd_fileh);
    817c:	01000074 	movhi	r4,1
    8180:	212e9904 	addi	r4,r4,-17820
    8184:	00084f40 	call	84f4 <printf>
	  }
  }
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    8188:	05000074 	movhi	r20,1

		snprintf(Red, sizeof(Red), "%d", R);
		snprintf(Green, sizeof(Green), "%d", G);
		snprintf(Blue, sizeof(Blue), "%d", B);

		strcat(buffer, Red);
    818c:	05400074 	movhi	r21,1
			  printf("Problem creating file. Error %i", sd_fileh);
	  }
  }
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    8190:	a5050004 	addi	r20,r20,5120

		snprintf(Red, sizeof(Red), "%d", R);
		snprintf(Green, sizeof(Green), "%d", G);
		snprintf(Blue, sizeof(Blue), "%d", B);

		strcat(buffer, Red);
    8194:	ad6faa84 	addi	r21,r21,-16726
			  printf("Problem creating file. Error %i", sd_fileh);
	  }
  }
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    8198:	a0800037 	ldwio	r2,0(r20)
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
    819c:	04c00074 	movhi	r19,1
    81a0:	9cc50404 	addi	r19,r19,5136
			  printf("Problem creating file. Error %i", sd_fileh);
	  }
  }
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    81a4:	d0a08115 	stw	r2,-32252(gp)
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
    81a8:	98800037 	ldwio	r2,0(r19)
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
    81ac:	04800074 	movhi	r18,1
    81b0:	94850804 	addi	r18,r18,5152
	  }
  }
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
    81b4:	d0a07f15 	stw	r2,-32260(gp)
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
    81b8:	90800037 	ldwio	r2,0(r18)
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    81bc:	04400074 	movhi	r17,1
    81c0:	8c450c04 	addi	r17,r17,5168
  }
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
    81c4:	d0a07e15 	stw	r2,-32264(gp)
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    81c8:	88800037 	ldwio	r2,0(r17)

	if(R >= 0 && G >= 0 && B >= 0){
		if (SWITCHES == 1){
    81cc:	00c00044 	movi	r3,1
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    81d0:	d0a07d15 	stw	r2,-32268(gp)

	if(R >= 0 && G >= 0 && B >= 0){
		if (SWITCHES == 1){
    81d4:	10c0021e 	bne	r2,r3,81e0 <main+0xfc>

/***
 * FUNCTIONS TO USE
 */
void redFilter(uint *G, uint *B){
	*G = 0;
    81d8:	d0207f15 	stw	zero,-32260(gp)
    81dc:	00000306 	br	81ec <main+0x108>

	if(R >= 0 && G >= 0 && B >= 0){
		if (SWITCHES == 1){
			redFilter(&G, &B);
		}
		else if (SWITCHES == 2){
    81e0:	00c00084 	movi	r3,2
    81e4:	10c0031e 	bne	r2,r3,81f4 <main+0x110>
	*B = 0;
	return;
}

void greenFilter(uint *R, uint *B){
	*R = 0;
    81e8:	d0208115 	stw	zero,-32252(gp)
	*B = 0;
    81ec:	d0207e15 	stw	zero,-32264(gp)
    81f0:	00000b06 	br	8220 <main+0x13c>
			redFilter(&G, &B);
		}
		else if (SWITCHES == 2){
			greenFilter(&R, &B);
		}
		else if (SWITCHES == 4){
    81f4:	00c00104 	movi	r3,4
    81f8:	10c0031e 	bne	r2,r3,8208 <main+0x124>
	*B = 0;
	return;
}

void blueFilter(uint *R, uint *G){
	*R = 0;
    81fc:	d0208115 	stw	zero,-32252(gp)
	*G = 0;
    8200:	d0207f15 	stw	zero,-32260(gp)
    8204:	00000606 	br	8220 <main+0x13c>
			greenFilter(&R, &B);
		}
		else if (SWITCHES == 4){
			blueFilter(&R, &G);
		}
		else if (SWITCHES == 8){
    8208:	00c00204 	movi	r3,8
    820c:	10c0041e 	bne	r2,r3,8220 <main+0x13c>
			grayScale(&R, &G, &B);
    8210:	d1a07e04 	addi	r6,gp,-32264
    8214:	d1607f04 	addi	r5,gp,-32260
    8218:	d1208104 	addi	r4,gp,-32252
    821c:	00080800 	call	8080 <grayScale>
		}
		else if (SWITCHES == 16){
			//Sobel()
		}

		snprintf(Red, sizeof(Red), "%d", R);
    8220:	d1e08117 	ldw	r7,-32252(gp)
    8224:	01800074 	movhi	r6,1
    8228:	01000074 	movhi	r4,1
    822c:	31aea104 	addi	r6,r6,-17788
    8230:	01400284 	movi	r5,10
    8234:	21302a84 	addi	r4,r4,-16214
    8238:	00086840 	call	8684 <snprintf>
		snprintf(Green, sizeof(Green), "%d", G);
    823c:	d1e07f17 	ldw	r7,-32260(gp)
    8240:	01800074 	movhi	r6,1
    8244:	01000074 	movhi	r4,1
    8248:	31aea104 	addi	r6,r6,-17788
    824c:	01400284 	movi	r5,10
    8250:	21302d04 	addi	r4,r4,-16204
    8254:	00086840 	call	8684 <snprintf>
		snprintf(Blue, sizeof(Blue), "%d", B);
    8258:	d1e07e17 	ldw	r7,-32264(gp)
    825c:	01800074 	movhi	r6,1
    8260:	01000074 	movhi	r4,1
    8264:	31aea104 	addi	r6,r6,-17788
    8268:	01400284 	movi	r5,10
    826c:	212fa804 	addi	r4,r4,-16736
    8270:	00086840 	call	8684 <snprintf>

		strcat(buffer, Red);
    8274:	01400074 	movhi	r5,1
    8278:	01000074 	movhi	r4,1
    827c:	29702a84 	addi	r5,r5,-16214
    8280:	212faa84 	addi	r4,r4,-16726
    8284:	000873c0 	call	873c <strcat>
		strcat(buffer, Blue);
    8288:	01400074 	movhi	r5,1
    828c:	01000074 	movhi	r4,1
    8290:	296fa804 	addi	r5,r5,-16736
    8294:	212faa84 	addi	r4,r4,-16726
    8298:	000873c0 	call	873c <strcat>
		strcat(buffer, Green);
    829c:	01400074 	movhi	r5,1
    82a0:	01000074 	movhi	r4,1
    82a4:	29702d04 	addi	r5,r5,-16204
    82a8:	212faa84 	addi	r4,r4,-16726
    82ac:	000873c0 	call	873c <strcat>
		strcat(buffer, "\0");
		int index = 0;
    82b0:	0021883a 	mov	r16,zero
		while (buffer[index] < sizeof(buffer))
    82b4:	8545883a 	add	r2,r16,r21
    82b8:	11400007 	ldb	r5,0(r2)
    82bc:	28000416 	blt	r5,zero,82d0 <main+0x1ec>
		{
			alt_up_sd_card_write(sd_fileh, buffer[index]);
    82c0:	d120800f 	ldh	r4,-32256(gp)
			index = index + 1;
    82c4:	84000044 	addi	r16,r16,1
		strcat(buffer, Green);
		strcat(buffer, "\0");
		int index = 0;
		while (buffer[index] < sizeof(buffer))
		{
			alt_up_sd_card_write(sd_fileh, buffer[index]);
    82c8:	000b4e00 	call	b4e0 <alt_up_sd_card_write>
    82cc:	003ff906 	br	82b4 <_gp+0xffff4664>
			index = index + 1;
		}


		IOWR_ALTERA_AVALON_PIO_DATA(RED_BASE, R);
    82d0:	d0e08117 	ldw	r3,-32252(gp)
    82d4:	00800074 	movhi	r2,1
    82d8:	10850004 	addi	r2,r2,5120
    82dc:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(GREEN_BASE, G);
    82e0:	d0a07f17 	ldw	r2,-32260(gp)
    82e4:	98800035 	stwio	r2,0(r19)
		IOWR_ALTERA_AVALON_PIO_DATA(BLUE_BASE, B);
    82e8:	d0a07e17 	ldw	r2,-32264(gp)
    82ec:	90800035 	stwio	r2,0(r18)
		IOWR_ALTERA_AVALON_PIO_DATA(SW_BASE, SWITCHES);
    82f0:	d0a07d17 	ldw	r2,-32268(gp)
    82f4:	88800035 	stwio	r2,0(r17)


	}
	  alt_up_sd_card_fclose(sd_fileh);
    82f8:	d120800f 	ldh	r4,-32256(gp)
    82fc:	000b7880 	call	b788 <alt_up_sd_card_fclose>

  }
    8300:	003fa506 	br	8198 <_gp+0xffff4548>

00008304 <__divsi3>:
    8304:	20001b16 	blt	r4,zero,8374 <__divsi3+0x70>
    8308:	000f883a 	mov	r7,zero
    830c:	28001616 	blt	r5,zero,8368 <__divsi3+0x64>
    8310:	200d883a 	mov	r6,r4
    8314:	29001a2e 	bgeu	r5,r4,8380 <__divsi3+0x7c>
    8318:	00800804 	movi	r2,32
    831c:	00c00044 	movi	r3,1
    8320:	00000106 	br	8328 <__divsi3+0x24>
    8324:	10000d26 	beq	r2,zero,835c <__divsi3+0x58>
    8328:	294b883a 	add	r5,r5,r5
    832c:	10bfffc4 	addi	r2,r2,-1
    8330:	18c7883a 	add	r3,r3,r3
    8334:	293ffb36 	bltu	r5,r4,8324 <_gp+0xffff46d4>
    8338:	0005883a 	mov	r2,zero
    833c:	18000726 	beq	r3,zero,835c <__divsi3+0x58>
    8340:	0005883a 	mov	r2,zero
    8344:	31400236 	bltu	r6,r5,8350 <__divsi3+0x4c>
    8348:	314dc83a 	sub	r6,r6,r5
    834c:	10c4b03a 	or	r2,r2,r3
    8350:	1806d07a 	srli	r3,r3,1
    8354:	280ad07a 	srli	r5,r5,1
    8358:	183ffa1e 	bne	r3,zero,8344 <_gp+0xffff46f4>
    835c:	38000126 	beq	r7,zero,8364 <__divsi3+0x60>
    8360:	0085c83a 	sub	r2,zero,r2
    8364:	f800283a 	ret
    8368:	014bc83a 	sub	r5,zero,r5
    836c:	39c0005c 	xori	r7,r7,1
    8370:	003fe706 	br	8310 <_gp+0xffff46c0>
    8374:	0109c83a 	sub	r4,zero,r4
    8378:	01c00044 	movi	r7,1
    837c:	003fe306 	br	830c <_gp+0xffff46bc>
    8380:	00c00044 	movi	r3,1
    8384:	003fee06 	br	8340 <_gp+0xffff46f0>

00008388 <__modsi3>:
    8388:	20001716 	blt	r4,zero,83e8 <__modsi3+0x60>
    838c:	000f883a 	mov	r7,zero
    8390:	2005883a 	mov	r2,r4
    8394:	28001216 	blt	r5,zero,83e0 <__modsi3+0x58>
    8398:	2900162e 	bgeu	r5,r4,83f4 <__modsi3+0x6c>
    839c:	01800804 	movi	r6,32
    83a0:	00c00044 	movi	r3,1
    83a4:	00000106 	br	83ac <__modsi3+0x24>
    83a8:	30000a26 	beq	r6,zero,83d4 <__modsi3+0x4c>
    83ac:	294b883a 	add	r5,r5,r5
    83b0:	31bfffc4 	addi	r6,r6,-1
    83b4:	18c7883a 	add	r3,r3,r3
    83b8:	293ffb36 	bltu	r5,r4,83a8 <_gp+0xffff4758>
    83bc:	18000526 	beq	r3,zero,83d4 <__modsi3+0x4c>
    83c0:	1806d07a 	srli	r3,r3,1
    83c4:	11400136 	bltu	r2,r5,83cc <__modsi3+0x44>
    83c8:	1145c83a 	sub	r2,r2,r5
    83cc:	280ad07a 	srli	r5,r5,1
    83d0:	183ffb1e 	bne	r3,zero,83c0 <_gp+0xffff4770>
    83d4:	38000126 	beq	r7,zero,83dc <__modsi3+0x54>
    83d8:	0085c83a 	sub	r2,zero,r2
    83dc:	f800283a 	ret
    83e0:	014bc83a 	sub	r5,zero,r5
    83e4:	003fec06 	br	8398 <_gp+0xffff4748>
    83e8:	0109c83a 	sub	r4,zero,r4
    83ec:	01c00044 	movi	r7,1
    83f0:	003fe706 	br	8390 <_gp+0xffff4740>
    83f4:	00c00044 	movi	r3,1
    83f8:	003ff106 	br	83c0 <_gp+0xffff4770>

000083fc <__udivsi3>:
    83fc:	200d883a 	mov	r6,r4
    8400:	2900152e 	bgeu	r5,r4,8458 <__udivsi3+0x5c>
    8404:	28001416 	blt	r5,zero,8458 <__udivsi3+0x5c>
    8408:	00800804 	movi	r2,32
    840c:	00c00044 	movi	r3,1
    8410:	00000206 	br	841c <__udivsi3+0x20>
    8414:	10000e26 	beq	r2,zero,8450 <__udivsi3+0x54>
    8418:	28000516 	blt	r5,zero,8430 <__udivsi3+0x34>
    841c:	294b883a 	add	r5,r5,r5
    8420:	10bfffc4 	addi	r2,r2,-1
    8424:	18c7883a 	add	r3,r3,r3
    8428:	293ffa36 	bltu	r5,r4,8414 <_gp+0xffff47c4>
    842c:	18000826 	beq	r3,zero,8450 <__udivsi3+0x54>
    8430:	0005883a 	mov	r2,zero
    8434:	31400236 	bltu	r6,r5,8440 <__udivsi3+0x44>
    8438:	314dc83a 	sub	r6,r6,r5
    843c:	10c4b03a 	or	r2,r2,r3
    8440:	1806d07a 	srli	r3,r3,1
    8444:	280ad07a 	srli	r5,r5,1
    8448:	183ffa1e 	bne	r3,zero,8434 <_gp+0xffff47e4>
    844c:	f800283a 	ret
    8450:	0005883a 	mov	r2,zero
    8454:	f800283a 	ret
    8458:	00c00044 	movi	r3,1
    845c:	003ff406 	br	8430 <_gp+0xffff47e0>

00008460 <__umodsi3>:
    8460:	2005883a 	mov	r2,r4
    8464:	2900122e 	bgeu	r5,r4,84b0 <__umodsi3+0x50>
    8468:	28001116 	blt	r5,zero,84b0 <__umodsi3+0x50>
    846c:	01800804 	movi	r6,32
    8470:	00c00044 	movi	r3,1
    8474:	00000206 	br	8480 <__umodsi3+0x20>
    8478:	30000c26 	beq	r6,zero,84ac <__umodsi3+0x4c>
    847c:	28000516 	blt	r5,zero,8494 <__umodsi3+0x34>
    8480:	294b883a 	add	r5,r5,r5
    8484:	31bfffc4 	addi	r6,r6,-1
    8488:	18c7883a 	add	r3,r3,r3
    848c:	293ffa36 	bltu	r5,r4,8478 <_gp+0xffff4828>
    8490:	18000626 	beq	r3,zero,84ac <__umodsi3+0x4c>
    8494:	1806d07a 	srli	r3,r3,1
    8498:	11400136 	bltu	r2,r5,84a0 <__umodsi3+0x40>
    849c:	1145c83a 	sub	r2,r2,r5
    84a0:	280ad07a 	srli	r5,r5,1
    84a4:	183ffb1e 	bne	r3,zero,8494 <_gp+0xffff4844>
    84a8:	f800283a 	ret
    84ac:	f800283a 	ret
    84b0:	00c00044 	movi	r3,1
    84b4:	003ff706 	br	8494 <_gp+0xffff4844>

000084b8 <_printf_r>:
    84b8:	defffd04 	addi	sp,sp,-12
    84bc:	dfc00015 	stw	ra,0(sp)
    84c0:	d9800115 	stw	r6,4(sp)
    84c4:	d9c00215 	stw	r7,8(sp)
    84c8:	20c00217 	ldw	r3,8(r4)
    84cc:	01800074 	movhi	r6,1
    84d0:	31a4bf04 	addi	r6,r6,-27908
    84d4:	19800115 	stw	r6,4(r3)
    84d8:	280d883a 	mov	r6,r5
    84dc:	21400217 	ldw	r5,8(r4)
    84e0:	d9c00104 	addi	r7,sp,4
    84e4:	0008db40 	call	8db4 <___vfprintf_internal_r>
    84e8:	dfc00017 	ldw	ra,0(sp)
    84ec:	dec00304 	addi	sp,sp,12
    84f0:	f800283a 	ret

000084f4 <printf>:
    84f4:	defffc04 	addi	sp,sp,-16
    84f8:	dfc00015 	stw	ra,0(sp)
    84fc:	d9400115 	stw	r5,4(sp)
    8500:	d9800215 	stw	r6,8(sp)
    8504:	d9c00315 	stw	r7,12(sp)
    8508:	00800074 	movhi	r2,1
    850c:	10af1504 	addi	r2,r2,-17324
    8510:	10800017 	ldw	r2,0(r2)
    8514:	01400074 	movhi	r5,1
    8518:	2964bf04 	addi	r5,r5,-27908
    851c:	10c00217 	ldw	r3,8(r2)
    8520:	d9800104 	addi	r6,sp,4
    8524:	19400115 	stw	r5,4(r3)
    8528:	200b883a 	mov	r5,r4
    852c:	11000217 	ldw	r4,8(r2)
    8530:	00092e00 	call	92e0 <__vfprintf_internal>
    8534:	dfc00017 	ldw	ra,0(sp)
    8538:	dec00404 	addi	sp,sp,16
    853c:	f800283a 	ret

00008540 <_puts_r>:
    8540:	defffd04 	addi	sp,sp,-12
    8544:	dc000015 	stw	r16,0(sp)
    8548:	2021883a 	mov	r16,r4
    854c:	2809883a 	mov	r4,r5
    8550:	dfc00215 	stw	ra,8(sp)
    8554:	dc400115 	stw	r17,4(sp)
    8558:	2823883a 	mov	r17,r5
    855c:	00087780 	call	8778 <strlen>
    8560:	81400217 	ldw	r5,8(r16)
    8564:	01000074 	movhi	r4,1
    8568:	2124bf04 	addi	r4,r4,-27908
    856c:	29000115 	stw	r4,4(r5)
    8570:	100f883a 	mov	r7,r2
    8574:	880d883a 	mov	r6,r17
    8578:	8009883a 	mov	r4,r16
    857c:	00092fc0 	call	92fc <__sfvwrite_small_dev>
    8580:	00ffffc4 	movi	r3,-1
    8584:	10c00926 	beq	r2,r3,85ac <_puts_r+0x6c>
    8588:	81400217 	ldw	r5,8(r16)
    858c:	01800074 	movhi	r6,1
    8590:	01c00044 	movi	r7,1
    8594:	28800117 	ldw	r2,4(r5)
    8598:	31aea204 	addi	r6,r6,-17784
    859c:	8009883a 	mov	r4,r16
    85a0:	103ee83a 	callr	r2
    85a4:	10bfffe0 	cmpeqi	r2,r2,-1
    85a8:	0085c83a 	sub	r2,zero,r2
    85ac:	dfc00217 	ldw	ra,8(sp)
    85b0:	dc400117 	ldw	r17,4(sp)
    85b4:	dc000017 	ldw	r16,0(sp)
    85b8:	dec00304 	addi	sp,sp,12
    85bc:	f800283a 	ret

000085c0 <puts>:
    85c0:	00800074 	movhi	r2,1
    85c4:	10af1504 	addi	r2,r2,-17324
    85c8:	200b883a 	mov	r5,r4
    85cc:	11000017 	ldw	r4,0(r2)
    85d0:	00085401 	jmpi	8540 <_puts_r>

000085d4 <_snprintf_r>:
    85d4:	3000040e 	bge	r6,zero,85e8 <_snprintf_r+0x14>
    85d8:	008022c4 	movi	r2,139
    85dc:	20800015 	stw	r2,0(r4)
    85e0:	00bfffc4 	movi	r2,-1
    85e4:	f800283a 	ret
    85e8:	defff604 	addi	sp,sp,-40
    85ec:	00c08204 	movi	r3,520
    85f0:	dfc00915 	stw	ra,36(sp)
    85f4:	dc400815 	stw	r17,32(sp)
    85f8:	dc000715 	stw	r16,28(sp)
    85fc:	d8c0000d 	sth	r3,0(sp)
    8600:	d9400415 	stw	r5,16(sp)
    8604:	d9400215 	stw	r5,8(sp)
    8608:	3005883a 	mov	r2,r6
    860c:	30000226 	beq	r6,zero,8618 <_snprintf_r+0x44>
    8610:	30ffffc4 	addi	r3,r6,-1
    8614:	00000106 	br	861c <_snprintf_r+0x48>
    8618:	0007883a 	mov	r3,zero
    861c:	1021883a 	mov	r16,r2
    8620:	00bfffc4 	movi	r2,-1
    8624:	d880008d 	sth	r2,2(sp)
    8628:	00800074 	movhi	r2,1
    862c:	380d883a 	mov	r6,r7
    8630:	10a4ed04 	addi	r2,r2,-27724
    8634:	d9c00a04 	addi	r7,sp,40
    8638:	d80b883a 	mov	r5,sp
    863c:	d8c00515 	stw	r3,20(sp)
    8640:	d8c00315 	stw	r3,12(sp)
    8644:	2023883a 	mov	r17,r4
    8648:	d8800115 	stw	r2,4(sp)
    864c:	d8000615 	stw	zero,24(sp)
    8650:	00088000 	call	8800 <___svfprintf_internal_r>
    8654:	00ffffc4 	movi	r3,-1
    8658:	10c0020e 	bge	r2,r3,8664 <_snprintf_r+0x90>
    865c:	00c022c4 	movi	r3,139
    8660:	88c00015 	stw	r3,0(r17)
    8664:	80000226 	beq	r16,zero,8670 <_snprintf_r+0x9c>
    8668:	d8c00417 	ldw	r3,16(sp)
    866c:	18000005 	stb	zero,0(r3)
    8670:	dfc00917 	ldw	ra,36(sp)
    8674:	dc400817 	ldw	r17,32(sp)
    8678:	dc000717 	ldw	r16,28(sp)
    867c:	dec00a04 	addi	sp,sp,40
    8680:	f800283a 	ret

00008684 <snprintf>:
    8684:	defff504 	addi	sp,sp,-44
    8688:	dfc00915 	stw	ra,36(sp)
    868c:	dc400815 	stw	r17,32(sp)
    8690:	dc000715 	stw	r16,28(sp)
    8694:	d9c00a15 	stw	r7,40(sp)
    8698:	00800074 	movhi	r2,1
    869c:	10af1504 	addi	r2,r2,-17324
    86a0:	14400017 	ldw	r17,0(r2)
    86a4:	2800040e 	bge	r5,zero,86b8 <snprintf+0x34>
    86a8:	008022c4 	movi	r2,139
    86ac:	88800015 	stw	r2,0(r17)
    86b0:	00bfffc4 	movi	r2,-1
    86b4:	00001c06 	br	8728 <snprintf+0xa4>
    86b8:	00c08204 	movi	r3,520
    86bc:	d8c0000d 	sth	r3,0(sp)
    86c0:	d9000415 	stw	r4,16(sp)
    86c4:	d9000215 	stw	r4,8(sp)
    86c8:	28000226 	beq	r5,zero,86d4 <snprintf+0x50>
    86cc:	28ffffc4 	addi	r3,r5,-1
    86d0:	00000106 	br	86d8 <snprintf+0x54>
    86d4:	0007883a 	mov	r3,zero
    86d8:	d8c00515 	stw	r3,20(sp)
    86dc:	d8c00315 	stw	r3,12(sp)
    86e0:	11000017 	ldw	r4,0(r2)
    86e4:	00ffffc4 	movi	r3,-1
    86e8:	d8c0008d 	sth	r3,2(sp)
    86ec:	00c00074 	movhi	r3,1
    86f0:	18e4ed04 	addi	r3,r3,-27724
    86f4:	2821883a 	mov	r16,r5
    86f8:	d9c00a04 	addi	r7,sp,40
    86fc:	d80b883a 	mov	r5,sp
    8700:	d8c00115 	stw	r3,4(sp)
    8704:	d8000615 	stw	zero,24(sp)
    8708:	00088000 	call	8800 <___svfprintf_internal_r>
    870c:	00ffffc4 	movi	r3,-1
    8710:	10c0020e 	bge	r2,r3,871c <snprintf+0x98>
    8714:	00c022c4 	movi	r3,139
    8718:	88c00015 	stw	r3,0(r17)
    871c:	80000226 	beq	r16,zero,8728 <snprintf+0xa4>
    8720:	d8c00417 	ldw	r3,16(sp)
    8724:	18000005 	stb	zero,0(r3)
    8728:	dfc00917 	ldw	ra,36(sp)
    872c:	dc400817 	ldw	r17,32(sp)
    8730:	dc000717 	ldw	r16,28(sp)
    8734:	dec00b04 	addi	sp,sp,44
    8738:	f800283a 	ret

0000873c <strcat>:
    873c:	2005883a 	mov	r2,r4
    8740:	2007883a 	mov	r3,r4
    8744:	19000007 	ldb	r4,0(r3)
    8748:	20000226 	beq	r4,zero,8754 <strcat+0x18>
    874c:	18c00044 	addi	r3,r3,1
    8750:	003ffc06 	br	8744 <_gp+0xffff4af4>
    8754:	29800003 	ldbu	r6,0(r5)
    8758:	18c00044 	addi	r3,r3,1
    875c:	29400044 	addi	r5,r5,1
    8760:	19bfffc5 	stb	r6,-1(r3)
    8764:	31803fcc 	andi	r6,r6,255
    8768:	3180201c 	xori	r6,r6,128
    876c:	31bfe004 	addi	r6,r6,-128
    8770:	303ff81e 	bne	r6,zero,8754 <_gp+0xffff4b04>
    8774:	f800283a 	ret

00008778 <strlen>:
    8778:	2005883a 	mov	r2,r4
    877c:	10c00007 	ldb	r3,0(r2)
    8780:	18000226 	beq	r3,zero,878c <strlen+0x14>
    8784:	10800044 	addi	r2,r2,1
    8788:	003ffc06 	br	877c <_gp+0xffff4b2c>
    878c:	1105c83a 	sub	r2,r2,r4
    8790:	f800283a 	ret

00008794 <print_repeat>:
    8794:	defffb04 	addi	sp,sp,-20
    8798:	dc800315 	stw	r18,12(sp)
    879c:	dc400215 	stw	r17,8(sp)
    87a0:	dc000115 	stw	r16,4(sp)
    87a4:	dfc00415 	stw	ra,16(sp)
    87a8:	2025883a 	mov	r18,r4
    87ac:	2823883a 	mov	r17,r5
    87b0:	d9800005 	stb	r6,0(sp)
    87b4:	3821883a 	mov	r16,r7
    87b8:	04000a0e 	bge	zero,r16,87e4 <print_repeat+0x50>
    87bc:	88800117 	ldw	r2,4(r17)
    87c0:	01c00044 	movi	r7,1
    87c4:	d80d883a 	mov	r6,sp
    87c8:	880b883a 	mov	r5,r17
    87cc:	9009883a 	mov	r4,r18
    87d0:	103ee83a 	callr	r2
    87d4:	843fffc4 	addi	r16,r16,-1
    87d8:	103ff726 	beq	r2,zero,87b8 <_gp+0xffff4b68>
    87dc:	00bfffc4 	movi	r2,-1
    87e0:	00000106 	br	87e8 <print_repeat+0x54>
    87e4:	0005883a 	mov	r2,zero
    87e8:	dfc00417 	ldw	ra,16(sp)
    87ec:	dc800317 	ldw	r18,12(sp)
    87f0:	dc400217 	ldw	r17,8(sp)
    87f4:	dc000117 	ldw	r16,4(sp)
    87f8:	dec00504 	addi	sp,sp,20
    87fc:	f800283a 	ret

00008800 <___svfprintf_internal_r>:
    8800:	deffe504 	addi	sp,sp,-108
    8804:	d8c00804 	addi	r3,sp,32
    8808:	ddc01815 	stw	r23,96(sp)
    880c:	dd801715 	stw	r22,92(sp)
    8810:	dd401615 	stw	r21,88(sp)
    8814:	dd001515 	stw	r20,84(sp)
    8818:	dcc01415 	stw	r19,80(sp)
    881c:	dc801315 	stw	r18,76(sp)
    8820:	dc401215 	stw	r17,72(sp)
    8824:	dc001115 	stw	r16,68(sp)
    8828:	dfc01a15 	stw	ra,104(sp)
    882c:	df001915 	stw	fp,100(sp)
    8830:	2029883a 	mov	r20,r4
    8834:	2823883a 	mov	r17,r5
    8838:	382d883a 	mov	r22,r7
    883c:	d9800f15 	stw	r6,60(sp)
    8840:	0021883a 	mov	r16,zero
    8844:	d8000e15 	stw	zero,56(sp)
    8848:	d8000a15 	stw	zero,40(sp)
    884c:	002b883a 	mov	r21,zero
    8850:	0027883a 	mov	r19,zero
    8854:	0025883a 	mov	r18,zero
    8858:	d8000c15 	stw	zero,48(sp)
    885c:	d8000b15 	stw	zero,44(sp)
    8860:	002f883a 	mov	r23,zero
    8864:	d8c00915 	stw	r3,36(sp)
    8868:	d8c00f17 	ldw	r3,60(sp)
    886c:	19000003 	ldbu	r4,0(r3)
    8870:	20803fcc 	andi	r2,r4,255
    8874:	1080201c 	xori	r2,r2,128
    8878:	10bfe004 	addi	r2,r2,-128
    887c:	10011e26 	beq	r2,zero,8cf8 <___svfprintf_internal_r+0x4f8>
    8880:	00c00044 	movi	r3,1
    8884:	b8c01426 	beq	r23,r3,88d8 <___svfprintf_internal_r+0xd8>
    8888:	1dc00216 	blt	r3,r23,8894 <___svfprintf_internal_r+0x94>
    888c:	b8000626 	beq	r23,zero,88a8 <___svfprintf_internal_r+0xa8>
    8890:	00011506 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    8894:	01400084 	movi	r5,2
    8898:	b9401d26 	beq	r23,r5,8910 <___svfprintf_internal_r+0x110>
    889c:	014000c4 	movi	r5,3
    88a0:	b9402b26 	beq	r23,r5,8950 <___svfprintf_internal_r+0x150>
    88a4:	00011006 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    88a8:	01400944 	movi	r5,37
    88ac:	1140fc26 	beq	r2,r5,8ca0 <___svfprintf_internal_r+0x4a0>
    88b0:	88800117 	ldw	r2,4(r17)
    88b4:	d9000005 	stb	r4,0(sp)
    88b8:	01c00044 	movi	r7,1
    88bc:	d80d883a 	mov	r6,sp
    88c0:	880b883a 	mov	r5,r17
    88c4:	a009883a 	mov	r4,r20
    88c8:	103ee83a 	callr	r2
    88cc:	1000d81e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    88d0:	84000044 	addi	r16,r16,1
    88d4:	00010406 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    88d8:	01400c04 	movi	r5,48
    88dc:	1140fa26 	beq	r2,r5,8cc8 <___svfprintf_internal_r+0x4c8>
    88e0:	01400944 	movi	r5,37
    88e4:	11400a1e 	bne	r2,r5,8910 <___svfprintf_internal_r+0x110>
    88e8:	d8800005 	stb	r2,0(sp)
    88ec:	88800117 	ldw	r2,4(r17)
    88f0:	b80f883a 	mov	r7,r23
    88f4:	d80d883a 	mov	r6,sp
    88f8:	880b883a 	mov	r5,r17
    88fc:	a009883a 	mov	r4,r20
    8900:	103ee83a 	callr	r2
    8904:	1000ca1e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8908:	84000044 	addi	r16,r16,1
    890c:	0000f506 	br	8ce4 <___svfprintf_internal_r+0x4e4>
    8910:	25fff404 	addi	r23,r4,-48
    8914:	bdc03fcc 	andi	r23,r23,255
    8918:	00c00244 	movi	r3,9
    891c:	1dc00936 	bltu	r3,r23,8944 <___svfprintf_internal_r+0x144>
    8920:	00bfffc4 	movi	r2,-1
    8924:	90800426 	beq	r18,r2,8938 <___svfprintf_internal_r+0x138>
    8928:	01400284 	movi	r5,10
    892c:	9009883a 	mov	r4,r18
    8930:	00095140 	call	9514 <__mulsi3>
    8934:	00000106 	br	893c <___svfprintf_internal_r+0x13c>
    8938:	0005883a 	mov	r2,zero
    893c:	b8a5883a 	add	r18,r23,r2
    8940:	0000e206 	br	8ccc <___svfprintf_internal_r+0x4cc>
    8944:	01400b84 	movi	r5,46
    8948:	1140e426 	beq	r2,r5,8cdc <___svfprintf_internal_r+0x4dc>
    894c:	05c00084 	movi	r23,2
    8950:	213ff404 	addi	r4,r4,-48
    8954:	27003fcc 	andi	fp,r4,255
    8958:	00c00244 	movi	r3,9
    895c:	1f000936 	bltu	r3,fp,8984 <___svfprintf_internal_r+0x184>
    8960:	00bfffc4 	movi	r2,-1
    8964:	98800426 	beq	r19,r2,8978 <___svfprintf_internal_r+0x178>
    8968:	01400284 	movi	r5,10
    896c:	9809883a 	mov	r4,r19
    8970:	00095140 	call	9514 <__mulsi3>
    8974:	00000106 	br	897c <___svfprintf_internal_r+0x17c>
    8978:	0005883a 	mov	r2,zero
    897c:	e0a7883a 	add	r19,fp,r2
    8980:	0000d906 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    8984:	00c01b04 	movi	r3,108
    8988:	10c0d226 	beq	r2,r3,8cd4 <___svfprintf_internal_r+0x4d4>
    898c:	013fffc4 	movi	r4,-1
    8990:	99000226 	beq	r19,r4,899c <___svfprintf_internal_r+0x19c>
    8994:	d8000b15 	stw	zero,44(sp)
    8998:	00000106 	br	89a0 <___svfprintf_internal_r+0x1a0>
    899c:	04c00044 	movi	r19,1
    89a0:	01001a44 	movi	r4,105
    89a4:	11001626 	beq	r2,r4,8a00 <___svfprintf_internal_r+0x200>
    89a8:	20800916 	blt	r4,r2,89d0 <___svfprintf_internal_r+0x1d0>
    89ac:	010018c4 	movi	r4,99
    89b0:	11008826 	beq	r2,r4,8bd4 <___svfprintf_internal_r+0x3d4>
    89b4:	01001904 	movi	r4,100
    89b8:	11001126 	beq	r2,r4,8a00 <___svfprintf_internal_r+0x200>
    89bc:	01001604 	movi	r4,88
    89c0:	1100c81e 	bne	r2,r4,8ce4 <___svfprintf_internal_r+0x4e4>
    89c4:	00c00044 	movi	r3,1
    89c8:	d8c00e15 	stw	r3,56(sp)
    89cc:	00001506 	br	8a24 <___svfprintf_internal_r+0x224>
    89d0:	01001cc4 	movi	r4,115
    89d4:	11009826 	beq	r2,r4,8c38 <___svfprintf_internal_r+0x438>
    89d8:	20800416 	blt	r4,r2,89ec <___svfprintf_internal_r+0x1ec>
    89dc:	01001bc4 	movi	r4,111
    89e0:	1100c01e 	bne	r2,r4,8ce4 <___svfprintf_internal_r+0x4e4>
    89e4:	05400204 	movi	r21,8
    89e8:	00000f06 	br	8a28 <___svfprintf_internal_r+0x228>
    89ec:	01001d44 	movi	r4,117
    89f0:	11000d26 	beq	r2,r4,8a28 <___svfprintf_internal_r+0x228>
    89f4:	01001e04 	movi	r4,120
    89f8:	11000a26 	beq	r2,r4,8a24 <___svfprintf_internal_r+0x224>
    89fc:	0000b906 	br	8ce4 <___svfprintf_internal_r+0x4e4>
    8a00:	d8c00a17 	ldw	r3,40(sp)
    8a04:	b7000104 	addi	fp,r22,4
    8a08:	18000726 	beq	r3,zero,8a28 <___svfprintf_internal_r+0x228>
    8a0c:	df000d15 	stw	fp,52(sp)
    8a10:	b5c00017 	ldw	r23,0(r22)
    8a14:	b800080e 	bge	r23,zero,8a38 <___svfprintf_internal_r+0x238>
    8a18:	05efc83a 	sub	r23,zero,r23
    8a1c:	02400044 	movi	r9,1
    8a20:	00000606 	br	8a3c <___svfprintf_internal_r+0x23c>
    8a24:	05400404 	movi	r21,16
    8a28:	b0c00104 	addi	r3,r22,4
    8a2c:	d8c00d15 	stw	r3,52(sp)
    8a30:	b5c00017 	ldw	r23,0(r22)
    8a34:	d8000a15 	stw	zero,40(sp)
    8a38:	0013883a 	mov	r9,zero
    8a3c:	d839883a 	mov	fp,sp
    8a40:	b8001726 	beq	r23,zero,8aa0 <___svfprintf_internal_r+0x2a0>
    8a44:	a80b883a 	mov	r5,r21
    8a48:	b809883a 	mov	r4,r23
    8a4c:	da401015 	stw	r9,64(sp)
    8a50:	00083fc0 	call	83fc <__udivsi3>
    8a54:	a80b883a 	mov	r5,r21
    8a58:	1009883a 	mov	r4,r2
    8a5c:	102d883a 	mov	r22,r2
    8a60:	00095140 	call	9514 <__mulsi3>
    8a64:	b885c83a 	sub	r2,r23,r2
    8a68:	00c00244 	movi	r3,9
    8a6c:	da401017 	ldw	r9,64(sp)
    8a70:	18800216 	blt	r3,r2,8a7c <___svfprintf_internal_r+0x27c>
    8a74:	10800c04 	addi	r2,r2,48
    8a78:	00000506 	br	8a90 <___svfprintf_internal_r+0x290>
    8a7c:	d8c00e17 	ldw	r3,56(sp)
    8a80:	18000226 	beq	r3,zero,8a8c <___svfprintf_internal_r+0x28c>
    8a84:	10800dc4 	addi	r2,r2,55
    8a88:	00000106 	br	8a90 <___svfprintf_internal_r+0x290>
    8a8c:	108015c4 	addi	r2,r2,87
    8a90:	e0800005 	stb	r2,0(fp)
    8a94:	b02f883a 	mov	r23,r22
    8a98:	e7000044 	addi	fp,fp,1
    8a9c:	003fe806 	br	8a40 <_gp+0xffff4df0>
    8aa0:	e6efc83a 	sub	r23,fp,sp
    8aa4:	9dc5c83a 	sub	r2,r19,r23
    8aa8:	0080090e 	bge	zero,r2,8ad0 <___svfprintf_internal_r+0x2d0>
    8aac:	e085883a 	add	r2,fp,r2
    8ab0:	01400c04 	movi	r5,48
    8ab4:	d8c00917 	ldw	r3,36(sp)
    8ab8:	e009883a 	mov	r4,fp
    8abc:	e0c0032e 	bgeu	fp,r3,8acc <___svfprintf_internal_r+0x2cc>
    8ac0:	e7000044 	addi	fp,fp,1
    8ac4:	21400005 	stb	r5,0(r4)
    8ac8:	e0bffa1e 	bne	fp,r2,8ab4 <_gp+0xffff4e64>
    8acc:	e6efc83a 	sub	r23,fp,sp
    8ad0:	d8c00b17 	ldw	r3,44(sp)
    8ad4:	4dd1883a 	add	r8,r9,r23
    8ad8:	922dc83a 	sub	r22,r18,r8
    8adc:	18001626 	beq	r3,zero,8b38 <___svfprintf_internal_r+0x338>
    8ae0:	48000a26 	beq	r9,zero,8b0c <___svfprintf_internal_r+0x30c>
    8ae4:	00800b44 	movi	r2,45
    8ae8:	d8800805 	stb	r2,32(sp)
    8aec:	88800117 	ldw	r2,4(r17)
    8af0:	01c00044 	movi	r7,1
    8af4:	d9800804 	addi	r6,sp,32
    8af8:	880b883a 	mov	r5,r17
    8afc:	a009883a 	mov	r4,r20
    8b00:	103ee83a 	callr	r2
    8b04:	10004a1e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8b08:	84000044 	addi	r16,r16,1
    8b0c:	0580070e 	bge	zero,r22,8b2c <___svfprintf_internal_r+0x32c>
    8b10:	b00f883a 	mov	r7,r22
    8b14:	01800c04 	movi	r6,48
    8b18:	880b883a 	mov	r5,r17
    8b1c:	a009883a 	mov	r4,r20
    8b20:	00087940 	call	8794 <print_repeat>
    8b24:	1000421e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8b28:	85a1883a 	add	r16,r16,r22
    8b2c:	e02d883a 	mov	r22,fp
    8b30:	bf2fc83a 	sub	r23,r23,fp
    8b34:	00002006 	br	8bb8 <___svfprintf_internal_r+0x3b8>
    8b38:	0580090e 	bge	zero,r22,8b60 <___svfprintf_internal_r+0x360>
    8b3c:	b00f883a 	mov	r7,r22
    8b40:	01800804 	movi	r6,32
    8b44:	880b883a 	mov	r5,r17
    8b48:	a009883a 	mov	r4,r20
    8b4c:	da401015 	stw	r9,64(sp)
    8b50:	00087940 	call	8794 <print_repeat>
    8b54:	da401017 	ldw	r9,64(sp)
    8b58:	1000351e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8b5c:	85a1883a 	add	r16,r16,r22
    8b60:	483ff226 	beq	r9,zero,8b2c <_gp+0xffff4edc>
    8b64:	00800b44 	movi	r2,45
    8b68:	d8800805 	stb	r2,32(sp)
    8b6c:	88800117 	ldw	r2,4(r17)
    8b70:	01c00044 	movi	r7,1
    8b74:	d9800804 	addi	r6,sp,32
    8b78:	880b883a 	mov	r5,r17
    8b7c:	a009883a 	mov	r4,r20
    8b80:	103ee83a 	callr	r2
    8b84:	10002a1e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8b88:	84000044 	addi	r16,r16,1
    8b8c:	003fe706 	br	8b2c <_gp+0xffff4edc>
    8b90:	b5bfffc4 	addi	r22,r22,-1
    8b94:	b0800003 	ldbu	r2,0(r22)
    8b98:	01c00044 	movi	r7,1
    8b9c:	d9800804 	addi	r6,sp,32
    8ba0:	d8800805 	stb	r2,32(sp)
    8ba4:	88800117 	ldw	r2,4(r17)
    8ba8:	880b883a 	mov	r5,r17
    8bac:	a009883a 	mov	r4,r20
    8bb0:	103ee83a 	callr	r2
    8bb4:	10001e1e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8bb8:	8585c83a 	sub	r2,r16,r22
    8bbc:	b5c9883a 	add	r4,r22,r23
    8bc0:	e085883a 	add	r2,fp,r2
    8bc4:	013ff216 	blt	zero,r4,8b90 <_gp+0xffff4f40>
    8bc8:	1021883a 	mov	r16,r2
    8bcc:	dd800d17 	ldw	r22,52(sp)
    8bd0:	00004406 	br	8ce4 <___svfprintf_internal_r+0x4e4>
    8bd4:	00800044 	movi	r2,1
    8bd8:	1480080e 	bge	r2,r18,8bfc <___svfprintf_internal_r+0x3fc>
    8bdc:	95ffffc4 	addi	r23,r18,-1
    8be0:	b80f883a 	mov	r7,r23
    8be4:	01800804 	movi	r6,32
    8be8:	880b883a 	mov	r5,r17
    8bec:	a009883a 	mov	r4,r20
    8bf0:	00087940 	call	8794 <print_repeat>
    8bf4:	10000e1e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8bf8:	85e1883a 	add	r16,r16,r23
    8bfc:	b0800017 	ldw	r2,0(r22)
    8c00:	01c00044 	movi	r7,1
    8c04:	d80d883a 	mov	r6,sp
    8c08:	d8800005 	stb	r2,0(sp)
    8c0c:	88800117 	ldw	r2,4(r17)
    8c10:	880b883a 	mov	r5,r17
    8c14:	a009883a 	mov	r4,r20
    8c18:	b5c00104 	addi	r23,r22,4
    8c1c:	103ee83a 	callr	r2
    8c20:	1000031e 	bne	r2,zero,8c30 <___svfprintf_internal_r+0x430>
    8c24:	84000044 	addi	r16,r16,1
    8c28:	b82d883a 	mov	r22,r23
    8c2c:	00002d06 	br	8ce4 <___svfprintf_internal_r+0x4e4>
    8c30:	00bfffc4 	movi	r2,-1
    8c34:	00003106 	br	8cfc <___svfprintf_internal_r+0x4fc>
    8c38:	b5c00017 	ldw	r23,0(r22)
    8c3c:	b7000104 	addi	fp,r22,4
    8c40:	b809883a 	mov	r4,r23
    8c44:	00087780 	call	8778 <strlen>
    8c48:	9091c83a 	sub	r8,r18,r2
    8c4c:	102d883a 	mov	r22,r2
    8c50:	0200090e 	bge	zero,r8,8c78 <___svfprintf_internal_r+0x478>
    8c54:	400f883a 	mov	r7,r8
    8c58:	01800804 	movi	r6,32
    8c5c:	880b883a 	mov	r5,r17
    8c60:	a009883a 	mov	r4,r20
    8c64:	da001015 	stw	r8,64(sp)
    8c68:	00087940 	call	8794 <print_repeat>
    8c6c:	da001017 	ldw	r8,64(sp)
    8c70:	103fef1e 	bne	r2,zero,8c30 <_gp+0xffff4fe0>
    8c74:	8221883a 	add	r16,r16,r8
    8c78:	88800117 	ldw	r2,4(r17)
    8c7c:	b00f883a 	mov	r7,r22
    8c80:	b80d883a 	mov	r6,r23
    8c84:	880b883a 	mov	r5,r17
    8c88:	a009883a 	mov	r4,r20
    8c8c:	103ee83a 	callr	r2
    8c90:	103fe71e 	bne	r2,zero,8c30 <_gp+0xffff4fe0>
    8c94:	85a1883a 	add	r16,r16,r22
    8c98:	e02d883a 	mov	r22,fp
    8c9c:	00001106 	br	8ce4 <___svfprintf_internal_r+0x4e4>
    8ca0:	00c00044 	movi	r3,1
    8ca4:	04ffffc4 	movi	r19,-1
    8ca8:	d8000e15 	stw	zero,56(sp)
    8cac:	d8c00a15 	stw	r3,40(sp)
    8cb0:	05400284 	movi	r21,10
    8cb4:	9825883a 	mov	r18,r19
    8cb8:	d8000c15 	stw	zero,48(sp)
    8cbc:	d8000b15 	stw	zero,44(sp)
    8cc0:	182f883a 	mov	r23,r3
    8cc4:	00000806 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    8cc8:	ddc00b15 	stw	r23,44(sp)
    8ccc:	05c00084 	movi	r23,2
    8cd0:	00000506 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    8cd4:	00c00044 	movi	r3,1
    8cd8:	d8c00c15 	stw	r3,48(sp)
    8cdc:	05c000c4 	movi	r23,3
    8ce0:	00000106 	br	8ce8 <___svfprintf_internal_r+0x4e8>
    8ce4:	002f883a 	mov	r23,zero
    8ce8:	d8c00f17 	ldw	r3,60(sp)
    8cec:	18c00044 	addi	r3,r3,1
    8cf0:	d8c00f15 	stw	r3,60(sp)
    8cf4:	003edc06 	br	8868 <_gp+0xffff4c18>
    8cf8:	8005883a 	mov	r2,r16
    8cfc:	dfc01a17 	ldw	ra,104(sp)
    8d00:	df001917 	ldw	fp,100(sp)
    8d04:	ddc01817 	ldw	r23,96(sp)
    8d08:	dd801717 	ldw	r22,92(sp)
    8d0c:	dd401617 	ldw	r21,88(sp)
    8d10:	dd001517 	ldw	r20,84(sp)
    8d14:	dcc01417 	ldw	r19,80(sp)
    8d18:	dc801317 	ldw	r18,76(sp)
    8d1c:	dc401217 	ldw	r17,72(sp)
    8d20:	dc001117 	ldw	r16,68(sp)
    8d24:	dec01b04 	addi	sp,sp,108
    8d28:	f800283a 	ret

00008d2c <__vfprintf_internal_unused>:
    8d2c:	00800074 	movhi	r2,1
    8d30:	10af1504 	addi	r2,r2,-17324
    8d34:	300f883a 	mov	r7,r6
    8d38:	280d883a 	mov	r6,r5
    8d3c:	200b883a 	mov	r5,r4
    8d40:	11000017 	ldw	r4,0(r2)
    8d44:	00088001 	jmpi	8800 <___svfprintf_internal_r>

00008d48 <print_repeat>:
    8d48:	defffb04 	addi	sp,sp,-20
    8d4c:	dc800315 	stw	r18,12(sp)
    8d50:	dc400215 	stw	r17,8(sp)
    8d54:	dc000115 	stw	r16,4(sp)
    8d58:	dfc00415 	stw	ra,16(sp)
    8d5c:	2025883a 	mov	r18,r4
    8d60:	2823883a 	mov	r17,r5
    8d64:	d9800005 	stb	r6,0(sp)
    8d68:	3821883a 	mov	r16,r7
    8d6c:	04000a0e 	bge	zero,r16,8d98 <print_repeat+0x50>
    8d70:	88800117 	ldw	r2,4(r17)
    8d74:	01c00044 	movi	r7,1
    8d78:	d80d883a 	mov	r6,sp
    8d7c:	880b883a 	mov	r5,r17
    8d80:	9009883a 	mov	r4,r18
    8d84:	103ee83a 	callr	r2
    8d88:	843fffc4 	addi	r16,r16,-1
    8d8c:	103ff726 	beq	r2,zero,8d6c <_gp+0xffff511c>
    8d90:	00bfffc4 	movi	r2,-1
    8d94:	00000106 	br	8d9c <print_repeat+0x54>
    8d98:	0005883a 	mov	r2,zero
    8d9c:	dfc00417 	ldw	ra,16(sp)
    8da0:	dc800317 	ldw	r18,12(sp)
    8da4:	dc400217 	ldw	r17,8(sp)
    8da8:	dc000117 	ldw	r16,4(sp)
    8dac:	dec00504 	addi	sp,sp,20
    8db0:	f800283a 	ret

00008db4 <___vfprintf_internal_r>:
    8db4:	deffe504 	addi	sp,sp,-108
    8db8:	d8c00804 	addi	r3,sp,32
    8dbc:	ddc01815 	stw	r23,96(sp)
    8dc0:	dd801715 	stw	r22,92(sp)
    8dc4:	dd401615 	stw	r21,88(sp)
    8dc8:	dd001515 	stw	r20,84(sp)
    8dcc:	dcc01415 	stw	r19,80(sp)
    8dd0:	dc801315 	stw	r18,76(sp)
    8dd4:	dc401215 	stw	r17,72(sp)
    8dd8:	dc001115 	stw	r16,68(sp)
    8ddc:	dfc01a15 	stw	ra,104(sp)
    8de0:	df001915 	stw	fp,100(sp)
    8de4:	2029883a 	mov	r20,r4
    8de8:	2823883a 	mov	r17,r5
    8dec:	382d883a 	mov	r22,r7
    8df0:	d9800f15 	stw	r6,60(sp)
    8df4:	0021883a 	mov	r16,zero
    8df8:	d8000e15 	stw	zero,56(sp)
    8dfc:	d8000a15 	stw	zero,40(sp)
    8e00:	002b883a 	mov	r21,zero
    8e04:	0027883a 	mov	r19,zero
    8e08:	0025883a 	mov	r18,zero
    8e0c:	d8000c15 	stw	zero,48(sp)
    8e10:	d8000b15 	stw	zero,44(sp)
    8e14:	002f883a 	mov	r23,zero
    8e18:	d8c00915 	stw	r3,36(sp)
    8e1c:	d8c00f17 	ldw	r3,60(sp)
    8e20:	19000003 	ldbu	r4,0(r3)
    8e24:	20803fcc 	andi	r2,r4,255
    8e28:	1080201c 	xori	r2,r2,128
    8e2c:	10bfe004 	addi	r2,r2,-128
    8e30:	10011e26 	beq	r2,zero,92ac <___vfprintf_internal_r+0x4f8>
    8e34:	00c00044 	movi	r3,1
    8e38:	b8c01426 	beq	r23,r3,8e8c <___vfprintf_internal_r+0xd8>
    8e3c:	1dc00216 	blt	r3,r23,8e48 <___vfprintf_internal_r+0x94>
    8e40:	b8000626 	beq	r23,zero,8e5c <___vfprintf_internal_r+0xa8>
    8e44:	00011506 	br	929c <___vfprintf_internal_r+0x4e8>
    8e48:	01400084 	movi	r5,2
    8e4c:	b9401d26 	beq	r23,r5,8ec4 <___vfprintf_internal_r+0x110>
    8e50:	014000c4 	movi	r5,3
    8e54:	b9402b26 	beq	r23,r5,8f04 <___vfprintf_internal_r+0x150>
    8e58:	00011006 	br	929c <___vfprintf_internal_r+0x4e8>
    8e5c:	01400944 	movi	r5,37
    8e60:	1140fc26 	beq	r2,r5,9254 <___vfprintf_internal_r+0x4a0>
    8e64:	88800117 	ldw	r2,4(r17)
    8e68:	d9000005 	stb	r4,0(sp)
    8e6c:	01c00044 	movi	r7,1
    8e70:	d80d883a 	mov	r6,sp
    8e74:	880b883a 	mov	r5,r17
    8e78:	a009883a 	mov	r4,r20
    8e7c:	103ee83a 	callr	r2
    8e80:	1000d81e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    8e84:	84000044 	addi	r16,r16,1
    8e88:	00010406 	br	929c <___vfprintf_internal_r+0x4e8>
    8e8c:	01400c04 	movi	r5,48
    8e90:	1140fa26 	beq	r2,r5,927c <___vfprintf_internal_r+0x4c8>
    8e94:	01400944 	movi	r5,37
    8e98:	11400a1e 	bne	r2,r5,8ec4 <___vfprintf_internal_r+0x110>
    8e9c:	d8800005 	stb	r2,0(sp)
    8ea0:	88800117 	ldw	r2,4(r17)
    8ea4:	b80f883a 	mov	r7,r23
    8ea8:	d80d883a 	mov	r6,sp
    8eac:	880b883a 	mov	r5,r17
    8eb0:	a009883a 	mov	r4,r20
    8eb4:	103ee83a 	callr	r2
    8eb8:	1000ca1e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    8ebc:	84000044 	addi	r16,r16,1
    8ec0:	0000f506 	br	9298 <___vfprintf_internal_r+0x4e4>
    8ec4:	25fff404 	addi	r23,r4,-48
    8ec8:	bdc03fcc 	andi	r23,r23,255
    8ecc:	00c00244 	movi	r3,9
    8ed0:	1dc00936 	bltu	r3,r23,8ef8 <___vfprintf_internal_r+0x144>
    8ed4:	00bfffc4 	movi	r2,-1
    8ed8:	90800426 	beq	r18,r2,8eec <___vfprintf_internal_r+0x138>
    8edc:	01400284 	movi	r5,10
    8ee0:	9009883a 	mov	r4,r18
    8ee4:	00095140 	call	9514 <__mulsi3>
    8ee8:	00000106 	br	8ef0 <___vfprintf_internal_r+0x13c>
    8eec:	0005883a 	mov	r2,zero
    8ef0:	b8a5883a 	add	r18,r23,r2
    8ef4:	0000e206 	br	9280 <___vfprintf_internal_r+0x4cc>
    8ef8:	01400b84 	movi	r5,46
    8efc:	1140e426 	beq	r2,r5,9290 <___vfprintf_internal_r+0x4dc>
    8f00:	05c00084 	movi	r23,2
    8f04:	213ff404 	addi	r4,r4,-48
    8f08:	27003fcc 	andi	fp,r4,255
    8f0c:	00c00244 	movi	r3,9
    8f10:	1f000936 	bltu	r3,fp,8f38 <___vfprintf_internal_r+0x184>
    8f14:	00bfffc4 	movi	r2,-1
    8f18:	98800426 	beq	r19,r2,8f2c <___vfprintf_internal_r+0x178>
    8f1c:	01400284 	movi	r5,10
    8f20:	9809883a 	mov	r4,r19
    8f24:	00095140 	call	9514 <__mulsi3>
    8f28:	00000106 	br	8f30 <___vfprintf_internal_r+0x17c>
    8f2c:	0005883a 	mov	r2,zero
    8f30:	e0a7883a 	add	r19,fp,r2
    8f34:	0000d906 	br	929c <___vfprintf_internal_r+0x4e8>
    8f38:	00c01b04 	movi	r3,108
    8f3c:	10c0d226 	beq	r2,r3,9288 <___vfprintf_internal_r+0x4d4>
    8f40:	013fffc4 	movi	r4,-1
    8f44:	99000226 	beq	r19,r4,8f50 <___vfprintf_internal_r+0x19c>
    8f48:	d8000b15 	stw	zero,44(sp)
    8f4c:	00000106 	br	8f54 <___vfprintf_internal_r+0x1a0>
    8f50:	04c00044 	movi	r19,1
    8f54:	01001a44 	movi	r4,105
    8f58:	11001626 	beq	r2,r4,8fb4 <___vfprintf_internal_r+0x200>
    8f5c:	20800916 	blt	r4,r2,8f84 <___vfprintf_internal_r+0x1d0>
    8f60:	010018c4 	movi	r4,99
    8f64:	11008826 	beq	r2,r4,9188 <___vfprintf_internal_r+0x3d4>
    8f68:	01001904 	movi	r4,100
    8f6c:	11001126 	beq	r2,r4,8fb4 <___vfprintf_internal_r+0x200>
    8f70:	01001604 	movi	r4,88
    8f74:	1100c81e 	bne	r2,r4,9298 <___vfprintf_internal_r+0x4e4>
    8f78:	00c00044 	movi	r3,1
    8f7c:	d8c00e15 	stw	r3,56(sp)
    8f80:	00001506 	br	8fd8 <___vfprintf_internal_r+0x224>
    8f84:	01001cc4 	movi	r4,115
    8f88:	11009826 	beq	r2,r4,91ec <___vfprintf_internal_r+0x438>
    8f8c:	20800416 	blt	r4,r2,8fa0 <___vfprintf_internal_r+0x1ec>
    8f90:	01001bc4 	movi	r4,111
    8f94:	1100c01e 	bne	r2,r4,9298 <___vfprintf_internal_r+0x4e4>
    8f98:	05400204 	movi	r21,8
    8f9c:	00000f06 	br	8fdc <___vfprintf_internal_r+0x228>
    8fa0:	01001d44 	movi	r4,117
    8fa4:	11000d26 	beq	r2,r4,8fdc <___vfprintf_internal_r+0x228>
    8fa8:	01001e04 	movi	r4,120
    8fac:	11000a26 	beq	r2,r4,8fd8 <___vfprintf_internal_r+0x224>
    8fb0:	0000b906 	br	9298 <___vfprintf_internal_r+0x4e4>
    8fb4:	d8c00a17 	ldw	r3,40(sp)
    8fb8:	b7000104 	addi	fp,r22,4
    8fbc:	18000726 	beq	r3,zero,8fdc <___vfprintf_internal_r+0x228>
    8fc0:	df000d15 	stw	fp,52(sp)
    8fc4:	b5c00017 	ldw	r23,0(r22)
    8fc8:	b800080e 	bge	r23,zero,8fec <___vfprintf_internal_r+0x238>
    8fcc:	05efc83a 	sub	r23,zero,r23
    8fd0:	02400044 	movi	r9,1
    8fd4:	00000606 	br	8ff0 <___vfprintf_internal_r+0x23c>
    8fd8:	05400404 	movi	r21,16
    8fdc:	b0c00104 	addi	r3,r22,4
    8fe0:	d8c00d15 	stw	r3,52(sp)
    8fe4:	b5c00017 	ldw	r23,0(r22)
    8fe8:	d8000a15 	stw	zero,40(sp)
    8fec:	0013883a 	mov	r9,zero
    8ff0:	d839883a 	mov	fp,sp
    8ff4:	b8001726 	beq	r23,zero,9054 <___vfprintf_internal_r+0x2a0>
    8ff8:	a80b883a 	mov	r5,r21
    8ffc:	b809883a 	mov	r4,r23
    9000:	da401015 	stw	r9,64(sp)
    9004:	00083fc0 	call	83fc <__udivsi3>
    9008:	a80b883a 	mov	r5,r21
    900c:	1009883a 	mov	r4,r2
    9010:	102d883a 	mov	r22,r2
    9014:	00095140 	call	9514 <__mulsi3>
    9018:	b885c83a 	sub	r2,r23,r2
    901c:	00c00244 	movi	r3,9
    9020:	da401017 	ldw	r9,64(sp)
    9024:	18800216 	blt	r3,r2,9030 <___vfprintf_internal_r+0x27c>
    9028:	10800c04 	addi	r2,r2,48
    902c:	00000506 	br	9044 <___vfprintf_internal_r+0x290>
    9030:	d8c00e17 	ldw	r3,56(sp)
    9034:	18000226 	beq	r3,zero,9040 <___vfprintf_internal_r+0x28c>
    9038:	10800dc4 	addi	r2,r2,55
    903c:	00000106 	br	9044 <___vfprintf_internal_r+0x290>
    9040:	108015c4 	addi	r2,r2,87
    9044:	e0800005 	stb	r2,0(fp)
    9048:	b02f883a 	mov	r23,r22
    904c:	e7000044 	addi	fp,fp,1
    9050:	003fe806 	br	8ff4 <_gp+0xffff53a4>
    9054:	e6efc83a 	sub	r23,fp,sp
    9058:	9dc5c83a 	sub	r2,r19,r23
    905c:	0080090e 	bge	zero,r2,9084 <___vfprintf_internal_r+0x2d0>
    9060:	e085883a 	add	r2,fp,r2
    9064:	01400c04 	movi	r5,48
    9068:	d8c00917 	ldw	r3,36(sp)
    906c:	e009883a 	mov	r4,fp
    9070:	e0c0032e 	bgeu	fp,r3,9080 <___vfprintf_internal_r+0x2cc>
    9074:	e7000044 	addi	fp,fp,1
    9078:	21400005 	stb	r5,0(r4)
    907c:	e0bffa1e 	bne	fp,r2,9068 <_gp+0xffff5418>
    9080:	e6efc83a 	sub	r23,fp,sp
    9084:	d8c00b17 	ldw	r3,44(sp)
    9088:	4dd1883a 	add	r8,r9,r23
    908c:	922dc83a 	sub	r22,r18,r8
    9090:	18001626 	beq	r3,zero,90ec <___vfprintf_internal_r+0x338>
    9094:	48000a26 	beq	r9,zero,90c0 <___vfprintf_internal_r+0x30c>
    9098:	00800b44 	movi	r2,45
    909c:	d8800805 	stb	r2,32(sp)
    90a0:	88800117 	ldw	r2,4(r17)
    90a4:	01c00044 	movi	r7,1
    90a8:	d9800804 	addi	r6,sp,32
    90ac:	880b883a 	mov	r5,r17
    90b0:	a009883a 	mov	r4,r20
    90b4:	103ee83a 	callr	r2
    90b8:	10004a1e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    90bc:	84000044 	addi	r16,r16,1
    90c0:	0580070e 	bge	zero,r22,90e0 <___vfprintf_internal_r+0x32c>
    90c4:	b00f883a 	mov	r7,r22
    90c8:	01800c04 	movi	r6,48
    90cc:	880b883a 	mov	r5,r17
    90d0:	a009883a 	mov	r4,r20
    90d4:	0008d480 	call	8d48 <print_repeat>
    90d8:	1000421e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    90dc:	85a1883a 	add	r16,r16,r22
    90e0:	e02d883a 	mov	r22,fp
    90e4:	bf2fc83a 	sub	r23,r23,fp
    90e8:	00002006 	br	916c <___vfprintf_internal_r+0x3b8>
    90ec:	0580090e 	bge	zero,r22,9114 <___vfprintf_internal_r+0x360>
    90f0:	b00f883a 	mov	r7,r22
    90f4:	01800804 	movi	r6,32
    90f8:	880b883a 	mov	r5,r17
    90fc:	a009883a 	mov	r4,r20
    9100:	da401015 	stw	r9,64(sp)
    9104:	0008d480 	call	8d48 <print_repeat>
    9108:	da401017 	ldw	r9,64(sp)
    910c:	1000351e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    9110:	85a1883a 	add	r16,r16,r22
    9114:	483ff226 	beq	r9,zero,90e0 <_gp+0xffff5490>
    9118:	00800b44 	movi	r2,45
    911c:	d8800805 	stb	r2,32(sp)
    9120:	88800117 	ldw	r2,4(r17)
    9124:	01c00044 	movi	r7,1
    9128:	d9800804 	addi	r6,sp,32
    912c:	880b883a 	mov	r5,r17
    9130:	a009883a 	mov	r4,r20
    9134:	103ee83a 	callr	r2
    9138:	10002a1e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    913c:	84000044 	addi	r16,r16,1
    9140:	003fe706 	br	90e0 <_gp+0xffff5490>
    9144:	b5bfffc4 	addi	r22,r22,-1
    9148:	b0800003 	ldbu	r2,0(r22)
    914c:	01c00044 	movi	r7,1
    9150:	d9800804 	addi	r6,sp,32
    9154:	d8800805 	stb	r2,32(sp)
    9158:	88800117 	ldw	r2,4(r17)
    915c:	880b883a 	mov	r5,r17
    9160:	a009883a 	mov	r4,r20
    9164:	103ee83a 	callr	r2
    9168:	10001e1e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    916c:	8585c83a 	sub	r2,r16,r22
    9170:	b5c9883a 	add	r4,r22,r23
    9174:	e085883a 	add	r2,fp,r2
    9178:	013ff216 	blt	zero,r4,9144 <_gp+0xffff54f4>
    917c:	1021883a 	mov	r16,r2
    9180:	dd800d17 	ldw	r22,52(sp)
    9184:	00004406 	br	9298 <___vfprintf_internal_r+0x4e4>
    9188:	00800044 	movi	r2,1
    918c:	1480080e 	bge	r2,r18,91b0 <___vfprintf_internal_r+0x3fc>
    9190:	95ffffc4 	addi	r23,r18,-1
    9194:	b80f883a 	mov	r7,r23
    9198:	01800804 	movi	r6,32
    919c:	880b883a 	mov	r5,r17
    91a0:	a009883a 	mov	r4,r20
    91a4:	0008d480 	call	8d48 <print_repeat>
    91a8:	10000e1e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    91ac:	85e1883a 	add	r16,r16,r23
    91b0:	b0800017 	ldw	r2,0(r22)
    91b4:	01c00044 	movi	r7,1
    91b8:	d80d883a 	mov	r6,sp
    91bc:	d8800005 	stb	r2,0(sp)
    91c0:	88800117 	ldw	r2,4(r17)
    91c4:	880b883a 	mov	r5,r17
    91c8:	a009883a 	mov	r4,r20
    91cc:	b5c00104 	addi	r23,r22,4
    91d0:	103ee83a 	callr	r2
    91d4:	1000031e 	bne	r2,zero,91e4 <___vfprintf_internal_r+0x430>
    91d8:	84000044 	addi	r16,r16,1
    91dc:	b82d883a 	mov	r22,r23
    91e0:	00002d06 	br	9298 <___vfprintf_internal_r+0x4e4>
    91e4:	00bfffc4 	movi	r2,-1
    91e8:	00003106 	br	92b0 <___vfprintf_internal_r+0x4fc>
    91ec:	b5c00017 	ldw	r23,0(r22)
    91f0:	b7000104 	addi	fp,r22,4
    91f4:	b809883a 	mov	r4,r23
    91f8:	00087780 	call	8778 <strlen>
    91fc:	9091c83a 	sub	r8,r18,r2
    9200:	102d883a 	mov	r22,r2
    9204:	0200090e 	bge	zero,r8,922c <___vfprintf_internal_r+0x478>
    9208:	400f883a 	mov	r7,r8
    920c:	01800804 	movi	r6,32
    9210:	880b883a 	mov	r5,r17
    9214:	a009883a 	mov	r4,r20
    9218:	da001015 	stw	r8,64(sp)
    921c:	0008d480 	call	8d48 <print_repeat>
    9220:	da001017 	ldw	r8,64(sp)
    9224:	103fef1e 	bne	r2,zero,91e4 <_gp+0xffff5594>
    9228:	8221883a 	add	r16,r16,r8
    922c:	88800117 	ldw	r2,4(r17)
    9230:	b00f883a 	mov	r7,r22
    9234:	b80d883a 	mov	r6,r23
    9238:	880b883a 	mov	r5,r17
    923c:	a009883a 	mov	r4,r20
    9240:	103ee83a 	callr	r2
    9244:	103fe71e 	bne	r2,zero,91e4 <_gp+0xffff5594>
    9248:	85a1883a 	add	r16,r16,r22
    924c:	e02d883a 	mov	r22,fp
    9250:	00001106 	br	9298 <___vfprintf_internal_r+0x4e4>
    9254:	00c00044 	movi	r3,1
    9258:	04ffffc4 	movi	r19,-1
    925c:	d8000e15 	stw	zero,56(sp)
    9260:	d8c00a15 	stw	r3,40(sp)
    9264:	05400284 	movi	r21,10
    9268:	9825883a 	mov	r18,r19
    926c:	d8000c15 	stw	zero,48(sp)
    9270:	d8000b15 	stw	zero,44(sp)
    9274:	182f883a 	mov	r23,r3
    9278:	00000806 	br	929c <___vfprintf_internal_r+0x4e8>
    927c:	ddc00b15 	stw	r23,44(sp)
    9280:	05c00084 	movi	r23,2
    9284:	00000506 	br	929c <___vfprintf_internal_r+0x4e8>
    9288:	00c00044 	movi	r3,1
    928c:	d8c00c15 	stw	r3,48(sp)
    9290:	05c000c4 	movi	r23,3
    9294:	00000106 	br	929c <___vfprintf_internal_r+0x4e8>
    9298:	002f883a 	mov	r23,zero
    929c:	d8c00f17 	ldw	r3,60(sp)
    92a0:	18c00044 	addi	r3,r3,1
    92a4:	d8c00f15 	stw	r3,60(sp)
    92a8:	003edc06 	br	8e1c <_gp+0xffff51cc>
    92ac:	8005883a 	mov	r2,r16
    92b0:	dfc01a17 	ldw	ra,104(sp)
    92b4:	df001917 	ldw	fp,100(sp)
    92b8:	ddc01817 	ldw	r23,96(sp)
    92bc:	dd801717 	ldw	r22,92(sp)
    92c0:	dd401617 	ldw	r21,88(sp)
    92c4:	dd001517 	ldw	r20,84(sp)
    92c8:	dcc01417 	ldw	r19,80(sp)
    92cc:	dc801317 	ldw	r18,76(sp)
    92d0:	dc401217 	ldw	r17,72(sp)
    92d4:	dc001117 	ldw	r16,68(sp)
    92d8:	dec01b04 	addi	sp,sp,108
    92dc:	f800283a 	ret

000092e0 <__vfprintf_internal>:
    92e0:	00800074 	movhi	r2,1
    92e4:	10af1504 	addi	r2,r2,-17324
    92e8:	300f883a 	mov	r7,r6
    92ec:	280d883a 	mov	r6,r5
    92f0:	200b883a 	mov	r5,r4
    92f4:	11000017 	ldw	r4,0(r2)
    92f8:	0008db41 	jmpi	8db4 <___vfprintf_internal_r>

000092fc <__sfvwrite_small_dev>:
    92fc:	2880000b 	ldhu	r2,0(r5)
    9300:	1080020c 	andi	r2,r2,8
    9304:	10002126 	beq	r2,zero,938c <__sfvwrite_small_dev+0x90>
    9308:	2880008f 	ldh	r2,2(r5)
    930c:	defffa04 	addi	sp,sp,-24
    9310:	dc000015 	stw	r16,0(sp)
    9314:	dfc00515 	stw	ra,20(sp)
    9318:	dd000415 	stw	r20,16(sp)
    931c:	dcc00315 	stw	r19,12(sp)
    9320:	dc800215 	stw	r18,8(sp)
    9324:	dc400115 	stw	r17,4(sp)
    9328:	2821883a 	mov	r16,r5
    932c:	10001216 	blt	r2,zero,9378 <__sfvwrite_small_dev+0x7c>
    9330:	2027883a 	mov	r19,r4
    9334:	3025883a 	mov	r18,r6
    9338:	3823883a 	mov	r17,r7
    933c:	05010004 	movi	r20,1024
    9340:	04400b0e 	bge	zero,r17,9370 <__sfvwrite_small_dev+0x74>
    9344:	880f883a 	mov	r7,r17
    9348:	a440010e 	bge	r20,r17,9350 <__sfvwrite_small_dev+0x54>
    934c:	01c10004 	movi	r7,1024
    9350:	8140008f 	ldh	r5,2(r16)
    9354:	900d883a 	mov	r6,r18
    9358:	9809883a 	mov	r4,r19
    935c:	00094bc0 	call	94bc <_write_r>
    9360:	0080050e 	bge	zero,r2,9378 <__sfvwrite_small_dev+0x7c>
    9364:	88a3c83a 	sub	r17,r17,r2
    9368:	90a5883a 	add	r18,r18,r2
    936c:	003ff406 	br	9340 <_gp+0xffff56f0>
    9370:	0005883a 	mov	r2,zero
    9374:	00000706 	br	9394 <__sfvwrite_small_dev+0x98>
    9378:	8080000b 	ldhu	r2,0(r16)
    937c:	10801014 	ori	r2,r2,64
    9380:	8080000d 	sth	r2,0(r16)
    9384:	00bfffc4 	movi	r2,-1
    9388:	00000206 	br	9394 <__sfvwrite_small_dev+0x98>
    938c:	00bfffc4 	movi	r2,-1
    9390:	f800283a 	ret
    9394:	dfc00517 	ldw	ra,20(sp)
    9398:	dd000417 	ldw	r20,16(sp)
    939c:	dcc00317 	ldw	r19,12(sp)
    93a0:	dc800217 	ldw	r18,8(sp)
    93a4:	dc400117 	ldw	r17,4(sp)
    93a8:	dc000017 	ldw	r16,0(sp)
    93ac:	dec00604 	addi	sp,sp,24
    93b0:	f800283a 	ret

000093b4 <__sfvwrite_small_str>:
    93b4:	2880000b 	ldhu	r2,0(r5)
    93b8:	10c0020c 	andi	r3,r2,8
    93bc:	18002026 	beq	r3,zero,9440 <__sfvwrite_small_str+0x8c>
    93c0:	28c0008f 	ldh	r3,2(r5)
    93c4:	defffd04 	addi	sp,sp,-12
    93c8:	dc000015 	stw	r16,0(sp)
    93cc:	dfc00215 	stw	ra,8(sp)
    93d0:	dc400115 	stw	r17,4(sp)
    93d4:	2821883a 	mov	r16,r5
    93d8:	1800150e 	bge	r3,zero,9430 <__sfvwrite_small_str+0x7c>
    93dc:	10c0800c 	andi	r3,r2,512
    93e0:	18001326 	beq	r3,zero,9430 <__sfvwrite_small_str+0x7c>
    93e4:	2c400517 	ldw	r17,20(r5)
    93e8:	89c0030e 	bge	r17,r7,93f8 <__sfvwrite_small_str+0x44>
    93ec:	10c0200c 	andi	r3,r2,128
    93f0:	18000326 	beq	r3,zero,9400 <__sfvwrite_small_str+0x4c>
    93f4:	00000e06 	br	9430 <__sfvwrite_small_str+0x7c>
    93f8:	3c40010e 	bge	r7,r17,9400 <__sfvwrite_small_str+0x4c>
    93fc:	3823883a 	mov	r17,r7
    9400:	81000417 	ldw	r4,16(r16)
    9404:	300b883a 	mov	r5,r6
    9408:	880d883a 	mov	r6,r17
    940c:	000945c0 	call	945c <memmove>
    9410:	80800517 	ldw	r2,20(r16)
    9414:	1445c83a 	sub	r2,r2,r17
    9418:	80800515 	stw	r2,20(r16)
    941c:	80800417 	ldw	r2,16(r16)
    9420:	1463883a 	add	r17,r2,r17
    9424:	84400415 	stw	r17,16(r16)
    9428:	0005883a 	mov	r2,zero
    942c:	00000606 	br	9448 <__sfvwrite_small_str+0x94>
    9430:	10801014 	ori	r2,r2,64
    9434:	8080000d 	sth	r2,0(r16)
    9438:	00bfffc4 	movi	r2,-1
    943c:	00000206 	br	9448 <__sfvwrite_small_str+0x94>
    9440:	00bfffc4 	movi	r2,-1
    9444:	f800283a 	ret
    9448:	dfc00217 	ldw	ra,8(sp)
    944c:	dc400117 	ldw	r17,4(sp)
    9450:	dc000017 	ldw	r16,0(sp)
    9454:	dec00304 	addi	sp,sp,12
    9458:	f800283a 	ret

0000945c <memmove>:
    945c:	2005883a 	mov	r2,r4
    9460:	218f883a 	add	r7,r4,r6
    9464:	29000236 	bltu	r5,r4,9470 <memmove+0x14>
    9468:	1007883a 	mov	r3,r2
    946c:	00000c06 	br	94a0 <memmove+0x44>
    9470:	2987883a 	add	r3,r5,r6
    9474:	20fffc2e 	bgeu	r4,r3,9468 <_gp+0xffff5818>
    9478:	380b883a 	mov	r5,r7
    947c:	30cdc83a 	sub	r6,r6,r3
    9480:	1989883a 	add	r4,r3,r6
    9484:	20000526 	beq	r4,zero,949c <memmove+0x40>
    9488:	18ffffc4 	addi	r3,r3,-1
    948c:	19000003 	ldbu	r4,0(r3)
    9490:	297fffc4 	addi	r5,r5,-1
    9494:	29000005 	stb	r4,0(r5)
    9498:	003ff906 	br	9480 <_gp+0xffff5830>
    949c:	f800283a 	ret
    94a0:	19c00526 	beq	r3,r7,94b8 <memmove+0x5c>
    94a4:	29000003 	ldbu	r4,0(r5)
    94a8:	18c00044 	addi	r3,r3,1
    94ac:	29400044 	addi	r5,r5,1
    94b0:	193fffc5 	stb	r4,-1(r3)
    94b4:	003ffa06 	br	94a0 <_gp+0xffff5850>
    94b8:	f800283a 	ret

000094bc <_write_r>:
    94bc:	defffd04 	addi	sp,sp,-12
    94c0:	dc000015 	stw	r16,0(sp)
    94c4:	04000074 	movhi	r16,1
    94c8:	dc400115 	stw	r17,4(sp)
    94cc:	842f9704 	addi	r16,r16,-16804
    94d0:	2023883a 	mov	r17,r4
    94d4:	2809883a 	mov	r4,r5
    94d8:	300b883a 	mov	r5,r6
    94dc:	380d883a 	mov	r6,r7
    94e0:	dfc00215 	stw	ra,8(sp)
    94e4:	80000015 	stw	zero,0(r16)
    94e8:	00096480 	call	9648 <write>
    94ec:	00ffffc4 	movi	r3,-1
    94f0:	10c0031e 	bne	r2,r3,9500 <_write_r+0x44>
    94f4:	80c00017 	ldw	r3,0(r16)
    94f8:	18000126 	beq	r3,zero,9500 <_write_r+0x44>
    94fc:	88c00015 	stw	r3,0(r17)
    9500:	dfc00217 	ldw	ra,8(sp)
    9504:	dc400117 	ldw	r17,4(sp)
    9508:	dc000017 	ldw	r16,0(sp)
    950c:	dec00304 	addi	sp,sp,12
    9510:	f800283a 	ret

00009514 <__mulsi3>:
    9514:	0005883a 	mov	r2,zero
    9518:	20000726 	beq	r4,zero,9538 <__mulsi3+0x24>
    951c:	20c0004c 	andi	r3,r4,1
    9520:	2008d07a 	srli	r4,r4,1
    9524:	18000126 	beq	r3,zero,952c <__mulsi3+0x18>
    9528:	1145883a 	add	r2,r2,r5
    952c:	294b883a 	add	r5,r5,r5
    9530:	203ffa1e 	bne	r4,zero,951c <_gp+0xffff58cc>
    9534:	f800283a 	ret
    9538:	f800283a 	ret

0000953c <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    953c:	deffff04 	addi	sp,sp,-4
    9540:	01000074 	movhi	r4,1
    9544:	01400074 	movhi	r5,1
    9548:	dfc00015 	stw	ra,0(sp)
    954c:	212ea904 	addi	r4,r4,-17756
    9550:	296f1d04 	addi	r5,r5,-17292

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    9554:	2140061e 	bne	r4,r5,9570 <alt_load+0x34>
    9558:	01000074 	movhi	r4,1
    955c:	01400074 	movhi	r5,1
    9560:	21200804 	addi	r4,r4,-32736
    9564:	29600804 	addi	r5,r5,-32736
    9568:	2140121e 	bne	r4,r5,95b4 <alt_load+0x78>
    956c:	00000b06 	br	959c <alt_load+0x60>
    9570:	00c00074 	movhi	r3,1
    9574:	18ef1d04 	addi	r3,r3,-17292
    9578:	1907c83a 	sub	r3,r3,r4
    957c:	0005883a 	mov	r2,zero
  {
    while( to != end )
    9580:	10fff526 	beq	r2,r3,9558 <_gp+0xffff5908>
    {
      *to++ = *from++;
    9584:	114f883a 	add	r7,r2,r5
    9588:	39c00017 	ldw	r7,0(r7)
    958c:	110d883a 	add	r6,r2,r4
    9590:	10800104 	addi	r2,r2,4
    9594:	31c00015 	stw	r7,0(r6)
    9598:	003ff906 	br	9580 <_gp+0xffff5930>
    959c:	01000074 	movhi	r4,1
    95a0:	01400074 	movhi	r5,1
    95a4:	212e7904 	addi	r4,r4,-17948
    95a8:	296e7904 	addi	r5,r5,-17948

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    95ac:	2140101e 	bne	r4,r5,95f0 <alt_load+0xb4>
    95b0:	00000b06 	br	95e0 <alt_load+0xa4>
    95b4:	00c00074 	movhi	r3,1
    95b8:	18e00804 	addi	r3,r3,-32736
    95bc:	1907c83a 	sub	r3,r3,r4
    95c0:	0005883a 	mov	r2,zero
  {
    while( to != end )
    95c4:	10fff526 	beq	r2,r3,959c <_gp+0xffff594c>
    {
      *to++ = *from++;
    95c8:	114f883a 	add	r7,r2,r5
    95cc:	39c00017 	ldw	r7,0(r7)
    95d0:	110d883a 	add	r6,r2,r4
    95d4:	10800104 	addi	r2,r2,4
    95d8:	31c00015 	stw	r7,0(r6)
    95dc:	003ff906 	br	95c4 <_gp+0xffff5974>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    95e0:	000b8940 	call	b894 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    95e4:	dfc00017 	ldw	ra,0(sp)
    95e8:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    95ec:	000b9801 	jmpi	b980 <alt_icache_flush_all>
    95f0:	00c00074 	movhi	r3,1
    95f4:	18eea904 	addi	r3,r3,-17756
    95f8:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    95fc:	0005883a 	mov	r2,zero
  {
    while( to != end )
    9600:	18bff726 	beq	r3,r2,95e0 <_gp+0xffff5990>
    {
      *to++ = *from++;
    9604:	114f883a 	add	r7,r2,r5
    9608:	39c00017 	ldw	r7,0(r7)
    960c:	110d883a 	add	r6,r2,r4
    9610:	10800104 	addi	r2,r2,4
    9614:	31c00015 	stw	r7,0(r6)
    9618:	003ff906 	br	9600 <_gp+0xffff59b0>

0000961c <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    961c:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    9620:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    9624:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    9628:	00096a80 	call	96a8 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    962c:	00096c80 	call	96c8 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    9630:	d1a08417 	ldw	r6,-32240(gp)
    9634:	d1608517 	ldw	r5,-32236(gp)
    9638:	d1208617 	ldw	r4,-32232(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    963c:	dfc00017 	ldw	ra,0(sp)
    9640:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    9644:	00080e41 	jmpi	80e4 <main>

00009648 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
    9648:	00800044 	movi	r2,1
    964c:	20800226 	beq	r4,r2,9658 <write+0x10>
    9650:	00800084 	movi	r2,2
    9654:	2080041e 	bne	r4,r2,9668 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
    9658:	01000074 	movhi	r4,1
    965c:	000f883a 	mov	r7,zero
    9660:	212f1604 	addi	r4,r4,-17320
    9664:	000b8601 	jmpi	b860 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
    9668:	d0a00817 	ldw	r2,-32736(gp)
    966c:	10000926 	beq	r2,zero,9694 <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
    9670:	deffff04 	addi	sp,sp,-4
    9674:	dfc00015 	stw	ra,0(sp)
    9678:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
    967c:	00c01444 	movi	r3,81
    9680:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
    9684:	00bfffc4 	movi	r2,-1
    9688:	dfc00017 	ldw	ra,0(sp)
    968c:	dec00104 	addi	sp,sp,4
    9690:	f800283a 	ret
    9694:	d0a08304 	addi	r2,gp,-32244
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
    9698:	00c01444 	movi	r3,81
    969c:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
    96a0:	00bfffc4 	movi	r2,-1
    96a4:	f800283a 	ret

000096a8 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    96a8:	deffff04 	addi	sp,sp,-4
    96ac:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
    96b0:	000b9840 	call	b984 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    96b4:	00800044 	movi	r2,1
    96b8:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    96bc:	dfc00017 	ldw	ra,0(sp)
    96c0:	dec00104 	addi	sp,sp,4
    96c4:	f800283a 	ret

000096c8 <alt_sys_init>:

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
    96c8:	01000074 	movhi	r4,1
    96cc:	d1600404 	addi	r5,gp,-32752
    96d0:	212ef304 	addi	r4,r4,-17460
    96d4:	000b8a01 	jmpi	b8a0 <alt_dev_llist_insert>

000096d8 <filename_to_upper_case>:
}
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
    96d8:	defffe04 	addi	sp,sp,-8
    96dc:	dc000015 	stw	r16,0(sp)
    96e0:	dfc00115 	stw	ra,4(sp)
    96e4:	2021883a 	mov	r16,r4
    int index;
    int length = strlen(file_name);
    96e8:	00087780 	call	8778 <strlen>
    
    for (index = 0; index < length; index++)
    96ec:	8007883a 	mov	r3,r16
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
    96f0:	01800644 	movi	r6,25
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
    96f4:	1c09c83a 	sub	r4,r3,r16
    96f8:	2080080e 	bge	r4,r2,971c <filename_to_upper_case+0x44>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
    96fc:	19000003 	ldbu	r4,0(r3)
    9700:	217fe7c4 	addi	r5,r4,-97
    9704:	29403fcc 	andi	r5,r5,255
    9708:	31400236 	bltu	r6,r5,9714 <filename_to_upper_case+0x3c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
    970c:	213ff804 	addi	r4,r4,-32
    9710:	19000005 	stb	r4,0(r3)
    9714:	18c00044 	addi	r3,r3,1
    9718:	003ff606 	br	96f4 <_gp+0xffff5aa4>
        }
    }
}
    971c:	dfc00117 	ldw	ra,4(sp)
    9720:	dc000017 	ldw	r16,0(sp)
    9724:	dec00204 	addi	sp,sp,8
    9728:	f800283a 	ret

0000972c <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
    972c:	defffe04 	addi	sp,sp,-8
    9730:	dc000015 	stw	r16,0(sp)
    9734:	dfc00115 	stw	ra,4(sp)
    9738:	2021883a 	mov	r16,r4
    int length = strlen(file_name);
    973c:	00087780 	call	8778 <strlen>
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    9740:	013fffc4 	movi	r4,-1
bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
    int length = strlen(file_name);
    int index;
    int last_dir_break_position = -1;
    9744:	200d883a 	mov	r6,r4
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    9748:	0007883a 	mov	r3,zero
    {
        if ((file_name[index] == ' ') ||
    974c:	02c00804 	movi	r11,32
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
    9750:	01c01704 	movi	r7,92
    9754:	02000bc4 	movi	r8,47
    9758:	03000244 	movi	r12,9
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
        {
            last_period = index;
            last_dir_break_position = index;
        }
        if (file_name[index] == '.')
    975c:	02400b84 	movi	r9,46
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
    9760:	034000c4 	movi	r13,3
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    9764:	1880180e 	bge	r3,r2,97c8 <check_file_name_for_FAT16_compliance+0x9c>
    {
        if ((file_name[index] == ' ') ||
    9768:	80cb883a 	add	r5,r16,r3
    976c:	29400007 	ldb	r5,0(r5)
    9770:	2ac01826 	beq	r5,r11,97d4 <check_file_name_for_FAT16_compliance+0xa8>
    9774:	1abfffc4 	addi	r10,r3,-1
    9778:	3280021e 	bne	r6,r10,9784 <check_file_name_for_FAT16_compliance+0x58>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
    977c:	29c01526 	beq	r5,r7,97d4 <check_file_name_for_FAT16_compliance+0xa8>
    9780:	2a001426 	beq	r5,r8,97d4 <check_file_name_for_FAT16_compliance+0xa8>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
    9784:	1915c83a 	sub	r10,r3,r4
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
    9788:	5300021e 	bne	r10,r12,9794 <check_file_name_for_FAT16_compliance+0x68>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
    978c:	2a401026 	beq	r5,r9,97d0 <check_file_name_for_FAT16_compliance+0xa4>
    9790:	00001006 	br	97d4 <check_file_name_for_FAT16_compliance+0xa8>
    9794:	31000426 	beq	r6,r4,97a8 <check_file_name_for_FAT16_compliance+0x7c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
    9798:	6a80030e 	bge	r13,r10,97a8 <check_file_name_for_FAT16_compliance+0x7c>
    979c:	29c00626 	beq	r5,r7,97b8 <check_file_name_for_FAT16_compliance+0x8c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
    97a0:	2a000526 	beq	r5,r8,97b8 <check_file_name_for_FAT16_compliance+0x8c>
    97a4:	00000b06 	br	97d4 <check_file_name_for_FAT16_compliance+0xa8>
           )
        {
            result = false;
            break;
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
    97a8:	29c00326 	beq	r5,r7,97b8 <check_file_name_for_FAT16_compliance+0x8c>
    97ac:	2a000226 	beq	r5,r8,97b8 <check_file_name_for_FAT16_compliance+0x8c>
        {
            last_period = index;
            last_dir_break_position = index;
        }
        if (file_name[index] == '.')
    97b0:	2a40031e 	bne	r5,r9,97c0 <check_file_name_for_FAT16_compliance+0x94>
    97b4:	00000106 	br	97bc <check_file_name_for_FAT16_compliance+0x90>
    97b8:	180d883a 	mov	r6,r3
    97bc:	1809883a 	mov	r4,r3
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    97c0:	18c00044 	addi	r3,r3,1
    97c4:	003fe706 	br	9764 <_gp+0xffff5b14>
{
    int length = strlen(file_name);
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    97c8:	00c00044 	movi	r3,1
    97cc:	00000206 	br	97d8 <check_file_name_for_FAT16_compliance+0xac>
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
    97d0:	313ffa26 	beq	r6,r4,97bc <_gp+0xffff5b6c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
             (file_name[index] != '\\') && (file_name[index] != '/'))
           )
        {
            result = false;
    97d4:	0007883a 	mov	r3,zero
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
    97d8:	8085883a 	add	r2,r16,r2
    97dc:	10bfffc7 	ldb	r2,-1(r2)
    97e0:	01001704 	movi	r4,92
    97e4:	11000226 	beq	r2,r4,97f0 <check_file_name_for_FAT16_compliance+0xc4>
    97e8:	01000bc4 	movi	r4,47
    97ec:	1100011e 	bne	r2,r4,97f4 <check_file_name_for_FAT16_compliance+0xc8>
    {
        result = false;
    97f0:	0007883a 	mov	r3,zero
    }
    return result;
}
    97f4:	1805883a 	mov	r2,r3
    97f8:	dfc00117 	ldw	ra,4(sp)
    97fc:	dc000017 	ldw	r16,0(sp)
    9800:	dec00204 	addi	sp,sp,8
    9804:	f800283a 	ret

00009808 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
    9808:	defffe04 	addi	sp,sp,-8
    980c:	dc000015 	stw	r16,0(sp)
    9810:	dfc00115 	stw	ra,4(sp)
    9814:	2021883a 	mov	r16,r4
    int index = 0;
    int length = strlen(name);
    9818:	00087780 	call	8778 <strlen>
    981c:	1009883a 	mov	r4,r2
    
    for(index = 0; index < length; index++)
    9820:	8007883a 	mov	r3,r16
    {
        if ((name[index] == '\\') || (name[index] == '/'))
    9824:	01801704 	movi	r6,92
    9828:	01c00bc4 	movi	r7,47
    982c:	1c05c83a 	sub	r2,r3,r16
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
    9830:	1100050e 	bge	r2,r4,9848 <get_dir_divider_location+0x40>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
    9834:	19400007 	ldb	r5,0(r3)
    9838:	29800526 	beq	r5,r6,9850 <get_dir_divider_location+0x48>
    983c:	18c00044 	addi	r3,r3,1
    9840:	29fffa1e 	bne	r5,r7,982c <_gp+0xffff5bdc>
    9844:	00000206 	br	9850 <get_dir_divider_location+0x48>
        {
            break;
        }
    }
    
    if (index == length)
    9848:	2080011e 	bne	r4,r2,9850 <get_dir_divider_location+0x48>
    {
        index = -1;
    984c:	00bfffc4 	movi	r2,-1
    }
    
    return index;
}
    9850:	dfc00117 	ldw	ra,4(sp)
    9854:	dc000017 	ldw	r16,0(sp)
    9858:	dec00204 	addi	sp,sp,8
    985c:	f800283a 	ret

00009860 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    9860:	2011883a 	mov	r8,r4
    9864:	21c00204 	addi	r7,r4,8
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
    9868:	02800644 	movi	r10,25
    986c:	40800003 	ldbu	r2,0(r8)
    9870:	10ffe7c4 	addi	r3,r2,-97
    9874:	18c03fcc 	andi	r3,r3,255
    9878:	50c00336 	bltu	r10,r3,9888 <match_file_record_to_name_ext+0x28>
    987c:	10bff804 	addi	r2,r2,-32
    9880:	10c03fcc 	andi	r3,r2,255
    9884:	00000306 	br	9894 <match_file_record_to_name_ext+0x34>
    9888:	10c03fcc 	andi	r3,r2,255
    988c:	18c0201c 	xori	r3,r3,128
    9890:	18ffe004 	addi	r3,r3,-128
    9894:	28800003 	ldbu	r2,0(r5)
    9898:	127fe7c4 	addi	r9,r2,-97
    989c:	4a403fcc 	andi	r9,r9,255
    98a0:	52400336 	bltu	r10,r9,98b0 <match_file_record_to_name_ext+0x50>
    98a4:	10bff804 	addi	r2,r2,-32
    98a8:	10803fcc 	andi	r2,r2,255
    98ac:	00000306 	br	98bc <match_file_record_to_name_ext+0x5c>
    98b0:	10803fcc 	andi	r2,r2,255
    98b4:	1080201c 	xori	r2,r2,128
    98b8:	10bfe004 	addi	r2,r2,-128
    98bc:	1880051e 	bne	r3,r2,98d4 <match_file_record_to_name_ext+0x74>
    98c0:	42000044 	addi	r8,r8,1
    98c4:	29400044 	addi	r5,r5,1
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
    98c8:	3a3fe81e 	bne	r7,r8,986c <_gp+0xffff5c1c>


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
    98cc:	00800044 	movi	r2,1
    98d0:	00000106 	br	98d8 <match_file_record_to_name_ext+0x78>

    for (index = 0; index < 8; index++)
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
        {
            match = false;
    98d4:	0005883a 	mov	r2,zero
    98d8:	210002c4 	addi	r4,r4,11
			break;
        }
    }
    for (index = 0; index < 3; index++)
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
    98dc:	02400644 	movi	r9,25
    98e0:	38c00003 	ldbu	r3,0(r7)
    98e4:	197fe7c4 	addi	r5,r3,-97
    98e8:	29403fcc 	andi	r5,r5,255
    98ec:	49400336 	bltu	r9,r5,98fc <match_file_record_to_name_ext+0x9c>
    98f0:	18fff804 	addi	r3,r3,-32
    98f4:	19403fcc 	andi	r5,r3,255
    98f8:	00000306 	br	9908 <match_file_record_to_name_ext+0xa8>
    98fc:	19403fcc 	andi	r5,r3,255
    9900:	2940201c 	xori	r5,r5,128
    9904:	297fe004 	addi	r5,r5,-128
    9908:	30c00003 	ldbu	r3,0(r6)
    990c:	1a3fe7c4 	addi	r8,r3,-97
    9910:	42003fcc 	andi	r8,r8,255
    9914:	4a000336 	bltu	r9,r8,9924 <match_file_record_to_name_ext+0xc4>
    9918:	18fff804 	addi	r3,r3,-32
    991c:	18c03fcc 	andi	r3,r3,255
    9920:	00000306 	br	9930 <match_file_record_to_name_ext+0xd0>
    9924:	18c03fcc 	andi	r3,r3,255
    9928:	18c0201c 	xori	r3,r3,128
    992c:	18ffe004 	addi	r3,r3,-128
    9930:	28c0041e 	bne	r5,r3,9944 <match_file_record_to_name_ext+0xe4>
    9934:	39c00044 	addi	r7,r7,1
    9938:	31800044 	addi	r6,r6,1
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
    993c:	21ffe81e 	bne	r4,r7,98e0 <_gp+0xffff5c90>
    9940:	f800283a 	ret
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
        {
            match = false;
    9944:	0005883a 	mov	r2,zero
			break;
        }
    }
	return match;
}
    9948:	f800283a 	ret

0000994c <convert_filename_to_name_extension>:
    return result;
}

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
    994c:	2a000204 	addi	r8,r5,8
    int counter;
    int local = 0;
    9950:	0005883a 	mov	r2,zero
    
    for(counter = 0; counter < 8; counter++)
    {
        if (filename[local] != '.')
    9954:	02400b84 	movi	r9,46
            name[counter] = filename[local];
            if (filename[local] != 0) local++;
        }
        else
        {
            name[counter] = ' ';
    9958:	02800804 	movi	r10,32
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
    {
        if (filename[local] != '.')
    995c:	2087883a 	add	r3,r4,r2
    9960:	19c00003 	ldbu	r7,0(r3)
    9964:	3ac03fcc 	andi	r11,r7,255
    9968:	5ac0201c 	xori	r11,r11,128
    996c:	5affe004 	addi	r11,r11,-128
    9970:	5a400526 	beq	r11,r9,9988 <convert_filename_to_name_extension+0x3c>
        {
            name[counter] = filename[local];
    9974:	29c00005 	stb	r7,0(r5)
            if (filename[local] != 0) local++;
    9978:	18c00007 	ldb	r3,0(r3)
    997c:	18000326 	beq	r3,zero,998c <convert_filename_to_name_extension+0x40>
    9980:	10800044 	addi	r2,r2,1
    9984:	00000106 	br	998c <convert_filename_to_name_extension+0x40>
        }
        else
        {
            name[counter] = ' ';
    9988:	2a800005 	stb	r10,0(r5)
    998c:	29400044 	addi	r5,r5,1
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
    9990:	2a3ff21e 	bne	r5,r8,995c <_gp+0xffff5d0c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    9994:	2087883a 	add	r3,r4,r2
    9998:	19400007 	ldb	r5,0(r3)
    999c:	00c00b84 	movi	r3,46
    99a0:	28c0011e 	bne	r5,r3,99a8 <convert_filename_to_name_extension+0x5c>
    99a4:	10800044 	addi	r2,r2,1
    99a8:	314000c4 	addi	r5,r6,3
            extension[counter] = filename[local];
            local++;
        }
        else
        {
            extension[counter] = ' ';
    99ac:	01c00804 	movi	r7,32
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
    {
        if (filename[local] != 0)
    99b0:	2087883a 	add	r3,r4,r2
    99b4:	18c00003 	ldbu	r3,0(r3)
    99b8:	1a003fcc 	andi	r8,r3,255
    99bc:	4200201c 	xori	r8,r8,128
    99c0:	423fe004 	addi	r8,r8,-128
    99c4:	40000326 	beq	r8,zero,99d4 <convert_filename_to_name_extension+0x88>
        {
            extension[counter] = filename[local];
    99c8:	30c00005 	stb	r3,0(r6)
            local++;
    99cc:	10800044 	addi	r2,r2,1
    99d0:	00000106 	br	99d8 <convert_filename_to_name_extension+0x8c>
        }
        else
        {
            extension[counter] = ' ';
    99d4:	31c00005 	stb	r7,0(r6)
    99d8:	31800044 	addi	r6,r6,1
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
    99dc:	29bff41e 	bne	r5,r6,99b0 <_gp+0xffff5d60>
        {
            extension[counter] = ' ';
        }
    }

}
    99e0:	f800283a 	ret

000099e4 <copy_file_record_name_to_string>:
}


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
    99e4:	200d883a 	mov	r6,r4
    99e8:	20c00204 	addi	r3,r4,8
	int index;
	int flength = 0;
    99ec:	0005883a 	mov	r2,zero

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
	{
		if (file_record->name[index] != ' ')
    99f0:	02000804 	movi	r8,32
    99f4:	31c00003 	ldbu	r7,0(r6)
    99f8:	3a403fcc 	andi	r9,r7,255
    99fc:	4a000326 	beq	r9,r8,9a0c <copy_file_record_name_to_string+0x28>
		{
			file_name[flength] = file_record->name[index];
    9a00:	2893883a 	add	r9,r5,r2
    9a04:	49c00005 	stb	r7,0(r9)
			flength = flength + 1;
    9a08:	10800044 	addi	r2,r2,1
    9a0c:	31800044 	addi	r6,r6,1
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
    9a10:	30fff81e 	bne	r6,r3,99f4 <_gp+0xffff5da4>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
    9a14:	21c00203 	ldbu	r7,8(r4)
    9a18:	01800804 	movi	r6,32
    9a1c:	39800e26 	beq	r7,r6,9a58 <copy_file_record_name_to_string+0x74>
	{
		file_name[flength] = '.';
    9a20:	288d883a 	add	r6,r5,r2
    9a24:	01c00b84 	movi	r7,46
    9a28:	31c00005 	stb	r7,0(r6)
		flength = flength + 1;
    9a2c:	10800044 	addi	r2,r2,1
    9a30:	210002c4 	addi	r4,r4,11
		for (index = 0; index < 3; index++)
		{
			if (file_record->extension[index] != ' ')
    9a34:	01c00804 	movi	r7,32
    9a38:	19800003 	ldbu	r6,0(r3)
    9a3c:	32003fcc 	andi	r8,r6,255
    9a40:	41c00326 	beq	r8,r7,9a50 <copy_file_record_name_to_string+0x6c>
			{
				file_name[flength] = file_record->extension[index];
    9a44:	2891883a 	add	r8,r5,r2
    9a48:	41800005 	stb	r6,0(r8)
				flength = flength + 1;
    9a4c:	10800044 	addi	r2,r2,1
    9a50:	18c00044 	addi	r3,r3,1
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
    9a54:	20fff81e 	bne	r4,r3,9a38 <_gp+0xffff5de8>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
    9a58:	2885883a 	add	r2,r5,r2
    9a5c:	10000005 	stb	zero,0(r2)
    9a60:	f800283a 	ret

00009a64 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
    9a64:	deffff04 	addi	sp,sp,-4
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
    9a68:	d1600404 	addi	r5,gp,-32752
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
    9a6c:	dfc00015 	stw	ra,0(sp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
    9a70:	000b90c0 	call	b90c <alt_find_dev>

	if (dev != NULL)
    9a74:	10001226 	beq	r2,zero,9ac0 <alt_up_sd_card_open_dev+0x5c>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
    9a78:	10c00a17 	ldw	r3,40(r2)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
    9a7c:	d0a08915 	stw	r2,-32220(gp)
		initialized = false;
    9a80:	d0209315 	stw	zero,-32180(gp)
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);

	if (dev != NULL)
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
    9a84:	19008d04 	addi	r4,r3,564
    9a88:	d1209115 	stw	r4,-32188(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
    9a8c:	19008904 	addi	r4,r3,548
    9a90:	d1209015 	stw	r4,-32192(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
    9a94:	19008404 	addi	r4,r3,528
    9a98:	d1208f15 	stw	r4,-32196(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
    9a9c:	19008c04 	addi	r4,r3,560
    9aa0:	d1208e15 	stw	r4,-32200(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
    9aa4:	d0e08c15 	stw	r3,-32208(gp)
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
    9aa8:	19008b04 	addi	r4,r3,556
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
		search_data.valid = false;
    9aac:	00c00074 	movhi	r3,1
    9ab0:	18f03004 	addi	r3,r3,-16192
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
    9ab4:	d1208d15 	stw	r4,-32204(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
    9ab8:	d0209215 	stw	zero,-32184(gp)
		search_data.valid = false;
    9abc:	18000415 	stw	zero,16(r3)
	}
	return dev;
}
    9ac0:	dfc00017 	ldw	ra,0(sp)
    9ac4:	dec00104 	addi	sp,sp,4
    9ac8:	f800283a 	ret

00009acc <alt_up_sd_card_is_Present>:
bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
    9acc:	d0e08917 	ldw	r3,-32220(gp)
    9ad0:	00800044 	movi	r2,1
    9ad4:	1800031e 	bne	r3,zero,9ae4 <alt_up_sd_card_is_Present+0x18>
    {
        result = true;
    }
	else if (initialized == true)
    9ad8:	d0e09317 	ldw	r3,-32180(gp)
    9adc:	1880131e 	bne	r3,r2,9b2c <alt_up_sd_card_is_Present+0x60>
    9ae0:	00000506 	br	9af8 <alt_up_sd_card_is_Present+0x2c>
bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
    9ae4:	d0e09117 	ldw	r3,-32188(gp)
    9ae8:	18c0002b 	ldhuio	r3,0(r3)
    9aec:	18c0008c 	andi	r3,r3,2
    9af0:	183ff926 	beq	r3,zero,9ad8 <_gp+0xffff5e88>
    9af4:	f800283a 	ret
	else if (initialized == true)
	{
		int index;

		initialized = false;
		search_data.valid = false;
    9af8:	00800074 	movhi	r2,1
    9afc:	10b03004 	addi	r2,r2,-16192
    9b00:	10000415 	stw	zero,16(r2)
    9b04:	00800074 	movhi	r2,1
    }
	else if (initialized == true)
	{
		int index;

		initialized = false;
    9b08:	d0209315 	stw	zero,-32180(gp)
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;
    9b0c:	d0209215 	stw	zero,-32184(gp)
    9b10:	10b05904 	addi	r2,r2,-16028
    9b14:	00c00504 	movi	r3,20

		for(index = 0; index < MAX_FILES_OPENED; index++)
		{
			active_files[index].in_use = false;
    9b18:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
    9b1c:	103fff15 	stw	zero,-4(r2)
    9b20:	18ffffc4 	addi	r3,r3,-1
    9b24:	10801004 	addi	r2,r2,64

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
    9b28:	183ffb1e 	bne	r3,zero,9b18 <_gp+0xffff5ec8>


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;
    9b2c:	0005883a 	mov	r2,zero
    9b30:	f800283a 	ret

00009b34 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
    9b34:	defffd04 	addi	sp,sp,-12
    9b38:	dc400115 	stw	r17,4(sp)
    9b3c:	dc000015 	stw	r16,0(sp)
    9b40:	dfc00215 	stw	ra,8(sp)
    9b44:	2023883a 	mov	r17,r4
    9b48:	2821883a 	mov	r16,r5
    bool result = false;
    
    if (alt_up_sd_card_is_Present())
    9b4c:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    9b50:	1000021e 	bne	r2,zero,9b5c <Write_Sector_Data+0x28>

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
    bool result = false;
    9b54:	0005883a 	mov	r2,zero
    9b58:	00001106 	br	9ba0 <Write_Sector_Data+0x6c>
    {
        short int reg_state = 0xff;

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
    9b5c:	8c09883a 	add	r4,r17,r16
    9b60:	2006927a 	slli	r3,r4,9
    9b64:	d0a08d17 	ldw	r2,-32204(gp)
    9b68:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
    9b6c:	d0a08e17 	ldw	r2,-32200(gp)
    9b70:	00c00604 	movi	r3,24
    9b74:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
    9b78:	d0a09117 	ldw	r2,-32188(gp)
    9b7c:	1080002b 	ldhuio	r2,0(r2)
    9b80:	10bfffcc 	andi	r2,r2,65535
        } while ((reg_state & 0x04)!=0);
    9b84:	10c0010c 	andi	r3,r2,4
    9b88:	183ffb1e 	bne	r3,zero,9b78 <_gp+0xffff5f28>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
    9b8c:	1080040c 	andi	r2,r2,16
    9b90:	103ff01e 	bne	r2,zero,9b54 <_gp+0xffff5f04>
        {
            result = true;
            current_sector_modified = false;
    9b94:	d0208815 	stw	zero,-32224(gp)
            current_sector_index = sector_index+partition_offset;
    9b98:	d1208715 	stw	r4,-32228(gp)
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
        } while ((reg_state & 0x04)!=0);
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
        {
            result = true;
    9b9c:	00800044 	movi	r2,1
            current_sector_modified = false;
            current_sector_index = sector_index+partition_offset;
        }
    }
    return result;
}
    9ba0:	dfc00217 	ldw	ra,8(sp)
    9ba4:	dc400117 	ldw	r17,4(sp)
    9ba8:	dc000017 	ldw	r16,0(sp)
    9bac:	dec00304 	addi	sp,sp,12
    9bb0:	f800283a 	ret

00009bb4 <Save_Modified_Sector>:

bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
    bool result = true;
    if (current_sector_modified)
    9bb4:	d0a08817 	ldw	r2,-32224(gp)
    9bb8:	10000326 	beq	r2,zero,9bc8 <Save_Modified_Sector+0x14>
    {
        result = Write_Sector_Data(current_sector_index, 0);
    9bbc:	d1208717 	ldw	r4,-32228(gp)
    9bc0:	000b883a 	mov	r5,zero
    9bc4:	0009b341 	jmpi	9b34 <Write_Sector_Data>
    }
    return result;
}
    9bc8:	00800044 	movi	r2,1
    9bcc:	f800283a 	ret

00009bd0 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
    9bd0:	defffd04 	addi	sp,sp,-12
    9bd4:	dc400115 	stw	r17,4(sp)
    9bd8:	dc000015 	stw	r16,0(sp)
    9bdc:	dfc00215 	stw	ra,8(sp)
    9be0:	2023883a 	mov	r17,r4
    9be4:	2821883a 	mov	r16,r5
	bool result = false;
    
	if (alt_up_sd_card_is_Present())
    9be8:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    9bec:	1000021e 	bne	r2,zero,9bf8 <Read_Sector_Data+0x28>


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
	bool result = false;
    9bf0:	0005883a 	mov	r2,zero
    9bf4:	00001906 	br	9c5c <Read_Sector_Data+0x8c>
	if (alt_up_sd_card_is_Present())
	{
		short int reg_state = 0xff;
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
    9bf8:	d0a08817 	ldw	r2,-32224(gp)
    9bfc:	1000081e 	bne	r2,zero,9c20 <Read_Sector_Data+0x50>
                return false;
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
    9c00:	8c09883a 	add	r4,r17,r16
    9c04:	2006927a 	slli	r3,r4,9
    9c08:	d0a08d17 	ldw	r2,-32204(gp)
    9c0c:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
    9c10:	d0a08e17 	ldw	r2,-32200(gp)
    9c14:	00c00444 	movi	r3,17
    9c18:	10c0002d 	sthio	r3,0(r2)
    9c1c:	00000506 	br	9c34 <Read_Sector_Data+0x64>
		short int reg_state = 0xff;
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
    9c20:	d1208717 	ldw	r4,-32228(gp)
    9c24:	000b883a 	mov	r5,zero
    9c28:	0009b340 	call	9b34 <Write_Sector_Data>
    9c2c:	103ff41e 	bne	r2,zero,9c00 <_gp+0xffff5fb0>
    9c30:	003fef06 	br	9bf0 <_gp+0xffff5fa0>
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
    9c34:	d0a09117 	ldw	r2,-32188(gp)
    9c38:	1080002b 	ldhuio	r2,0(r2)
    9c3c:	10bfffcc 	andi	r2,r2,65535
		} while ((reg_state & 0x04)!=0);
    9c40:	10c0010c 	andi	r3,r2,4
    9c44:	183ffb1e 	bne	r3,zero,9c34 <_gp+0xffff5fe4>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
    9c48:	1080040c 	andi	r2,r2,16
    9c4c:	103fe81e 	bne	r2,zero,9bf0 <_gp+0xffff5fa0>
		{
			result = true;
            current_sector_modified = false;
    9c50:	d0208815 	stw	zero,-32224(gp)
            current_sector_index = sector_index+partition_offset;
    9c54:	d1208715 	stw	r4,-32228(gp)
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
		} while ((reg_state & 0x04)!=0);
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
		{
			result = true;
    9c58:	00800044 	movi	r2,1
            current_sector_modified = false;
            current_sector_index = sector_index+partition_offset;
		}
	}
	return result;
}
    9c5c:	dfc00217 	ldw	ra,8(sp)
    9c60:	dc400117 	ldw	r17,4(sp)
    9c64:	dc000017 	ldw	r16,0(sp)
    9c68:	dec00304 	addi	sp,sp,12
    9c6c:	f800283a 	ret

00009c70 <get_cluster_flag>:
bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9c70:	00800074 	movhi	r2,1
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9c74:	defffd04 	addi	sp,sp,-12
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9c78:	10b03504 	addi	r2,r2,-16172
    9c7c:	10801117 	ldw	r2,68(r2)
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9c80:	dc000015 	stw	r16,0(sp)
    9c84:	2021883a 	mov	r16,r4
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9c88:	d1208b17 	ldw	r4,-32212(gp)
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9c8c:	dc400115 	stw	r17,4(sp)
    9c90:	dfc00215 	stw	ra,8(sp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9c94:	2089883a 	add	r4,r4,r2
    9c98:	8004d23a 	srli	r2,r16,8
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9c9c:	2823883a 	mov	r17,r5
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9ca0:	2089883a 	add	r4,r4,r2
     
    if (sector_index != current_sector_index)
    9ca4:	d0a08717 	ldw	r2,-32228(gp)
    9ca8:	2080091e 	bne	r4,r2,9cd0 <get_cluster_flag+0x60>
        if (Read_Sector_Data(sector_index, 0) == false)
        {
            return false;
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
    9cac:	d0a08917 	ldw	r2,-32220(gp)
    9cb0:	84003fcc 	andi	r16,r16,255
    9cb4:	8421883a 	add	r16,r16,r16
    9cb8:	10800a17 	ldw	r2,40(r2)
    9cbc:	80a1883a 	add	r16,r16,r2
    9cc0:	8080002b 	ldhuio	r2,0(r16)
    9cc4:	8880000d 	sth	r2,0(r17)
    return true;
    9cc8:	00800044 	movi	r2,1
    9ccc:	00000306 	br	9cdc <get_cluster_flag+0x6c>
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
     
    if (sector_index != current_sector_index)
    {
        if (Read_Sector_Data(sector_index, 0) == false)
    9cd0:	000b883a 	mov	r5,zero
    9cd4:	0009bd00 	call	9bd0 <Read_Sector_Data>
    9cd8:	103ff41e 	bne	r2,zero,9cac <_gp+0xffff605c>
            return false;
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
    return true;
}
    9cdc:	dfc00217 	ldw	ra,8(sp)
    9ce0:	dc400117 	ldw	r17,4(sp)
    9ce4:	dc000017 	ldw	r16,0(sp)
    9ce8:	dec00304 	addi	sp,sp,12
    9cec:	f800283a 	ret

00009cf0 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9cf0:	defffd04 	addi	sp,sp,-12
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    9cf4:	d0a08b17 	ldw	r2,-32212(gp)
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9cf8:	dc000015 	stw	r16,0(sp)
    9cfc:	2021883a 	mov	r16,r4
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    9d00:	2008d23a 	srli	r4,r4,8
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9d04:	dc400115 	stw	r17,4(sp)
    9d08:	dfc00215 	stw	ra,8(sp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    9d0c:	2089883a 	add	r4,r4,r2
    9d10:	00800074 	movhi	r2,1
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9d14:	2823883a 	mov	r17,r5
    9d18:	10b03504 	addi	r2,r2,-16172
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    
    if (first_fat)
    9d1c:	30000226 	beq	r6,zero,9d28 <mark_cluster+0x38>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9d20:	10801117 	ldw	r2,68(r2)
    9d24:	00000106 	br	9d2c <mark_cluster+0x3c>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
    9d28:	10801217 	ldw	r2,72(r2)
    9d2c:	2089883a 	add	r4,r4,r2
    }
     
    if (sector_index != current_sector_index)
    9d30:	d0a08717 	ldw	r2,-32228(gp)
    9d34:	2080091e 	bne	r4,r2,9d5c <mark_cluster+0x6c>
        if (Read_Sector_Data(sector_index, 0) == false)
        {
            return false;
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
    9d38:	d0a08917 	ldw	r2,-32220(gp)
    9d3c:	84003fcc 	andi	r16,r16,255
    9d40:	8421883a 	add	r16,r16,r16
    9d44:	10800a17 	ldw	r2,40(r2)
    9d48:	80a1883a 	add	r16,r16,r2
    9d4c:	8440002d 	sthio	r17,0(r16)
    current_sector_modified = true;
    9d50:	00800044 	movi	r2,1
    9d54:	d0a08815 	stw	r2,-32224(gp)
    return true;
    9d58:	00000306 	br	9d68 <mark_cluster+0x78>
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
    }
     
    if (sector_index != current_sector_index)
    {
        if (Read_Sector_Data(sector_index, 0) == false)
    9d5c:	000b883a 	mov	r5,zero
    9d60:	0009bd00 	call	9bd0 <Read_Sector_Data>
    9d64:	103ff41e 	bne	r2,zero,9d38 <_gp+0xffff60e8>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
    current_sector_modified = true;
    return true;
}
    9d68:	dfc00217 	ldw	ra,8(sp)
    9d6c:	dc400117 	ldw	r17,4(sp)
    9d70:	dc000017 	ldw	r16,0(sp)
    9d74:	dec00304 	addi	sp,sp,12
    9d78:	f800283a 	ret

00009d7c <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
    9d7c:	deffff04 	addi	sp,sp,-4
	bool result = false;
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
    9d80:	000b883a 	mov	r5,zero
    9d84:	0009883a 	mov	r4,zero

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
    9d88:	dfc00015 	stw	ra,0(sp)
	bool result = false;
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
    9d8c:	0009bd00 	call	9bd0 <Read_Sector_Data>
    9d90:	1000021e 	bne	r2,zero,9d9c <Check_for_Master_Boot_Record+0x20>
bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
	bool result = false;
    9d94:	0005883a 	mov	r2,zero
    9d98:	00003706 	br	9e78 <Check_for_Master_Boot_Record+0xfc>
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
    9d9c:	d1e08917 	ldw	r7,-32220(gp)
    9da0:	38800a17 	ldw	r2,40(r7)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
    9da4:	10807faf 	ldhio	r2,510(r2)
    9da8:	00ea9554 	movui	r3,43605
    9dac:	10bfffcc 	andi	r2,r2,65535
    9db0:	10fff81e 	bne	r2,r3,9d94 <_gp+0xffff6144>
    9db4:	00806f84 	movi	r2,446
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
    9db8:	02400044 	movi	r9,1
    9dbc:	02bfff44 	movi	r10,-3
    9dc0:	02c00104 	movi	r11,4
    9dc4:	03000384 	movi	r12,14

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
    9dc8:	02007f84 	movi	r8,510
			{
				int partition_data_offset = (index * 16) + 0x01be;
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
    9dcc:	38c00a17 	ldw	r3,40(r7)
    9dd0:	18c00104 	addi	r3,r3,4
    9dd4:	1887883a 	add	r3,r3,r2
    9dd8:	18c00023 	ldbuio	r3,0(r3)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
    9ddc:	19003fcc 	andi	r4,r3,255
    9de0:	2100201c 	xori	r4,r4,128
    9de4:	213fe004 	addi	r4,r4,-128
    9de8:	22400626 	beq	r4,r9,9e04 <Check_for_Master_Boot_Record+0x88>
    9dec:	50c6703a 	and	r3,r10,r3
    9df0:	18c03fcc 	andi	r3,r3,255
    9df4:	18c0201c 	xori	r3,r3,128
    9df8:	18ffe004 	addi	r3,r3,-128
    9dfc:	1ac00126 	beq	r3,r11,9e04 <Check_for_Master_Boot_Record+0x88>
    9e00:	23001a1e 	bne	r4,r12,9e6c <Check_for_Master_Boot_Record+0xf0>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
    9e04:	38c00a17 	ldw	r3,40(r7)
    9e08:	19000284 	addi	r4,r3,10
    9e0c:	2089883a 	add	r4,r4,r2
    9e10:	2140002b 	ldhuio	r5,0(r4)
    9e14:	19000204 	addi	r4,r3,8
    9e18:	297fffcc 	andi	r5,r5,65535
    9e1c:	2089883a 	add	r4,r4,r2
    9e20:	2100002b 	ldhuio	r4,0(r4)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
    9e24:	19800384 	addi	r6,r3,14

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
    9e28:	213fffcc 	andi	r4,r4,65535
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
    9e2c:	308d883a 	add	r6,r6,r2
    9e30:	3180002b 	ldhuio	r6,0(r6)
    9e34:	18c00304 	addi	r3,r3,12
    9e38:	31bfffcc 	andi	r6,r6,65535
    9e3c:	1887883a 	add	r3,r3,r2
    9e40:	18c0002b 	ldhuio	r3,0(r3)
    9e44:	300c943a 	slli	r6,r6,16
    9e48:	18ffffcc 	andi	r3,r3,65535
    9e4c:	30c6b03a 	or	r3,r6,r3
		            
					// Check if the partition is valid
					if (partition_size > 0)
    9e50:	00c0060e 	bge	zero,r3,9e6c <Check_for_Master_Boot_Record+0xf0>
					{
						result = true;
						fat_partition_size_in_512_byte_sectors = partition_size;
						fat_partition_offset_in_512_byte_sectors = offset;
    9e54:	2804943a 	slli	r2,r5,16
		            
					// Check if the partition is valid
					if (partition_size > 0)
					{
						result = true;
						fat_partition_size_in_512_byte_sectors = partition_size;
    9e58:	d0e08a15 	stw	r3,-32216(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
    9e5c:	1104b03a 	or	r2,r2,r4
    9e60:	d0a08b15 	stw	r2,-32212(gp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
		            
					// Check if the partition is valid
					if (partition_size > 0)
					{
						result = true;
    9e64:	00800044 	movi	r2,1
    9e68:	00000306 	br	9e78 <Check_for_Master_Boot_Record+0xfc>
    9e6c:	10800404 	addi	r2,r2,16

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
    9e70:	123fd61e 	bne	r2,r8,9dcc <_gp+0xffff617c>
    9e74:	003fc706 	br	9d94 <_gp+0xffff6144>
			}
		}
	}

	return result;
}
    9e78:	dfc00017 	ldw	ra,0(sp)
    9e7c:	dec00104 	addi	sp,sp,4
    9e80:	f800283a 	ret

00009e84 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
    9e84:	defffa04 	addi	sp,sp,-24
	bool result = false;
	int counter = 0;
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
    9e88:	200b883a 	mov	r5,r4
    9e8c:	0009883a 	mov	r4,zero
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
    9e90:	dcc00315 	stw	r19,12(sp)
    9e94:	dfc00515 	stw	ra,20(sp)
    9e98:	dd000415 	stw	r20,16(sp)
    9e9c:	dc800215 	stw	r18,8(sp)
    9ea0:	dc400115 	stw	r17,4(sp)
    9ea4:	dc000015 	stw	r16,0(sp)
	bool result = false;
	int counter = 0;
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
    9ea8:	0009bd00 	call	9bd0 <Read_Sector_Data>
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
    9eac:	d4e08917 	ldw	r19,-32220(gp)
    9eb0:	98c00a17 	ldw	r3,40(r19)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
    9eb4:	19007faf 	ldhio	r4,510(r3)
    9eb8:	016a9554 	movui	r5,43605
    9ebc:	213fffcc 	andi	r4,r4,65535
    9ec0:	2140921e 	bne	r4,r5,a10c <Check_for_DOS_FAT+0x288>
    9ec4:	10009226 	beq	r2,zero,a110 <Check_for_DOS_FAT+0x28c>
	{
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
    9ec8:	18800023 	ldbuio	r2,0(r3)
    9ecc:	04000074 	movhi	r16,1
    9ed0:	84303504 	addi	r16,r16,-16172
    9ed4:	80800005 	stb	r2,0(r16)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
    9ed8:	18800063 	ldbuio	r2,1(r3)
    9edc:	80800045 	stb	r2,1(r16)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
    9ee0:	188000a3 	ldbuio	r2,2(r3)
		for (counter = 0; counter < 8; counter++)
    9ee4:	0007883a 	mov	r3,zero
	{
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
    9ee8:	80800085 	stb	r2,2(r16)
    9eec:	810000c4 	addi	r4,r16,3
		for (counter = 0; counter < 8; counter++)
    9ef0:	01400204 	movi	r5,8
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
    9ef4:	98800a17 	ldw	r2,40(r19)
    9ef8:	108000c4 	addi	r2,r2,3
    9efc:	10c5883a 	add	r2,r2,r3
    9f00:	10800023 	ldbuio	r2,0(r2)
    9f04:	20800005 	stb	r2,0(r4)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
    9f08:	18c00044 	addi	r3,r3,1
    9f0c:	21000044 	addi	r4,r4,1
    9f10:	197ff81e 	bne	r3,r5,9ef4 <_gp+0xffff62a4>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
    9f14:	98800a17 	ldw	r2,40(r19)
    9f18:	11000323 	ldbuio	r4,12(r2)
    9f1c:	21003fcc 	andi	r4,r4,255
    9f20:	10c002e3 	ldbuio	r3,11(r2)
    9f24:	2008923a 	slli	r4,r4,8
    9f28:	18c03fcc 	andi	r3,r3,255
    9f2c:	18c0201c 	xori	r3,r3,128
    9f30:	18ffe004 	addi	r3,r3,-128
    9f34:	20c6b03a 	or	r3,r4,r3
    9f38:	80c0030d 	sth	r3,12(r16)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
    9f3c:	10c00363 	ldbuio	r3,13(r2)
    9f40:	80c00385 	stb	r3,14(r16)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
    9f44:	10c003ab 	ldhuio	r3,14(r2)
    9f48:	80c0040d 	sth	r3,16(r16)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
    9f4c:	10c00423 	ldbuio	r3,16(r2)
    9f50:	80c00485 	stb	r3,18(r16)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
    9f54:	110004a3 	ldbuio	r4,18(r2)
    9f58:	21003fcc 	andi	r4,r4,255
    9f5c:	10c00463 	ldbuio	r3,17(r2)
    9f60:	2008923a 	slli	r4,r4,8
    9f64:	18c03fcc 	andi	r3,r3,255
    9f68:	20c6b03a 	or	r3,r4,r3
    9f6c:	80c0050d 	sth	r3,20(r16)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
    9f70:	10c00523 	ldbuio	r3,20(r2)
    9f74:	18c03fcc 	andi	r3,r3,255
    9f78:	148004e3 	ldbuio	r18,19(r2)
    9f7c:	1806923a 	slli	r3,r3,8
    9f80:	94803fcc 	andi	r18,r18,255
    9f84:	1ca4b03a 	or	r18,r3,r18
    9f88:	8480058d 	sth	r18,22(r16)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
    9f8c:	10c00563 	ldbuio	r3,21(r2)
    9f90:	80c00605 	stb	r3,24(r16)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
    9f94:	10c005ab 	ldhuio	r3,22(r2)
    9f98:	80c0068d 	sth	r3,26(r16)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
    9f9c:	10c0062b 	ldhuio	r3,24(r2)
    9fa0:	80c0070d 	sth	r3,28(r16)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
    9fa4:	10c006ab 	ldhuio	r3,26(r2)
    9fa8:	80c0078d 	sth	r3,30(r16)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
    9fac:	10c00737 	ldwio	r3,28(r2)
    9fb0:	80c00815 	stw	r3,32(r16)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
    9fb4:	15000837 	ldwio	r20,32(r2)
    9fb8:	85000915 	stw	r20,36(r16)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
    9fbc:	10800923 	ldbuio	r2,36(r2)
    9fc0:	80800a05 	stb	r2,40(r16)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
    9fc4:	98800a17 	ldw	r2,40(r19)
    9fc8:	10800963 	ldbuio	r2,37(r2)
    9fcc:	80800a45 	stb	r2,41(r16)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
    9fd0:	98800a17 	ldw	r2,40(r19)
    9fd4:	108009a3 	ldbuio	r2,38(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
    9fd8:	8100050b 	ldhu	r4,20(r16)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
    9fdc:	80800a85 	stb	r2,42(r16)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
    9fe0:	8440068b 	ldhu	r17,26(r16)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
    9fe4:	8080040b 	ldhu	r2,16(r16)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
    9fe8:	8140030b 	ldhu	r5,12(r16)
    9fec:	2008917a 	slli	r4,r4,5
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
    9ff0:	80801115 	stw	r2,68(r16)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
    9ff4:	1445883a 	add	r2,r2,r17
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
    9ff8:	88a3883a 	add	r17,r17,r2
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
    9ffc:	80801215 	stw	r2,72(r16)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
    a000:	84401315 	stw	r17,76(r16)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
    a004:	00083040 	call	8304 <__divsi3>
    a008:	1445883a 	add	r2,r2,r17
    a00c:	80801415 	stw	r2,80(r16)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
    a010:	913fffcc 	andi	r4,r18,65535
    a014:	81400383 	ldbu	r5,14(r16)
    a018:	20000226 	beq	r4,zero,a024 <Check_for_DOS_FAT+0x1a0>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
    a01c:	00083040 	call	8304 <__divsi3>
    a020:	00000206 	br	a02c <Check_for_DOS_FAT+0x1a8>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
    a024:	a009883a 	mov	r4,r20
    a028:	00083fc0 	call	83fc <__udivsi3>
		}
		if (num_clusters < 4087)
    a02c:	00c3fd84 	movi	r3,4086
    a030:	18800216 	blt	r3,r2,a03c <Check_for_DOS_FAT+0x1b8>
		{
			boot_sector_data.bits_for_cluster_index = 12;
    a034:	00800304 	movi	r2,12
    a038:	00000506 	br	a050 <Check_for_DOS_FAT+0x1cc>
		}
		else if (num_clusters <= 65517)
    a03c:	00fffb54 	movui	r3,65517
    a040:	18800216 	blt	r3,r2,a04c <Check_for_DOS_FAT+0x1c8>
		{
			boot_sector_data.bits_for_cluster_index = 16;
    a044:	00800404 	movi	r2,16
    a048:	00000106 	br	a050 <Check_for_DOS_FAT+0x1cc>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
    a04c:	00800804 	movi	r2,32
    a050:	01000074 	movhi	r4,1
    a054:	80801085 	stb	r2,66(r16)
    a058:	21303fc4 	addi	r4,r4,-16129
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
    a05c:	0007883a 	mov	r3,zero
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
    a060:	01400104 	movi	r5,4
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
    a064:	98800a17 	ldw	r2,40(r19)
    a068:	108009c4 	addi	r2,r2,39
    a06c:	10c5883a 	add	r2,r2,r3
    a070:	10800023 	ldbuio	r2,0(r2)
    a074:	20800005 	stb	r2,0(r4)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
    a078:	18c00044 	addi	r3,r3,1
    a07c:	21000044 	addi	r4,r4,1
    a080:	197ff81e 	bne	r3,r5,a064 <_gp+0xffff6414>
    a084:	01000074 	movhi	r4,1
    a088:	213040c4 	addi	r4,r4,-16125
    a08c:	0007883a 	mov	r3,zero
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
    a090:	014002c4 	movi	r5,11
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
    a094:	98800a17 	ldw	r2,40(r19)
    a098:	10800ac4 	addi	r2,r2,43
    a09c:	10c5883a 	add	r2,r2,r3
    a0a0:	10800023 	ldbuio	r2,0(r2)
    a0a4:	20800005 	stb	r2,0(r4)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
    a0a8:	18c00044 	addi	r3,r3,1
    a0ac:	21000044 	addi	r4,r4,1
    a0b0:	197ff81e 	bne	r3,r5,a094 <_gp+0xffff6444>
    a0b4:	01000074 	movhi	r4,1
    a0b8:	21304384 	addi	r4,r4,-16114
    a0bc:	0007883a 	mov	r3,zero
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
    a0c0:	01400204 	movi	r5,8
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
    a0c4:	98800a17 	ldw	r2,40(r19)
    a0c8:	10800d84 	addi	r2,r2,54
    a0cc:	10c5883a 	add	r2,r2,r3
    a0d0:	10800023 	ldbuio	r2,0(r2)
    a0d4:	20800005 	stb	r2,0(r4)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
    a0d8:	18c00044 	addi	r3,r3,1
    a0dc:	21000044 	addi	r4,r4,1
    a0e0:	197ff81e 	bne	r3,r5,a0c4 <_gp+0xffff6474>
    a0e4:	00c00074 	movhi	r3,1
    a0e8:	18f05904 	addi	r3,r3,-16028
    a0ec:	0005883a 	mov	r2,zero
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
    a0f0:	01000504 	movi	r4,20
		{
			active_files[counter].in_use = false;
    a0f4:	18000015 	stw	zero,0(r3)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
    a0f8:	10800044 	addi	r2,r2,1
    a0fc:	18c01004 	addi	r3,r3,64
    a100:	113ffc1e 	bne	r2,r4,a0f4 <_gp+0xffff64a4>
    a104:	00800044 	movi	r2,1
    a108:	00000106 	br	a110 <Check_for_DOS_FAT+0x28c>
		}
		result = true;
	}
    else
    {
        result = false;
    a10c:	0005883a 	mov	r2,zero
    }
	return result;
}
    a110:	dfc00517 	ldw	ra,20(sp)
    a114:	dd000417 	ldw	r20,16(sp)
    a118:	dcc00317 	ldw	r19,12(sp)
    a11c:	dc800217 	ldw	r18,8(sp)
    a120:	dc400117 	ldw	r17,4(sp)
    a124:	dc000017 	ldw	r16,0(sp)
    a128:	dec00604 	addi	sp,sp,24
    a12c:	f800283a 	ret

0000a130 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    a130:	00800074 	movhi	r2,1
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    a134:	defffb04 	addi	sp,sp,-20
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    a138:	10b03504 	addi	r2,r2,-16172
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    a13c:	dc400115 	stw	r17,4(sp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    a140:	14401117 	ldw	r17,68(r2)
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    a144:	dcc00315 	stw	r19,12(sp)
    a148:	dc800215 	stw	r18,8(sp)
    a14c:	dc000015 	stw	r16,0(sp)
    a150:	dfc00415 	stw	ra,16(sp)
    a154:	2027883a 	mov	r19,r4
    a158:	04000084 	movi	r16,2
    a15c:	1025883a 	mov	r18,r2
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
    a160:	90801217 	ldw	r2,72(r18)
    a164:	88801026 	beq	r17,r2,a1a8 <find_first_empty_cluster+0x78>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
    a168:	d1608b17 	ldw	r5,-32212(gp)
    a16c:	8809883a 	mov	r4,r17
    a170:	0009bd00 	call	9bd0 <Read_Sector_Data>
    a174:	10000a26 	beq	r2,zero,a1a0 <find_first_empty_cluster+0x70>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
    a178:	d0e08917 	ldw	r3,-32220(gp)
    a17c:	80803fcc 	andi	r2,r16,255
    a180:	1085883a 	add	r2,r2,r2
    a184:	18c00a17 	ldw	r3,40(r3)
    a188:	10c5883a 	add	r2,r2,r3
                if (cluster == 0)
    a18c:	1080002f 	ldhio	r2,0(r2)
    a190:	10000726 	beq	r2,zero,a1b0 <find_first_empty_cluster+0x80>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
    a194:	84000044 	addi	r16,r16,1
                } 
            } while ((cluster_index % 256) != 0);
    a198:	80803fcc 	andi	r2,r16,255
    a19c:	003ff506 	br	a174 <_gp+0xffff6524>
        }
        if (cluster == 0)
        {
            break;
        }
        sector++;
    a1a0:	8c400044 	addi	r17,r17,1
    a1a4:	003fee06 	br	a160 <_gp+0xffff6510>
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    unsigned int cluster_index = 2;
    short int cluster = -1;
    bool result = false;
    a1a8:	0005883a 	mov	r2,zero
    a1ac:	00000206 	br	a1b8 <find_first_empty_cluster+0x88>
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
    {
        *cluster_number = cluster_index;
    a1b0:	9c000015 	stw	r16,0(r19)
		result = true;
    a1b4:	00800044 	movi	r2,1
    }
    return result;
}
    a1b8:	dfc00417 	ldw	ra,16(sp)
    a1bc:	dcc00317 	ldw	r19,12(sp)
    a1c0:	dc800217 	ldw	r18,8(sp)
    a1c4:	dc400117 	ldw	r17,4(sp)
    a1c8:	dc000017 	ldw	r16,0(sp)
    a1cc:	dec00504 	addi	sp,sp,20
    a1d0:	f800283a 	ret

0000a1d4 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    a1d4:	defff504 	addi	sp,sp,-44
    a1d8:	dcc00515 	stw	r19,20(sp)
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a1dc:	04c00074 	movhi	r19,1
}


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    a1e0:	dd400715 	stw	r21,28(sp)
    a1e4:	dd000615 	stw	r20,24(sp)
    a1e8:	dc000215 	stw	r16,8(sp)
    a1ec:	dfc00a15 	stw	ra,40(sp)
    a1f0:	ddc00915 	stw	r23,36(sp)
    a1f4:	dd800815 	stw	r22,32(sp)
    a1f8:	dc800415 	stw	r18,16(sp)
    a1fc:	dc400315 	stw	r17,12(sp)
    a200:	2021883a 	mov	r16,r4
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a204:	9cf03504 	addi	r19,r19,-16172
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                    if ((leading_char == 0x00e5) || (leading_char == 0))
    a208:	05003944 	movi	r20,229
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    a20c:	05400404 	movi	r21,16
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a210:	99400383 	ldbu	r5,14(r19)
    a214:	813fff84 	addi	r4,r16,-2
    a218:	05c00074 	movhi	r23,1
    a21c:	00095140 	call	9514 <__mulsi3>
    a220:	9c801417 	ldw	r18,80(r19)
    a224:	bdf03504 	addi	r23,r23,-16172
    a228:	14a5883a 	add	r18,r2,r18
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a22c:	902d883a 	mov	r22,r18
    a230:	b8800383 	ldbu	r2,14(r23)
    a234:	b4a3c83a 	sub	r17,r22,r18
    a238:	8880040e 	bge	r17,r2,a24c <find_first_empty_record_in_a_subdirectory+0x78>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    a23c:	d1608b17 	ldw	r5,-32212(gp)
    a240:	b009883a 	mov	r4,r22
    a244:	0009bd00 	call	9bd0 <Read_Sector_Data>
    a248:	1000051e 	bne	r2,zero,a260 <find_first_empty_record_in_a_subdirectory+0x8c>
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
    a24c:	d9400104 	addi	r5,sp,4
    a250:	8009883a 	mov	r4,r16
    a254:	0009c700 	call	9c70 <get_cluster_flag>
    a258:	1000131e 	bne	r2,zero,a2a8 <find_first_empty_record_in_a_subdirectory+0xd4>
    a25c:	00003406 	br	a330 <find_first_empty_record_in_a_subdirectory+0x15c>
    a260:	0007883a 	mov	r3,zero
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
    a264:	d1208917 	ldw	r4,-32220(gp)
    a268:	1804917a 	slli	r2,r3,5
    a26c:	21000a17 	ldw	r4,40(r4)
    a270:	1105883a 	add	r2,r2,r4
    a274:	10800023 	ldbuio	r2,0(r2)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
    a278:	10803fcc 	andi	r2,r2,255
    a27c:	1500051e 	bne	r2,r20,a294 <find_first_empty_record_in_a_subdirectory+0xc0>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
    a280:	8804913a 	slli	r2,r17,4
    a284:	10c5883a 	add	r2,r2,r3
    a288:	1004943a 	slli	r2,r2,16
    a28c:	1404b03a 	or	r2,r2,r16
                        return result;
    a290:	00002c06 	br	a344 <find_first_empty_record_in_a_subdirectory+0x170>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                    if ((leading_char == 0x00e5) || (leading_char == 0))
    a294:	103ffa26 	beq	r2,zero,a280 <_gp+0xffff6630>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    a298:	18c00044 	addi	r3,r3,1
    a29c:	1d7ff11e 	bne	r3,r21,a264 <_gp+0xffff6614>
    a2a0:	b5800044 	addi	r22,r22,1
    a2a4:	003fe206 	br	a230 <_gp+0xffff65e0>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
    a2a8:	d880010b 	ldhu	r2,4(sp)
    a2ac:	00fffe14 	movui	r3,65528
    a2b0:	10bffe0c 	andi	r2,r2,65528
    a2b4:	10c01e1e 	bne	r2,r3,a330 <find_first_empty_record_in_a_subdirectory+0x15c>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
    a2b8:	d809883a 	mov	r4,sp
    a2bc:	000a1300 	call	a130 <find_first_empty_cluster>
    a2c0:	1000021e 	bne	r2,zero,a2cc <find_first_empty_record_in_a_subdirectory+0xf8>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a2c4:	00bfffc4 	movi	r2,-1
    a2c8:	00001606 	br	a324 <find_first_empty_record_in_a_subdirectory+0x150>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
    a2cc:	d940000f 	ldh	r5,0(sp)
    a2d0:	01800044 	movi	r6,1
    a2d4:	8009883a 	mov	r4,r16
    a2d8:	0009cf00 	call	9cf0 <mark_cluster>
    a2dc:	103ff926 	beq	r2,zero,a2c4 <_gp+0xffff6674>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
    a2e0:	d9000017 	ldw	r4,0(sp)
    a2e4:	01800044 	movi	r6,1
    a2e8:	017fffc4 	movi	r5,-1
    a2ec:	0009cf00 	call	9cf0 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
    a2f0:	103ff426 	beq	r2,zero,a2c4 <_gp+0xffff6674>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
    a2f4:	d940000f 	ldh	r5,0(sp)
    a2f8:	000d883a 	mov	r6,zero
    a2fc:	8009883a 	mov	r4,r16
    a300:	0009cf00 	call	9cf0 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
    a304:	103fef26 	beq	r2,zero,a2c4 <_gp+0xffff6674>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
    a308:	d9000017 	ldw	r4,0(sp)
    a30c:	000d883a 	mov	r6,zero
    a310:	017fffc4 	movi	r5,-1
    a314:	0009cf00 	call	9cf0 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
    a318:	103fea26 	beq	r2,zero,a2c4 <_gp+0xffff6674>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
    a31c:	0009bb40 	call	9bb4 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
    a320:	d8800017 	ldw	r2,0(sp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
    a324:	dc00010b 	ldhu	r16,4(sp)
    a328:	843ffe0c 	andi	r16,r16,65528
    a32c:	00000106 	br	a334 <find_first_empty_record_in_a_subdirectory+0x160>
    a330:	00bfffc4 	movi	r2,-1
			{
				// Error encountered.                 
				result = -1;
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
    a334:	00fffdd4 	movui	r3,65527
    a338:	1c000216 	blt	r3,r16,a344 <find_first_empty_record_in_a_subdirectory+0x170>
    a33c:	00ffffc4 	movi	r3,-1
    a340:	10ffb326 	beq	r2,r3,a210 <_gp+0xffff65c0>
    return result; 
}
    a344:	dfc00a17 	ldw	ra,40(sp)
    a348:	ddc00917 	ldw	r23,36(sp)
    a34c:	dd800817 	ldw	r22,32(sp)
    a350:	dd400717 	ldw	r21,28(sp)
    a354:	dd000617 	ldw	r20,24(sp)
    a358:	dcc00517 	ldw	r19,20(sp)
    a35c:	dc800417 	ldw	r18,16(sp)
    a360:	dc400317 	ldw	r17,12(sp)
    a364:	dc000217 	ldw	r16,8(sp)
    a368:	dec00b04 	addi	sp,sp,44
    a36c:	f800283a 	ret

0000a370 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
    a370:	defffa04 	addi	sp,sp,-24
    a374:	dc400115 	stw	r17,4(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a378:	04400074 	movhi	r17,1
    a37c:	8c703504 	addi	r17,r17,-16172
    a380:	8900050b 	ldhu	r4,20(r17)
    a384:	8940030b 	ldhu	r5,12(r17)
}


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
    a388:	dd000415 	stw	r20,16(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a38c:	2008917a 	slli	r4,r4,5
}


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
    a390:	dcc00315 	stw	r19,12(sp)
    a394:	dc800215 	stw	r18,8(sp)
    a398:	dc000015 	stw	r16,0(sp)
    a39c:	dfc00515 	stw	ra,20(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a3a0:	00083040 	call	8304 <__divsi3>
    a3a4:	1025883a 	mov	r18,r2
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a3a8:	0021883a 	mov	r16,zero
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                if ((leading_char == 0x00e5) || (leading_char == 0))
    a3ac:	04c03944 	movi	r19,229
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
    a3b0:	05000404 	movi	r20,16
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a3b4:	84800526 	beq	r16,r18,a3cc <find_first_empty_record_in_root_directory+0x5c>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
    a3b8:	89001317 	ldw	r4,76(r17)
    a3bc:	d1608b17 	ldw	r5,-32212(gp)
    a3c0:	8109883a 	add	r4,r16,r4
    a3c4:	0009bd00 	call	9bd0 <Read_Sector_Data>
    a3c8:	1000021e 	bne	r2,zero,a3d4 <find_first_empty_record_in_root_directory+0x64>
        else
        {
            break;
        }
    }
    return result;
    a3cc:	00bfffc4 	movi	r2,-1
    a3d0:	00001106 	br	a418 <find_first_empty_record_in_root_directory+0xa8>
    a3d4:	0005883a 	mov	r2,zero
            for (file_counter = 0; file_counter < 16; file_counter++)
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
    a3d8:	d1208917 	ldw	r4,-32220(gp)
    a3dc:	1006917a 	slli	r3,r2,5
    a3e0:	21000a17 	ldw	r4,40(r4)
    a3e4:	1907883a 	add	r3,r3,r4
    a3e8:	18c00023 	ldbuio	r3,0(r3)
                if ((leading_char == 0x00e5) || (leading_char == 0))
    a3ec:	18c03fcc 	andi	r3,r3,255
    a3f0:	1cc0041e 	bne	r3,r19,a404 <find_first_empty_record_in_root_directory+0x94>
                {
                    result = (sector_index*16 + file_counter) << 16;
    a3f4:	8020913a 	slli	r16,r16,4
    a3f8:	8085883a 	add	r2,r16,r2
    a3fc:	1004943a 	slli	r2,r2,16
                    return result;
    a400:	00000506 	br	a418 <find_first_empty_record_in_root_directory+0xa8>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                if ((leading_char == 0x00e5) || (leading_char == 0))
    a404:	183ffb26 	beq	r3,zero,a3f4 <_gp+0xffff67a4>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
    a408:	10800044 	addi	r2,r2,1
    a40c:	153ff21e 	bne	r2,r20,a3d8 <_gp+0xffff6788>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a410:	84000044 	addi	r16,r16,1
    a414:	003fe706 	br	a3b4 <_gp+0xffff6764>
        {
            break;
        }
    }
    return result;
}
    a418:	dfc00517 	ldw	ra,20(sp)
    a41c:	dd000417 	ldw	r20,16(sp)
    a420:	dcc00317 	ldw	r19,12(sp)
    a424:	dc800217 	ldw	r18,8(sp)
    a428:	dc400117 	ldw	r17,4(sp)
    a42c:	dc000017 	ldw	r16,0(sp)
    a430:	dec00604 	addi	sp,sp,24
    a434:	f800283a 	ret

0000a438 <Read_File_Record_At_Offset>:

bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a438:	208007cc 	andi	r2,r4,31
    a43c:	10005a1e 	bne	r2,zero,a5a8 <Read_File_Record_At_Offset+0x170>
}


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
    a440:	defffb04 	addi	sp,sp,-20
    a444:	dcc00315 	stw	r19,12(sp)
    a448:	dc800215 	stw	r18,8(sp)
    a44c:	dc400115 	stw	r17,4(sp)
    a450:	dc000015 	stw	r16,0(sp)
    a454:	dfc00415 	stw	ra,16(sp)
    a458:	3825883a 	mov	r18,r7
    a45c:	3027883a 	mov	r19,r6
    a460:	2821883a 	mov	r16,r5
    a464:	2023883a 	mov	r17,r4
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a468:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    a46c:	1000021e 	bne	r2,zero,a478 <Read_File_Record_At_Offset+0x40>


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
    a470:	0005883a 	mov	r2,zero
    a474:	00004506 	br	a58c <Read_File_Record_At_Offset+0x154>
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a478:	d0a09217 	ldw	r2,-32184(gp)
    a47c:	103ffc26 	beq	r2,zero,a470 <_gp+0xffff6820>
    a480:	80800204 	addi	r2,r16,8
    a484:	8007883a 	mov	r3,r16
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
    a488:	8c0dc83a 	sub	r6,r17,r16
    a48c:	d1208917 	ldw	r4,-32220(gp)
    a490:	30cb883a 	add	r5,r6,r3
    a494:	21000a17 	ldw	r4,40(r4)
    a498:	2909883a 	add	r4,r5,r4
    a49c:	21000023 	ldbuio	r4,0(r4)
    a4a0:	19000005 	stb	r4,0(r3)
    a4a4:	18c00044 	addi	r3,r3,1
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
    a4a8:	18bff81e 	bne	r3,r2,a48c <_gp+0xffff683c>
    a4ac:	814002c4 	addi	r5,r16,11
    a4b0:	8809883a 	mov	r4,r17
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
    a4b4:	d0e08917 	ldw	r3,-32220(gp)
    a4b8:	18c00a17 	ldw	r3,40(r3)
    a4bc:	18c00204 	addi	r3,r3,8
    a4c0:	1907883a 	add	r3,r3,r4
    a4c4:	18c00023 	ldbuio	r3,0(r3)
    a4c8:	10c00005 	stb	r3,0(r2)
    a4cc:	10800044 	addi	r2,r2,1
    a4d0:	21000044 	addi	r4,r4,1

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
    a4d4:	28bff71e 	bne	r5,r2,a4b4 <_gp+0xffff6864>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
    a4d8:	d0a08917 	ldw	r2,-32220(gp)
    a4dc:	10c00a17 	ldw	r3,40(r2)
    a4e0:	18c002c4 	addi	r3,r3,11
    a4e4:	1c47883a 	add	r3,r3,r17
    a4e8:	18c00023 	ldbuio	r3,0(r3)
    a4ec:	80c002c5 	stb	r3,11(r16)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
    a4f0:	10c00a17 	ldw	r3,40(r2)
    a4f4:	18c00384 	addi	r3,r3,14
    a4f8:	1c47883a 	add	r3,r3,r17
    a4fc:	18c0002b 	ldhuio	r3,0(r3)
    a500:	80c0030d 	sth	r3,12(r16)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
    a504:	10c00a17 	ldw	r3,40(r2)
    a508:	18c00404 	addi	r3,r3,16
    a50c:	1c47883a 	add	r3,r3,r17
    a510:	18c0002b 	ldhuio	r3,0(r3)
    a514:	80c0038d 	sth	r3,14(r16)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
    a518:	10c00a17 	ldw	r3,40(r2)
    a51c:	18c00484 	addi	r3,r3,18
    a520:	1c47883a 	add	r3,r3,r17
    a524:	18c0002b 	ldhuio	r3,0(r3)
    a528:	80c0040d 	sth	r3,16(r16)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
    a52c:	10c00a17 	ldw	r3,40(r2)
    a530:	18c00584 	addi	r3,r3,22
    a534:	1c47883a 	add	r3,r3,r17
    a538:	18c0002b 	ldhuio	r3,0(r3)
    a53c:	80c0048d 	sth	r3,18(r16)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
    a540:	10c00a17 	ldw	r3,40(r2)
    a544:	18c00604 	addi	r3,r3,24
    a548:	1c47883a 	add	r3,r3,r17
    a54c:	18c0002b 	ldhuio	r3,0(r3)
    a550:	80c0050d 	sth	r3,20(r16)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
    a554:	10c00a17 	ldw	r3,40(r2)
    a558:	18c00684 	addi	r3,r3,26
    a55c:	1c47883a 	add	r3,r3,r17
    a560:	18c0002b 	ldhuio	r3,0(r3)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
    a564:	10800a17 	ldw	r2,40(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
    a568:	80c0058d 	sth	r3,22(r16)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
    a56c:	10800704 	addi	r2,r2,28
    a570:	1445883a 	add	r2,r2,r17
    a574:	10800037 	ldwio	r2,0(r2)
    a578:	80800615 	stw	r2,24(r16)
		record->file_record_cluster = cluster_index;
    a57c:	84c00a15 	stw	r19,40(r16)
		record->file_record_sector_in_cluster = sector_in_cluster;
    a580:	84800b15 	stw	r18,44(r16)
		record->file_record_offset = offset;
    a584:	84400c0d 	sth	r17,48(r16)
    a588:	00800044 	movi	r2,1
		result = true;
	}
	return result;
}
    a58c:	dfc00417 	ldw	ra,16(sp)
    a590:	dcc00317 	ldw	r19,12(sp)
    a594:	dc800217 	ldw	r18,8(sp)
    a598:	dc400117 	ldw	r17,4(sp)
    a59c:	dc000017 	ldw	r16,0(sp)
    a5a0:	dec00504 	addi	sp,sp,20
    a5a4:	f800283a 	ret


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
    a5a8:	0005883a 	mov	r2,zero
		record->file_record_sector_in_cluster = sector_in_cluster;
		record->file_record_offset = offset;
		result = true;
	}
	return result;
}
    a5ac:	f800283a 	ret

0000a5b0 <get_home_directory_cluster_for_file>:
}


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    a5b0:	deffef04 	addi	sp,sp,-68
    a5b4:	dd800d15 	stw	r22,52(sp)
    a5b8:	dd400c15 	stw	r21,48(sp)
    a5bc:	dd000b15 	stw	r20,44(sp)
    a5c0:	dcc00a15 	stw	r19,40(sp)
    a5c4:	dc800915 	stw	r18,36(sp)
    a5c8:	dc400815 	stw	r17,32(sp)
    a5cc:	dc000715 	stw	r16,28(sp)
    a5d0:	dfc01015 	stw	ra,64(sp)
    a5d4:	df000f15 	stw	fp,60(sp)
    a5d8:	ddc00e15 	stw	r23,56(sp)
    a5dc:	202b883a 	mov	r21,r4
    a5e0:	d9400515 	stw	r5,20(sp)
    a5e4:	3023883a 	mov	r17,r6
    a5e8:	05000074 	movhi	r20,1
    int home_dir_cluster = 0;
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    a5ec:	00098080 	call	9808 <get_dir_divider_location>
    a5f0:	1021883a 	mov	r16,r2
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    int home_dir_cluster = 0;
    int location, index;
    int start_location = 0;
    a5f4:	0027883a 	mov	r19,zero

bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    int home_dir_cluster = 0;
    a5f8:	002d883a 	mov	r22,zero


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    a5fc:	0025883a 	mov	r18,zero
    a600:	a5303504 	addi	r20,r20,-16172
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
    a604:	0400850e 	bge	zero,r16,a81c <get_home_directory_cluster_for_file+0x26c>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
    a608:	01400074 	movhi	r5,1
    a60c:	01800204 	movi	r6,8
    a610:	296ea284 	addi	r5,r5,-17782
    a614:	d809883a 	mov	r4,sp
    a618:	000b9bc0 	call	b9bc <memcpy>
        char extension[3] = { ' ', ' ', ' ' };
    a61c:	01400074 	movhi	r5,1
    a620:	d9000204 	addi	r4,sp,8
    a624:	018000c4 	movi	r6,3
    a628:	296ea484 	addi	r5,r5,-17774
    a62c:	000b9bc0 	call	b9bc <memcpy>
        int ext_index = -1;
    a630:	013fffc4 	movi	r4,-1
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
    a634:	0005883a 	mov	r2,zero
        {
            if (file_name[index+start_location] == '.')
    a638:	01c00b84 	movi	r7,46
            {
                ext_index = index;
            }
            else if (ext_index < 0)
    a63c:	2011883a 	mov	r8,r4
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
        {
            if (file_name[index+start_location] == '.')
    a640:	988b883a 	add	r5,r19,r2
    a644:	a94b883a 	add	r5,r21,r5
    a648:	29800003 	ldbu	r6,0(r5)
    a64c:	31403fcc 	andi	r5,r6,255
    a650:	2940201c 	xori	r5,r5,128
    a654:	297fe004 	addi	r5,r5,-128
    a658:	29c00826 	beq	r5,r7,a67c <get_home_directory_cluster_for_file+0xcc>
            {
                ext_index = index;
            }
            else if (ext_index < 0)
    a65c:	2200021e 	bne	r4,r8,a668 <get_home_directory_cluster_for_file+0xb8>
            {
                name[index] = file_name[index+start_location];
    a660:	d88b883a 	add	r5,sp,r2
    a664:	00000306 	br	a674 <get_home_directory_cluster_for_file+0xc4>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
    a668:	110bc83a 	sub	r5,r2,r4
    a66c:	d8c00204 	addi	r3,sp,8
    a670:	194b883a 	add	r5,r3,r5
    a674:	29800005 	stb	r6,0(r5)
    a678:	00000106 	br	a680 <get_home_directory_cluster_for_file+0xd0>
    a67c:	1009883a 	mov	r4,r2
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
    a680:	10800044 	addi	r2,r2,1
    a684:	80bfee1e 	bne	r16,r2,a640 <_gp+0xffff69f0>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
    a688:	b000261e 	bne	r22,zero,a724 <get_home_directory_cluster_for_file+0x174>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a68c:	a100050b 	ldhu	r4,20(r20)
    a690:	a140030b 	ldhu	r5,12(r20)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a694:	002f883a 	mov	r23,zero
        }
        
        if (home_dir_cluster == 0)
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a698:	2008917a 	slli	r4,r4,5
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
                            if (match)
                            {
                                new_cluster = file_record->start_cluster_index;
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
    a69c:	07000044 	movi	fp,1
        }
        
        if (home_dir_cluster == 0)
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a6a0:	00083040 	call	8304 <__divsi3>
    a6a4:	d8800415 	stw	r2,16(sp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a6a8:	d8c00417 	ldw	r3,16(sp)
    a6ac:	b8c05926 	beq	r23,r3,a814 <get_home_directory_cluster_for_file+0x264>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
    a6b0:	a1001317 	ldw	r4,76(r20)
    a6b4:	d1608b17 	ldw	r5,-32212(gp)
    a6b8:	b909883a 	add	r4,r23,r4
    a6bc:	0009bd00 	call	9bd0 <Read_Sector_Data>
    a6c0:	10005426 	beq	r2,zero,a814 <get_home_directory_cluster_for_file+0x264>
    a6c4:	002d883a 	mov	r22,zero
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
    a6c8:	b80f883a 	mov	r7,r23
    a6cc:	000d883a 	mov	r6,zero
    a6d0:	880b883a 	mov	r5,r17
    a6d4:	b009883a 	mov	r4,r22
    a6d8:	000a4380 	call	a438 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a6dc:	88800003 	ldbu	r2,0(r17)
    a6e0:	00c03944 	movi	r3,229
    a6e4:	10c00b26 	beq	r2,r3,a714 <get_home_directory_cluster_for_file+0x164>
    a6e8:	10000a26 	beq	r2,zero,a714 <get_home_directory_cluster_for_file+0x164>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
    a6ec:	d9800204 	addi	r6,sp,8
    a6f0:	d80b883a 	mov	r5,sp
    a6f4:	8809883a 	mov	r4,r17
    a6f8:	00098600 	call	9860 <match_file_record_to_name_ext>
                            if (match)
    a6fc:	10000526 	beq	r2,zero,a714 <get_home_directory_cluster_for_file+0x164>
                            {
                                new_cluster = file_record->start_cluster_index;
    a700:	8d80058b 	ldhu	r22,22(r17)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
    a704:	8f000a15 	stw	fp,40(r17)
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
    a708:	b0003a1e 	bne	r22,zero,a7f4 <get_home_directory_cluster_for_file+0x244>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a70c:	bdc00044 	addi	r23,r23,1
    a710:	003fe506 	br	a6a8 <_gp+0xffff6a58>
    a714:	b5800804 	addi	r22,r22,32
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
    a718:	00808004 	movi	r2,512
    a71c:	b0bfea1e 	bne	r22,r2,a6c8 <_gp+0xffff6a78>
    a720:	003ffa06 	br	a70c <_gp+0xffff6abc>
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a724:	b0ffff84 	addi	r3,r22,-2
    a728:	d8c00615 	stw	r3,24(sp)
    a72c:	a1400383 	ldbu	r5,14(r20)
    a730:	d9000617 	ldw	r4,24(sp)
    a734:	00095140 	call	9514 <__mulsi3>
    a738:	a5c01417 	ldw	r23,80(r20)
    a73c:	15ef883a 	add	r23,r2,r23
    a740:	ddc00415 	stw	r23,16(sp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a744:	002f883a 	mov	r23,zero
    a748:	a0800383 	ldbu	r2,14(r20)
    a74c:	b880050e 	bge	r23,r2,a764 <get_home_directory_cluster_for_file+0x1b4>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    a750:	d8c00417 	ldw	r3,16(sp)
    a754:	d1608b17 	ldw	r5,-32212(gp)
    a758:	1dc9883a 	add	r4,r3,r23
    a75c:	0009bd00 	call	9bd0 <Read_Sector_Data>
    a760:	1000051e 	bne	r2,zero,a778 <get_home_directory_cluster_for_file+0x1c8>
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
    a764:	d9400304 	addi	r5,sp,12
    a768:	b009883a 	mov	r4,r22
    a76c:	0009c700 	call	9c70 <get_cluster_flag>
    a770:	1000181e 	bne	r2,zero,a7d4 <get_home_directory_cluster_for_file+0x224>
    a774:	00002706 	br	a814 <get_home_directory_cluster_for_file+0x264>
    a778:	0039883a 	mov	fp,zero
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
    a77c:	b80f883a 	mov	r7,r23
    a780:	b00d883a 	mov	r6,r22
    a784:	880b883a 	mov	r5,r17
    a788:	e009883a 	mov	r4,fp
    a78c:	000a4380 	call	a438 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a790:	88800003 	ldbu	r2,0(r17)
    a794:	00c03944 	movi	r3,229
    a798:	10c00926 	beq	r2,r3,a7c0 <get_home_directory_cluster_for_file+0x210>
    a79c:	10000826 	beq	r2,zero,a7c0 <get_home_directory_cluster_for_file+0x210>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
    a7a0:	d9800204 	addi	r6,sp,8
    a7a4:	d80b883a 	mov	r5,sp
    a7a8:	8809883a 	mov	r4,r17
    a7ac:	00098600 	call	9860 <match_file_record_to_name_ext>
                                if (match)
    a7b0:	10000326 	beq	r2,zero,a7c0 <get_home_directory_cluster_for_file+0x210>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
    a7b4:	8880058b 	ldhu	r2,22(r17)
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
    a7b8:	b0800426 	beq	r22,r2,a7cc <get_home_directory_cluster_for_file+0x21c>
    a7bc:	00000c06 	br	a7f0 <get_home_directory_cluster_for_file+0x240>
    a7c0:	e7000804 	addi	fp,fp,32
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
    a7c4:	00808004 	movi	r2,512
    a7c8:	e0bfec1e 	bne	fp,r2,a77c <_gp+0xffff6b2c>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a7cc:	bdc00044 	addi	r23,r23,1
    a7d0:	003fdd06 	br	a748 <_gp+0xffff6af8>
    a7d4:	d880030b 	ldhu	r2,12(sp)
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
    a7d8:	013ffe14 	movui	r4,65528
    a7dc:	10bffe0c 	andi	r2,r2,65528
    a7e0:	11000c26 	beq	r2,r4,a814 <get_home_directory_cluster_for_file+0x264>
					{
						// Directory path is invalid.                 
						return false;
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
    a7e4:	013ffdd4 	movui	r4,65527
    a7e8:	25800116 	blt	r4,r22,a7f0 <get_home_directory_cluster_for_file+0x240>
    a7ec:	b0bfcf26 	beq	r22,r2,a72c <_gp+0xffff6adc>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a7f0:	102d883a 	mov	r22,r2
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
            if (new_cluster != home_dir_cluster)
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
                start_location = start_location+location+1;
    a7f4:	84e1883a 	add	r16,r16,r19
    a7f8:	84c00044 	addi	r19,r16,1
            {
                // Directory path is invalid. 
                return false;
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
    a7fc:	acc9883a 	add	r4,r21,r19
    a800:	00098080 	call	9808 <get_dir_divider_location>
    a804:	1021883a 	mov	r16,r2
        if (location < 0)
    a808:	103f7e0e 	bge	r2,zero,a604 <_gp+0xffff69b4>
        {
            // Directory has been located.
            result = true;
    a80c:	04800044 	movi	r18,1
    a810:	003f7c06 	br	a604 <_gp+0xffff69b4>
                start_location = start_location+location+1;
            }
            else
            {
                // Directory path is invalid. 
                return false;
    a814:	0005883a 	mov	r2,zero
    a818:	00000706 	br	a838 <get_home_directory_cluster_for_file+0x288>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
    a81c:	d8c00517 	ldw	r3,20(sp)
    a820:	1d800015 	stw	r22,0(r3)
    if (home_dir_cluster == 0)
    a824:	b000031e 	bne	r22,zero,a834 <get_home_directory_cluster_for_file+0x284>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
    a828:	88000a15 	stw	zero,40(r17)
		result = true;
    a82c:	00800044 	movi	r2,1
    a830:	00000106 	br	a838 <get_home_directory_cluster_for_file+0x288>
    a834:	9005883a 	mov	r2,r18
    }
    return result;
}
    a838:	dfc01017 	ldw	ra,64(sp)
    a83c:	df000f17 	ldw	fp,60(sp)
    a840:	ddc00e17 	ldw	r23,56(sp)
    a844:	dd800d17 	ldw	r22,52(sp)
    a848:	dd400c17 	ldw	r21,48(sp)
    a84c:	dd000b17 	ldw	r20,44(sp)
    a850:	dcc00a17 	ldw	r19,40(sp)
    a854:	dc800917 	ldw	r18,36(sp)
    a858:	dc400817 	ldw	r17,32(sp)
    a85c:	dc000717 	ldw	r16,28(sp)
    a860:	dec01104 	addi	sp,sp,68
    a864:	f800283a 	ret

0000a868 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    a868:	defff204 	addi	sp,sp,-56
    a86c:	dc000415 	stw	r16,16(sp)
    a870:	2021883a 	mov	r16,r4
    int location = get_dir_divider_location( file_name );
    a874:	2809883a 	mov	r4,r5
}


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    a878:	dfc00d15 	stw	ra,52(sp)
    a87c:	dd400915 	stw	r21,36(sp)
    a880:	dd000815 	stw	r20,32(sp)
    a884:	dcc00715 	stw	r19,28(sp)
    a888:	dc800615 	stw	r18,24(sp)
    a88c:	dc400515 	stw	r17,20(sp)
    a890:	2825883a 	mov	r18,r5
    a894:	3027883a 	mov	r19,r6
    a898:	df000c15 	stw	fp,48(sp)
    a89c:	ddc00b15 	stw	r23,44(sp)
    a8a0:	dd800a15 	stw	r22,40(sp)
    int location = get_dir_divider_location( file_name );
    a8a4:	00098080 	call	9808 <get_dir_divider_location>
    int last_dir_separator = 0;
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
    a8a8:	01400074 	movhi	r5,1
    a8ac:	01800204 	movi	r6,8
    a8b0:	296ea284 	addi	r5,r5,-17782
    a8b4:	d809883a 	mov	r4,sp


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    int location = get_dir_divider_location( file_name );
    a8b8:	1029883a 	mov	r20,r2
    int last_dir_separator = 0;
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
    a8bc:	000b9bc0 	call	b9bc <memcpy>
    char extension[3] = { ' ', ' ', ' ' };
    a8c0:	01400074 	movhi	r5,1
    a8c4:	018000c4 	movi	r6,3
    a8c8:	296ea484 	addi	r5,r5,-17774
    a8cc:	d9000204 	addi	r4,sp,8
    a8d0:	000b9bc0 	call	b9bc <memcpy>
    int ext_index = -1;
    int cluster = directory_start_cluster;
    int index;
	int length = strlen(file_name);
    a8d4:	9009883a 	mov	r4,r18
    a8d8:	00087780 	call	8778 <strlen>
    a8dc:	102b883a 	mov	r21,r2

bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    int location = get_dir_divider_location( file_name );
    int last_dir_separator = 0;
    a8e0:	0023883a 	mov	r17,zero
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
    a8e4:	0500060e 	bge	zero,r20,a900 <find_file_in_directory+0x98>
    {
        last_dir_separator = last_dir_separator+location+1;
    a8e8:	a463883a 	add	r17,r20,r17
    a8ec:	8c400044 	addi	r17,r17,1
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    a8f0:	9449883a 	add	r4,r18,r17
    a8f4:	00098080 	call	9808 <get_dir_divider_location>
    a8f8:	1029883a 	mov	r20,r2
    a8fc:	003ff906 	br	a8e4 <_gp+0xffff6c94>
    a900:	8807883a 	mov	r3,r17
    a904:	00bfffc4 	movi	r2,-1
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    {
        if (file_name[index] == '.')
    a908:	01800b84 	movi	r6,46
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    a90c:	1d40120e 	bge	r3,r21,a958 <find_file_in_directory+0xf0>
    {
        if (file_name[index] == '.')
    a910:	90c9883a 	add	r4,r18,r3
    a914:	21400003 	ldbu	r5,0(r4)
    a918:	29003fcc 	andi	r4,r5,255
    a91c:	2100201c 	xori	r4,r4,128
    a920:	213fe004 	addi	r4,r4,-128
    a924:	21800926 	beq	r4,r6,a94c <find_file_in_directory+0xe4>
        {
            ext_index = index;
        }
        else if (ext_index < 0)
    a928:	1000030e 	bge	r2,zero,a938 <find_file_in_directory+0xd0>
        {
            name[index-last_dir_separator] = file_name[index];
    a92c:	1c49c83a 	sub	r4,r3,r17
    a930:	d909883a 	add	r4,sp,r4
    a934:	00000306 	br	a944 <find_file_in_directory+0xdc>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
    a938:	1889c83a 	sub	r4,r3,r2
    a93c:	d9c001c4 	addi	r7,sp,7
    a940:	3909883a 	add	r4,r7,r4
    a944:	21400005 	stb	r5,0(r4)
    a948:	00000106 	br	a950 <find_file_in_directory+0xe8>
    a94c:	1805883a 	mov	r2,r3
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    a950:	18c00044 	addi	r3,r3,1
    a954:	003fed06 	br	a90c <_gp+0xffff6cbc>
    a958:	04400074 	movhi	r17,1
    a95c:	8c703504 	addi	r17,r17,-16172
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
    a960:	80000426 	beq	r16,zero,a974 <find_file_in_directory+0x10c>
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a964:	05003944 	movi	r20,229
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
    a968:	05408004 	movi	r21,512
    a96c:	05bffe04 	movi	r22,-8
    a970:	00003b06 	br	aa60 <find_file_in_directory+0x1f8>

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a974:	8900050b 	ldhu	r4,20(r17)
    a978:	8940030b 	ldhu	r5,12(r17)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a97c:	0021883a 	mov	r16,zero

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a980:	2008917a 	slli	r4,r4,5
                
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a984:	05403944 	movi	r21,229
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    a988:	05808004 	movi	r22,512

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a98c:	00083040 	call	8304 <__divsi3>
    a990:	1029883a 	mov	r20,r2
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a994:	85004026 	beq	r16,r20,aa98 <find_file_in_directory+0x230>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
    a998:	89001317 	ldw	r4,76(r17)
    a99c:	d1608b17 	ldw	r5,-32212(gp)
    a9a0:	8109883a 	add	r4,r16,r4
    a9a4:	0009bd00 	call	9bd0 <Read_Sector_Data>
    a9a8:	10003b26 	beq	r2,zero,aa98 <find_file_in_directory+0x230>
    a9ac:	0025883a 	mov	r18,zero
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
    a9b0:	800f883a 	mov	r7,r16
    a9b4:	000d883a 	mov	r6,zero
    a9b8:	980b883a 	mov	r5,r19
    a9bc:	9009883a 	mov	r4,r18
    a9c0:	000a4380 	call	a438 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a9c4:	98800003 	ldbu	r2,0(r19)
    a9c8:	15400826 	beq	r2,r21,a9ec <find_file_in_directory+0x184>
    a9cc:	10000726 	beq	r2,zero,a9ec <find_file_in_directory+0x184>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
    a9d0:	d9800204 	addi	r6,sp,8
    a9d4:	d80b883a 	mov	r5,sp
    a9d8:	9809883a 	mov	r4,r19
    a9dc:	00098600 	call	9860 <match_file_record_to_name_ext>

                        if (match)
    a9e0:	10000226 	beq	r2,zero,a9ec <find_file_in_directory+0x184>
				if (get_cluster_flag(cluster, &new_cluster))
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
					{
						return false;
    a9e4:	00800044 	movi	r2,1
    a9e8:	00002c06 	br	aa9c <find_file_in_directory+0x234>
    a9ec:	94800804 	addi	r18,r18,32
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    a9f0:	95bfef1e 	bne	r18,r22,a9b0 <_gp+0xffff6d60>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a9f4:	84000044 	addi	r16,r16,1
    a9f8:	003fe606 	br	a994 <_gp+0xffff6d44>
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    a9fc:	d1608b17 	ldw	r5,-32212(gp)
    aa00:	e489883a 	add	r4,fp,r18
    aa04:	0009bd00 	call	9bd0 <Read_Sector_Data>
    aa08:	10000d26 	beq	r2,zero,aa40 <find_file_in_directory+0x1d8>
    aa0c:	002f883a 	mov	r23,zero
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
    aa10:	900f883a 	mov	r7,r18
    aa14:	800d883a 	mov	r6,r16
    aa18:	980b883a 	mov	r5,r19
    aa1c:	b809883a 	mov	r4,r23
    aa20:	000a4380 	call	a438 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    aa24:	98800003 	ldbu	r2,0(r19)
    aa28:	1500141e 	bne	r2,r20,aa7c <find_file_in_directory+0x214>
    aa2c:	bdc00804 	addi	r23,r23,32
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
    aa30:	bd7ff71e 	bne	r23,r21,aa10 <_gp+0xffff6dc0>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    aa34:	94800044 	addi	r18,r18,1
    aa38:	88800383 	ldbu	r2,14(r17)
    aa3c:	90bfef16 	blt	r18,r2,a9fc <_gp+0xffff6dac>
            // that holds data for the current directory.
            if (result == false)
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
    aa40:	d9400304 	addi	r5,sp,12
    aa44:	8009883a 	mov	r4,r16
    aa48:	0009c700 	call	9c70 <get_cluster_flag>
    aa4c:	10001226 	beq	r2,zero,aa98 <find_file_in_directory+0x230>
    aa50:	dc00030b 	ldhu	r16,12(sp)
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
    aa54:	00bffe14 	movui	r2,65528
    aa58:	b420703a 	and	r16,r22,r16
    aa5c:	80800e26 	beq	r16,r2,aa98 <find_file_in_directory+0x230>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    aa60:	89400383 	ldbu	r5,14(r17)
    aa64:	813fff84 	addi	r4,r16,-2
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    aa68:	0025883a 	mov	r18,zero
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    aa6c:	00095140 	call	9514 <__mulsi3>
    aa70:	8f001417 	ldw	fp,80(r17)
    aa74:	1739883a 	add	fp,r2,fp
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    aa78:	003fef06 	br	aa38 <_gp+0xffff6de8>
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    aa7c:	103feb26 	beq	r2,zero,aa2c <_gp+0xffff6ddc>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
    aa80:	d9800204 	addi	r6,sp,8
    aa84:	d80b883a 	mov	r5,sp
    aa88:	9809883a 	mov	r4,r19
    aa8c:	00098600 	call	9860 <match_file_record_to_name_ext>

                            if (match)
    aa90:	103fe626 	beq	r2,zero,aa2c <_gp+0xffff6ddc>
    aa94:	003fd306 	br	a9e4 <_gp+0xffff6d94>
				if (get_cluster_flag(cluster, &new_cluster))
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
					{
						return false;
    aa98:	0005883a 	mov	r2,zero
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
}
    aa9c:	dfc00d17 	ldw	ra,52(sp)
    aaa0:	df000c17 	ldw	fp,48(sp)
    aaa4:	ddc00b17 	ldw	r23,44(sp)
    aaa8:	dd800a17 	ldw	r22,40(sp)
    aaac:	dd400917 	ldw	r21,36(sp)
    aab0:	dd000817 	ldw	r20,32(sp)
    aab4:	dcc00717 	ldw	r19,28(sp)
    aab8:	dc800617 	ldw	r18,24(sp)
    aabc:	dc400517 	ldw	r17,20(sp)
    aac0:	dc000417 	ldw	r16,16(sp)
    aac4:	dec00e04 	addi	sp,sp,56
    aac8:	f800283a 	ret

0000aacc <Write_File_Record_At_Offset>:

bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    aacc:	208007cc 	andi	r2,r4,31
    aad0:	1000551e 	bne	r2,zero,ac28 <Write_File_Record_At_Offset+0x15c>
}


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    aad4:	defffd04 	addi	sp,sp,-12
    aad8:	dc400115 	stw	r17,4(sp)
    aadc:	dc000015 	stw	r16,0(sp)
    aae0:	dfc00215 	stw	ra,8(sp)
    aae4:	2821883a 	mov	r16,r5
    aae8:	2023883a 	mov	r17,r4
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    aaec:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    aaf0:	1000021e 	bne	r2,zero,aafc <Write_File_Record_At_Offset+0x30>


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    aaf4:	0005883a 	mov	r2,zero
    aaf8:	00004606 	br	ac14 <Write_File_Record_At_Offset+0x148>
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    aafc:	d0a09217 	ldw	r2,-32184(gp)
    ab00:	103ffc26 	beq	r2,zero,aaf4 <_gp+0xffff6ea4>
    ab04:	81000044 	addi	r4,r16,1
    ab08:	80800204 	addi	r2,r16,8
    ab0c:	8007883a 	mov	r3,r16
        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
    ab10:	8c11c83a 	sub	r8,r17,r16
    ab14:	d1608917 	ldw	r5,-32220(gp)
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
    ab18:	21800003 	ldbu	r6,0(r4)
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
    ab1c:	29400a17 	ldw	r5,40(r5)
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
    ab20:	300e923a 	slli	r7,r6,8
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
    ab24:	40cd883a 	add	r6,r8,r3
    ab28:	314b883a 	add	r5,r6,r5
    ab2c:	19800003 	ldbu	r6,0(r3)
    ab30:	398cb03a 	or	r6,r7,r6
    ab34:	2980002d 	sthio	r6,0(r5)
    ab38:	18c00084 	addi	r3,r3,2
    ab3c:	21000084 	addi	r4,r4,2
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
    ab40:	10fff41e 	bne	r2,r3,ab14 <_gp+0xffff6ec4>
    ab44:	814002c4 	addi	r5,r16,11
    ab48:	8807883a 	mov	r3,r17
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
    ab4c:	d1208917 	ldw	r4,-32220(gp)
    ab50:	11800003 	ldbu	r6,0(r2)
    ab54:	21000a17 	ldw	r4,40(r4)
    ab58:	1909883a 	add	r4,r3,r4
    ab5c:	21800225 	stbio	r6,8(r4)
    ab60:	10800044 	addi	r2,r2,1
    ab64:	18c00044 	addi	r3,r3,1
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
    ab68:	28bff81e 	bne	r5,r2,ab4c <_gp+0xffff6efc>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
    ab6c:	d0a08917 	ldw	r2,-32220(gp)
    ab70:	80c002c3 	ldbu	r3,11(r16)
    ab74:	10800a17 	ldw	r2,40(r2)
    ab78:	8885883a 	add	r2,r17,r2
    ab7c:	10c002e5 	stbio	r3,11(r2)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
    ab80:	d0a08917 	ldw	r2,-32220(gp)
    ab84:	80c0030b 	ldhu	r3,12(r16)
    ab88:	10800a17 	ldw	r2,40(r2)
    ab8c:	8885883a 	add	r2,r17,r2
    ab90:	10c003ad 	sthio	r3,14(r2)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
    ab94:	d0a08917 	ldw	r2,-32220(gp)
    ab98:	80c0038b 	ldhu	r3,14(r16)
    ab9c:	10800a17 	ldw	r2,40(r2)
    aba0:	8885883a 	add	r2,r17,r2
    aba4:	10c0042d 	sthio	r3,16(r2)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
    aba8:	d0a08917 	ldw	r2,-32220(gp)
    abac:	80c0040b 	ldhu	r3,16(r16)
    abb0:	10800a17 	ldw	r2,40(r2)
    abb4:	8885883a 	add	r2,r17,r2
    abb8:	10c004ad 	sthio	r3,18(r2)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
    abbc:	d0a08917 	ldw	r2,-32220(gp)
    abc0:	80c0048b 	ldhu	r3,18(r16)
    abc4:	10800a17 	ldw	r2,40(r2)
    abc8:	8885883a 	add	r2,r17,r2
    abcc:	10c005ad 	sthio	r3,22(r2)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
    abd0:	d0a08917 	ldw	r2,-32220(gp)
    abd4:	80c0050b 	ldhu	r3,20(r16)
    abd8:	10800a17 	ldw	r2,40(r2)
    abdc:	8885883a 	add	r2,r17,r2
    abe0:	10c0062d 	sthio	r3,24(r2)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
    abe4:	d0a08917 	ldw	r2,-32220(gp)
    abe8:	80c0058b 	ldhu	r3,22(r16)
    abec:	10800a17 	ldw	r2,40(r2)
    abf0:	8885883a 	add	r2,r17,r2
    abf4:	10c006ad 	sthio	r3,26(r2)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
    abf8:	d0a08917 	ldw	r2,-32220(gp)
    abfc:	11000a17 	ldw	r4,40(r2)
    ac00:	80800617 	ldw	r2,24(r16)
    ac04:	8923883a 	add	r17,r17,r4
    ac08:	88800735 	stwio	r2,28(r17)
        current_sector_modified = true;                  
    ac0c:	00800044 	movi	r2,1
    ac10:	d0a08815 	stw	r2,-32224(gp)
        result = true;
    }
    return result;
}
    ac14:	dfc00217 	ldw	ra,8(sp)
    ac18:	dc400117 	ldw	r17,4(sp)
    ac1c:	dc000017 	ldw	r16,0(sp)
    ac20:	dec00304 	addi	sp,sp,12
    ac24:	f800283a 	ret


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    ac28:	0005883a 	mov	r2,zero
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
        current_sector_modified = true;                  
        result = true;
    }
    return result;
}
    ac2c:	f800283a 	ret

0000ac30 <create_file>:

}

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    ac30:	defff904 	addi	sp,sp,-28
    ac34:	dd000515 	stw	r20,20(sp)
    ac38:	2029883a 	mov	r20,r4
    unsigned int cluster_number;
    bool result = false;
    
    if (find_first_empty_cluster(&cluster_number))
    ac3c:	d809883a 	mov	r4,sp

}

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    ac40:	dcc00415 	stw	r19,16(sp)
    ac44:	dc000115 	stw	r16,4(sp)
    ac48:	dfc00615 	stw	ra,24(sp)
    ac4c:	dc800315 	stw	r18,12(sp)
    ac50:	dc400215 	stw	r17,8(sp)
    ac54:	2821883a 	mov	r16,r5
    ac58:	3027883a 	mov	r19,r6
    unsigned int cluster_number;
    bool result = false;
    
    if (find_first_empty_cluster(&cluster_number))
    ac5c:	000a1300 	call	a130 <find_first_empty_cluster>
    ac60:	1000021e 	bne	r2,zero,ac6c <create_file+0x3c>

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    unsigned int cluster_number;
    bool result = false;
    ac64:	0005883a 	mov	r2,zero
    ac68:	00004b06 	br	ad98 <create_file+0x168>
    
    if (find_first_empty_cluster(&cluster_number))
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
    ac6c:	98800a17 	ldw	r2,40(r19)
    ac70:	1000021e 	bne	r2,zero,ac7c <create_file+0x4c>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
    ac74:	000a3700 	call	a370 <find_first_empty_record_in_root_directory>
    ac78:	00000206 	br	ac84 <create_file+0x54>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
    ac7c:	9900058b 	ldhu	r4,22(r19)
    ac80:	000a1d40 	call	a1d4 <find_first_empty_record_in_a_subdirectory>
    ac84:	1023883a 	mov	r17,r2
        }
        if (record_index >= 0)
    ac88:	103ff616 	blt	r2,zero,ac64 <_gp+0xffff7014>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
    ac8c:	a009883a 	mov	r4,r20
    ac90:	00098080 	call	9808 <get_dir_divider_location>
            int last_dir_separator = 0;
    ac94:	0025883a 	mov	r18,zero

            // Skip through all directory separators.
            while (location > 0)
    ac98:	0080050e 	bge	zero,r2,acb0 <create_file+0x80>
            {
                last_dir_separator = last_dir_separator+location+1;
    ac9c:	14a5883a 	add	r18,r2,r18
    aca0:	94800044 	addi	r18,r18,1
                location = get_dir_divider_location( &(name[last_dir_separator]) );
    aca4:	a489883a 	add	r4,r20,r18
    aca8:	00098080 	call	9808 <get_dir_divider_location>
    acac:	003ffa06 	br	ac98 <_gp+0xffff7048>
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
    acb0:	a489883a 	add	r4,r20,r18
    acb4:	81800204 	addi	r6,r16,8
    acb8:	800b883a 	mov	r5,r16
    acbc:	000994c0 	call	994c <convert_filename_to_name_extension>
            file_record->create_time = 0;
            file_record->create_date = 0;
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
    acc0:	d8800017 	ldw	r2,0(sp)
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
    acc4:	893fffcc 	andi	r4,r17,65535
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
    acc8:	8822d43a 	srli	r17,r17,16
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
    accc:	800002c5 	stb	zero,11(r16)
            file_record->create_time = 0;
            file_record->create_date = 0;
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
    acd0:	8080058d 	sth	r2,22(r16)
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
    acd4:	8825d13a 	srai	r18,r17,4
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
    acd8:	80800715 	stw	r2,28(r16)
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
    acdc:	8c4003cc 	andi	r17,r17,15
            file_record->home_directory_cluster = home_dir->start_cluster_index;
    ace0:	9880058b 	ldhu	r2,22(r19)
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
    ace4:	8822917a 	slli	r17,r17,5
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
            file_record->create_time = 0;
    ace8:	8000030d 	sth	zero,12(r16)
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
    acec:	80800d15 	stw	r2,52(r16)
            file_record->in_use = true;
    acf0:	00800044 	movi	r2,1
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
    acf4:	84400c0d 	sth	r17,48(r16)
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
            file_record->create_time = 0;
            file_record->create_date = 0;
    acf8:	8000038d 	sth	zero,14(r16)
    acfc:	04400074 	movhi	r17,1
            file_record->last_access_date = 0;
    ad00:	8000040d 	sth	zero,16(r16)
            file_record->last_modified_time = 0;
    ad04:	8000048d 	sth	zero,18(r16)
            file_record->last_modified_date = 0;
    ad08:	8000050d 	sth	zero,20(r16)
            file_record->start_cluster_index = cluster_number;
            file_record->file_size_in_bytes = 0;
    ad0c:	80000615 	stw	zero,24(r16)
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
    ad10:	80000815 	stw	zero,32(r16)
            file_record->current_byte_position = 0;
    ad14:	80000915 	stw	zero,36(r16)
            file_record->file_record_cluster = record_index & 0x0000ffff;
    ad18:	81000a15 	stw	r4,40(r16)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
    ad1c:	84800b15 	stw	r18,44(r16)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
    ad20:	80800f15 	stw	r2,60(r16)
            file_record->modified = true;
    ad24:	80800e15 	stw	r2,56(r16)
    ad28:	8c703504 	addi	r17,r17,-16172
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
    ad2c:	2000031e 	bne	r4,zero,ad3c <create_file+0x10c>
    ad30:	89001317 	ldw	r4,76(r17)
    ad34:	9109883a 	add	r4,r18,r4
    ad38:	00000606 	br	ad54 <create_file+0x124>
    ad3c:	89400383 	ldbu	r5,14(r17)
    ad40:	213fff84 	addi	r4,r4,-2
    ad44:	00095140 	call	9514 <__mulsi3>
    ad48:	89001417 	ldw	r4,80(r17)
    ad4c:	1105883a 	add	r2,r2,r4
    ad50:	1489883a 	add	r4,r2,r18
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
    ad54:	d1608b17 	ldw	r5,-32212(gp)
    ad58:	0009bd00 	call	9bd0 <Read_Sector_Data>
    ad5c:	103fc126 	beq	r2,zero,ac64 <_gp+0xffff7014>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
    ad60:	81000c0f 	ldh	r4,48(r16)
    ad64:	800b883a 	mov	r5,r16
    ad68:	000aacc0 	call	aacc <Write_File_Record_At_Offset>
    ad6c:	103fbd26 	beq	r2,zero,ac64 <_gp+0xffff7014>
                {
                    Save_Modified_Sector();
    ad70:	0009bb40 	call	9bb4 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
    ad74:	d9000017 	ldw	r4,0(sp)
    ad78:	01800044 	movi	r6,1
    ad7c:	017fffc4 	movi	r5,-1
    ad80:	0009cf00 	call	9cf0 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
    ad84:	d9000017 	ldw	r4,0(sp)
    ad88:	000d883a 	mov	r6,zero
    ad8c:	017fffc4 	movi	r5,-1
    ad90:	0009cf00 	call	9cf0 <mark_cluster>

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    unsigned int cluster_number;
    bool result = false;
    ad94:	1004c03a 	cmpne	r2,r2,zero
            }
        }

    }
    return result;           
}
    ad98:	dfc00617 	ldw	ra,24(sp)
    ad9c:	dd000517 	ldw	r20,20(sp)
    ada0:	dcc00417 	ldw	r19,16(sp)
    ada4:	dc800317 	ldw	r18,12(sp)
    ada8:	dc400217 	ldw	r17,8(sp)
    adac:	dc000117 	ldw	r16,4(sp)
    adb0:	dec00704 	addi	sp,sp,28
    adb4:	f800283a 	ret

0000adb8 <Look_for_FAT16>:
}


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
    adb8:	deffff04 	addi	sp,sp,-4
    adbc:	dfc00015 	stw	ra,0(sp)
	bool result = false;

	if (alt_up_sd_card_is_Present())
    adc0:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    adc4:	1000021e 	bne	r2,zero,add0 <Look_for_FAT16+0x18>


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
	bool result = false;
    adc8:	0005883a 	mov	r2,zero
    adcc:	00001d06 	br	ae44 <Look_for_FAT16+0x8c>

	if (alt_up_sd_card_is_Present())
	{
		short int csd_file_format = *CSD_register_w0;
    add0:	d0a08f17 	ldw	r2,-32196(gp)
    add4:	1080000b 	ldhu	r2,0(r2)
        
		fat_partition_offset_in_512_byte_sectors = 0;
    add8:	d0208b15 	stw	zero,-32212(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
    addc:	d0208a15 	stw	zero,-32216(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
    ade0:	10ffffcc 	andi	r3,r2,65535
    ade4:	18e0001c 	xori	r3,r3,32768
    ade8:	18e00004 	addi	r3,r3,-32768
    adec:	183ff616 	blt	r3,zero,adc8 <_gp+0xffff7178>
    adf0:	1083000c 	andi	r2,r2,3072
    adf4:	00c30004 	movi	r3,3072
    adf8:	10fff326 	beq	r2,r3,adc8 <_gp+0xffff7178>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
    adfc:	00c10004 	movi	r3,1024
    ae00:	10c0021e 	bne	r2,r3,ae0c <Look_for_FAT16+0x54>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
    ae04:	0009883a 	mov	r4,zero
    ae08:	00000406 	br	ae1c <Look_for_FAT16+0x64>
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
    ae0c:	103fee1e 	bne	r2,zero,adc8 <_gp+0xffff7178>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
    ae10:	0009d7c0 	call	9d7c <Check_for_Master_Boot_Record>
    ae14:	103fec26 	beq	r2,zero,adc8 <_gp+0xffff7178>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
    ae18:	d1208b17 	ldw	r4,-32212(gp)
    ae1c:	0009e840 	call	9e84 <Check_for_DOS_FAT>
				}                        
			}
			if (result == true)
    ae20:	00c00044 	movi	r3,1
    ae24:	10c0071e 	bne	r2,r3,ae44 <Look_for_FAT16+0x8c>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
    ae28:	00c00074 	movhi	r3,1
    ae2c:	18f03504 	addi	r3,r3,-16172
    ae30:	19401083 	ldbu	r5,66(r3)
    ae34:	01000404 	movi	r4,16
    ae38:	293fe31e 	bne	r5,r4,adc8 <_gp+0xffff7178>
				{
					result = false;
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
    ae3c:	18c0058b 	ldhu	r3,22(r3)
    ae40:	d0e08a15 	stw	r3,-32216(gp)
				}
			}
		}
	}
	return result;
}
    ae44:	dfc00017 	ldw	ra,0(sp)
    ae48:	dec00104 	addi	sp,sp,4
    ae4c:	f800283a 	ret

0000ae50 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
    ae50:	deffff04 	addi	sp,sp,-4
    ae54:	dfc00015 	stw	ra,0(sp)
	bool result = false;

	if (alt_up_sd_card_is_Present())
    ae58:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    ae5c:	10000a26 	beq	r2,zero,ae88 <alt_up_sd_card_is_FAT16+0x38>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
    ae60:	d0a09317 	ldw	r2,-32180(gp)
    ae64:	1000061e 	bne	r2,zero,ae80 <alt_up_sd_card_is_FAT16+0x30>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
    ae68:	000adb80 	call	adb8 <Look_for_FAT16>
    ae6c:	d0a09215 	stw	r2,-32184(gp)
			initialized = is_sd_card_formated_as_FAT16;
    ae70:	d0a09315 	stw	r2,-32180(gp)
			search_data.valid = false;
    ae74:	00800074 	movhi	r2,1
    ae78:	10b03004 	addi	r2,r2,-16192
    ae7c:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
    ae80:	d0a09217 	ldw	r2,-32184(gp)
    ae84:	00000306 	br	ae94 <alt_up_sd_card_is_FAT16+0x44>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
    ae88:	d0209315 	stw	zero,-32180(gp)
		is_sd_card_formated_as_FAT16 = false;
    ae8c:	d0209215 	stw	zero,-32184(gp)
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
	bool result = false;
    ae90:	0005883a 	mov	r2,zero
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
	}

	return result;
}
    ae94:	dfc00017 	ldw	ra,0(sp)
    ae98:	dec00104 	addi	sp,sp,4
    ae9c:	f800283a 	ret

0000aea0 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
    aea0:	deffe404 	addi	sp,sp,-112
    aea4:	dd401715 	stw	r21,92(sp)
    aea8:	dfc01b15 	stw	ra,108(sp)
    aeac:	df001a15 	stw	fp,104(sp)
    aeb0:	ddc01915 	stw	r23,100(sp)
    aeb4:	dd801815 	stw	r22,96(sp)
    aeb8:	dd001615 	stw	r20,88(sp)
    aebc:	dcc01515 	stw	r19,84(sp)
    aec0:	dc801415 	stw	r18,80(sp)
    aec4:	dc401315 	stw	r17,76(sp)
    aec8:	dc001215 	stw	r16,72(sp)
    aecc:	202b883a 	mov	r21,r4
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    aed0:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    aed4:	10006c26 	beq	r2,zero,b088 <alt_up_sd_card_find_next+0x1e8>
    aed8:	d0a09217 	ldw	r2,-32184(gp)
    aedc:	10006a26 	beq	r2,zero,b088 <alt_up_sd_card_find_next+0x1e8>
	{
		if (search_data.valid)
    aee0:	04400074 	movhi	r17,1
    aee4:	8c703004 	addi	r17,r17,-16192
    aee8:	88800417 	ldw	r2,16(r17)
    aeec:	10006826 	beq	r2,zero,b090 <alt_up_sd_card_find_next+0x1f0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
    aef0:	8c800117 	ldw	r18,4(r17)
    aef4:	05000074 	movhi	r20,1
    aef8:	a5303504 	addi	r20,r20,-16172
    aefc:	8c00030f 	ldh	r16,12(r17)

			if (cluster == 0)
    af00:	9000251e 	bne	r18,zero,af98 <alt_up_sd_card_find_next+0xf8>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    af04:	a100050b 	ldhu	r4,20(r20)
    af08:	a140030b 	ldhu	r5,12(r20)
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    af0c:	84000044 	addi	r16,r16,1
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    af10:	2008917a 	slli	r4,r4,5
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
    af14:	05c003c4 	movi	r23,15
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    af18:	07003944 	movi	fp,229
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    af1c:	00083040 	call	8304 <__divsi3>
				int sector_index = search_data.current_sector_in_cluster;
    af20:	8c800217 	ldw	r18,8(r17)
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    af24:	102d883a 	mov	r22,r2
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
    af28:	9580050e 	bge	r18,r22,af40 <alt_up_sd_card_find_next+0xa0>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
    af2c:	a1001317 	ldw	r4,76(r20)
    af30:	d1608b17 	ldw	r5,-32212(gp)
    af34:	9109883a 	add	r4,r18,r4
    af38:	0009bd00 	call	9bd0 <Read_Sector_Data>
    af3c:	1000021e 	bne	r2,zero,af48 <alt_up_sd_card_find_next+0xa8>
					else
					{
						break;
					}
				}
				result = -1;
    af40:	04ffffc4 	movi	r19,-1
    af44:	00004e06 	br	b080 <alt_up_sd_card_find_next+0x1e0>
    af48:	8026917a 	slli	r19,r16,5
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
    af4c:	bc000f16 	blt	r23,r16,af8c <alt_up_sd_card_find_next+0xec>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
    af50:	900f883a 	mov	r7,r18
    af54:	000d883a 	mov	r6,zero
    af58:	d80b883a 	mov	r5,sp
    af5c:	9809883a 	mov	r4,r19
    af60:	000a4380 	call	a438 <Read_File_Record_At_Offset>
    af64:	10000626 	beq	r2,zero,af80 <alt_up_sd_card_find_next+0xe0>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    af68:	d8800003 	ldbu	r2,0(sp)
    af6c:	10000426 	beq	r2,zero,af80 <alt_up_sd_card_find_next+0xe0>
    af70:	17000326 	beq	r2,fp,af80 <alt_up_sd_card_find_next+0xe0>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
    af74:	8c00030d 	sth	r16,12(r17)
									search_data.current_sector_in_cluster = sector_index;
    af78:	8c800215 	stw	r18,8(r17)
    af7c:	00002906 	br	b024 <alt_up_sd_card_find_next+0x184>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
    af80:	84000044 	addi	r16,r16,1
    af84:	9cc00804 	addi	r19,r19,32
    af88:	003ff006 	br	af4c <_gp+0xffff72fc>
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
    af8c:	94800044 	addi	r18,r18,1
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
    af90:	0021883a 	mov	r16,zero
    af94:	003fe406 	br	af28 <_gp+0xffff72d8>
				}
				result = -1;
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
    af98:	84000044 	addi	r16,r16,1
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
	short int result = 2;
    af9c:	04c00084 	movi	r19,2
						{        
							for (; file_counter < 16; file_counter++)
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    afa0:	05c03944 	movi	r23,229
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    afa4:	a1400383 	ldbu	r5,14(r20)
    afa8:	913fff84 	addi	r4,r18,-2
    afac:	00095140 	call	9514 <__mulsi3>
    afb0:	a7001417 	ldw	fp,80(r20)
					int sector_index = search_data.current_sector_in_cluster;
    afb4:	8d800217 	ldw	r22,8(r17)
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    afb8:	1739883a 	add	fp,r2,fp
    afbc:	00000206 	br	afc8 <alt_up_sd_card_find_next+0x128>
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    afc0:	b5800044 	addi	r22,r22,1
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
    afc4:	0021883a 	mov	r16,zero
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    afc8:	a0800383 	ldbu	r2,14(r20)
    afcc:	b0801a0e 	bge	r22,r2,b038 <alt_up_sd_card_find_next+0x198>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    afd0:	d1608b17 	ldw	r5,-32212(gp)
    afd4:	e589883a 	add	r4,fp,r22
    afd8:	0009bd00 	call	9bd0 <Read_Sector_Data>
    afdc:	10001626 	beq	r2,zero,b038 <alt_up_sd_card_find_next+0x198>
    afe0:	8010917a 	slli	r8,r16,5
						{        
							for (; file_counter < 16; file_counter++)
    afe4:	008003c4 	movi	r2,15
    afe8:	143ff516 	blt	r2,r16,afc0 <_gp+0xffff7370>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
    afec:	4009883a 	mov	r4,r8
    aff0:	b00f883a 	mov	r7,r22
    aff4:	900d883a 	mov	r6,r18
    aff8:	d80b883a 	mov	r5,sp
    affc:	da001115 	stw	r8,68(sp)
    b000:	000a4380 	call	a438 <Read_File_Record_At_Offset>
    b004:	da001117 	ldw	r8,68(sp)
    b008:	10000e26 	beq	r2,zero,b044 <alt_up_sd_card_find_next+0x1a4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    b00c:	d8800003 	ldbu	r2,0(sp)
    b010:	10000c26 	beq	r2,zero,b044 <alt_up_sd_card_find_next+0x1a4>
    b014:	15c00b26 	beq	r2,r23,b044 <alt_up_sd_card_find_next+0x1a4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
    b018:	8c800115 	stw	r18,4(r17)
										search_data.file_index_in_sector = file_counter;
    b01c:	8c00030d 	sth	r16,12(r17)
										search_data.current_sector_in_cluster = sector_index;
    b020:	8d800215 	stw	r22,8(r17)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
    b024:	a80b883a 	mov	r5,r21
    b028:	d809883a 	mov	r4,sp
    b02c:	00099e40 	call	99e4 <copy_file_record_name_to_string>
									search_data.file_index_in_sector = file_counter;
									search_data.current_sector_in_cluster = sector_index;

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
    b030:	0005883a 	mov	r2,zero
    b034:	00001706 	br	b094 <alt_up_sd_card_find_next+0x1f4>
							break;
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
    b038:	a0800383 	ldbu	r2,14(r20)
    b03c:	b0800e16 	blt	r22,r2,b078 <alt_up_sd_card_find_next+0x1d8>
    b040:	00000306 	br	b050 <alt_up_sd_card_find_next+0x1b0>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
    b044:	84000044 	addi	r16,r16,1
    b048:	42000804 	addi	r8,r8,32
    b04c:	003fe506 	br	afe4 <_gp+0xffff7394>
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
    b050:	d9401004 	addi	r5,sp,64
    b054:	9009883a 	mov	r4,r18
    b058:	0009c700 	call	9c70 <get_cluster_flag>
    b05c:	10000526 	beq	r2,zero,b074 <alt_up_sd_card_find_next+0x1d4>
    b060:	dc80100b 	ldhu	r18,64(sp)
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
    b064:	00bffe14 	movui	r2,65528
    b068:	94bffe0c 	andi	r18,r18,65528
    b06c:	9080021e 	bne	r18,r2,b078 <alt_up_sd_card_find_next+0x1d8>
							{
								result = -1;
								search_data.valid = false;
    b070:	88000415 	stw	zero,16(r17)
							cluster = ((new_cluster) & 0x0000fff8);
						}
						else
						{
							// Error encountered.                 
							result = -1;
    b074:	04ffffc4 	movi	r19,-1
						}
					}              
				} while (cluster < 0x0000fff8);
    b078:	00bffdd4 	movui	r2,65527
    b07c:	14bfc90e 	bge	r2,r18,afa4 <_gp+0xffff7354>
    b080:	9805883a 	mov	r2,r19
    b084:	00000306 	br	b094 <alt_up_sd_card_find_next+0x1f4>
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
	short int result = 2;
    b088:	00800084 	movi	r2,2
    b08c:	00000106 	br	b094 <alt_up_sd_card_find_next+0x1f4>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
    b090:	008000c4 	movi	r2,3
		}
	}
	return result;
}
    b094:	dfc01b17 	ldw	ra,108(sp)
    b098:	df001a17 	ldw	fp,104(sp)
    b09c:	ddc01917 	ldw	r23,100(sp)
    b0a0:	dd801817 	ldw	r22,96(sp)
    b0a4:	dd401717 	ldw	r21,92(sp)
    b0a8:	dd001617 	ldw	r20,88(sp)
    b0ac:	dcc01517 	ldw	r19,84(sp)
    b0b0:	dc801417 	ldw	r18,80(sp)
    b0b4:	dc401317 	ldw	r17,76(sp)
    b0b8:	dc001217 	ldw	r16,72(sp)
    b0bc:	dec01c04 	addi	sp,sp,112
    b0c0:	f800283a 	ret

0000b0c4 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
    b0c4:	deffec04 	addi	sp,sp,-80
    b0c8:	dc001215 	stw	r16,72(sp)
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    b0cc:	d9001115 	stw	r4,68(sp)
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
    b0d0:	dfc01315 	stw	ra,76(sp)
    b0d4:	2821883a 	mov	r16,r5
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    b0d8:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    b0dc:	d9001117 	ldw	r4,68(sp)
    b0e0:	10001526 	beq	r2,zero,b138 <alt_up_sd_card_find_first+0x74>
    b0e4:	d0a09217 	ldw	r2,-32184(gp)
    b0e8:	10001326 	beq	r2,zero,b138 <alt_up_sd_card_find_first+0x74>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
    b0ec:	d80d883a 	mov	r6,sp
    b0f0:	d9401004 	addi	r5,sp,64
    b0f4:	000a5b00 	call	a5b0 <get_home_directory_cluster_for_file>
    b0f8:	10000d26 	beq	r2,zero,b130 <alt_up_sd_card_find_first+0x6c>
		{
			search_data.directory_root_cluster = home_directory_cluster;
    b0fc:	d8c01017 	ldw	r3,64(sp)
    b100:	00800074 	movhi	r2,1
    b104:	10b03004 	addi	r2,r2,-16192
    b108:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
    b10c:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
			search_data.file_index_in_sector = -1;
    b110:	00ffffc4 	movi	r3,-1
    b114:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
			result = alt_up_sd_card_find_next(file_name);
    b118:	8009883a 	mov	r4,r16
		{
			search_data.directory_root_cluster = home_directory_cluster;
			search_data.current_cluster_index = home_directory_cluster;
			search_data.current_sector_in_cluster = 0;
			search_data.file_index_in_sector = -1;
			search_data.valid = true;
    b11c:	00c00044 	movi	r3,1
    b120:	10c00415 	stw	r3,16(r2)

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
		{
			search_data.directory_root_cluster = home_directory_cluster;
			search_data.current_cluster_index = home_directory_cluster;
			search_data.current_sector_in_cluster = 0;
    b124:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
			search_data.valid = true;
			result = alt_up_sd_card_find_next(file_name);
    b128:	000aea00 	call	aea0 <alt_up_sd_card_find_next>
    b12c:	00000306 	br	b13c <alt_up_sd_card_find_first+0x78>
		}
		else
		{
			result = 1;
    b130:	00800044 	movi	r2,1
    b134:	00000106 	br	b13c <alt_up_sd_card_find_first+0x78>
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
	short int result = 2;
    b138:	00800084 	movi	r2,2
		{
			result = 1;
		}
	}
	return result;
}
    b13c:	dfc01317 	ldw	ra,76(sp)
    b140:	dc001217 	ldw	r16,72(sp)
    b144:	dec01404 	addi	sp,sp,80
    b148:	f800283a 	ret

0000b14c <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
    b14c:	deffe804 	addi	sp,sp,-96
    b150:	dd401615 	stw	r21,88(sp)
    b154:	dd001515 	stw	r20,84(sp)
    b158:	dfc01715 	stw	ra,92(sp)
    b15c:	dcc01415 	stw	r19,80(sp)
    b160:	dc801315 	stw	r18,76(sp)
    b164:	dc401215 	stw	r17,72(sp)
    b168:	dc001115 	stw	r16,68(sp)
    b16c:	2029883a 	mov	r20,r4
    b170:	282b883a 	mov	r21,r5
	short int file_record_index = -1;

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    b174:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    b178:	10004f26 	beq	r2,zero,b2b8 <alt_up_sd_card_fopen+0x16c>
    b17c:	d0a09217 	ldw	r2,-32184(gp)
    b180:	10004d26 	beq	r2,zero,b2b8 <alt_up_sd_card_fopen+0x16c>
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
    b184:	a009883a 	mov	r4,r20
{
	short int file_record_index = -1;

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
        unsigned int home_directory_cluster = 0;
    b188:	d8001015 	stw	zero,64(sp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
    b18c:	00096d80 	call	96d8 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
    b190:	a009883a 	mov	r4,r20
    b194:	000972c0 	call	972c <check_file_name_for_FAT16_compliance>
    b198:	1000021e 	bne	r2,zero,b1a4 <alt_up_sd_card_fopen+0x58>
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
	short int file_record_index = -1;
    b19c:	047fffc4 	movi	r17,-1
    b1a0:	00004306 	br	b2b0 <alt_up_sd_card_fopen+0x164>
        if (check_file_name_for_FAT16_compliance(name))
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
    b1a4:	d80d883a 	mov	r6,sp
    b1a8:	d9401004 	addi	r5,sp,64
    b1ac:	a009883a 	mov	r4,r20
    b1b0:	000a5b00 	call	a5b0 <get_home_directory_cluster_for_file>
    b1b4:	10004026 	beq	r2,zero,b2b8 <alt_up_sd_card_fopen+0x16c>
    b1b8:	04800074 	movhi	r18,1
    b1bc:	94b05904 	addi	r18,r18,-16028
    b1c0:	9005883a 	mov	r2,r18
    b1c4:	0027883a 	mov	r19,zero
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    b1c8:	00c00504 	movi	r3,20
    		{
    			if (active_files[index].in_use == false)
    b1cc:	11000017 	ldw	r4,0(r2)
    b1d0:	20000b1e 	bne	r4,zero,b200 <alt_up_sd_card_fopen+0xb4>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
    b1d4:	982091ba 	slli	r16,r19,6
    b1d8:	00c00074 	movhi	r3,1
    b1dc:	18f04a04 	addi	r3,r3,-16088
    b1e0:	d9001017 	ldw	r4,64(sp)
    b1e4:	80e1883a 	add	r16,r16,r3
    b1e8:	800d883a 	mov	r6,r16
    b1ec:	a00b883a 	mov	r5,r20
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    		{
    			if (active_files[index].in_use == false)
    			{
    				file_record_index = index;
    b1f0:	9823883a 	mov	r17,r19
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
    b1f4:	000a8680 	call	a868 <find_file_in_directory>
    b1f8:	1000051e 	bne	r2,zero,b210 <alt_up_sd_card_fopen+0xc4>
    b1fc:	00002106 	br	b284 <alt_up_sd_card_fopen+0x138>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    b200:	9cc00044 	addi	r19,r19,1
    b204:	10801004 	addi	r2,r2,64
    b208:	98fff01e 	bne	r19,r3,b1cc <_gp+0xffff757c>
    b20c:	003fe306 	br	b19c <_gp+0xffff754c>
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
                {
                    if (create)
    b210:	a800291e 	bne	r21,zero,b2b8 <alt_up_sd_card_fopen+0x16c>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
    b214:	8080058b 	ldhu	r2,22(r16)
                    active_files[file_record_index].current_sector_in_cluster = 0;
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    b218:	00c00044 	movi	r3,1
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
                    active_files[file_record_index].current_sector_in_cluster = 0;
    b21c:	80000815 	stw	zero,32(r16)
                    if (create)
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
    b220:	80800715 	stw	r2,28(r16)
                    active_files[file_record_index].current_sector_in_cluster = 0;
                    active_files[file_record_index].current_byte_position = 0;
    b224:	80000915 	stw	zero,36(r16)
                    active_files[file_record_index].in_use = true;
    b228:	80c00f15 	stw	r3,60(r16)
    				active_files[file_record_index].modified = false;
    b22c:	80000e15 	stw	zero,56(r16)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
    b230:	81400a04 	addi	r5,r16,40
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
    b234:	81800b04 	addi	r6,r16,44
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
    b238:	0005883a 	mov	r2,zero
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
    b23c:	84000c04 	addi	r16,r16,48
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
    b240:	01000504 	movi	r4,20
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
    b244:	98800b26 	beq	r19,r2,b274 <alt_up_sd_card_fopen+0x128>
    b248:	91c00017 	ldw	r7,0(r18)
    b24c:	38c0091e 	bne	r7,r3,b274 <alt_up_sd_card_fopen+0x128>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
    b250:	2a000017 	ldw	r8,0(r5)
    b254:	91fffb17 	ldw	r7,-20(r18)
    b258:	41c0061e 	bne	r8,r7,b274 <alt_up_sd_card_fopen+0x128>
    b25c:	32000017 	ldw	r8,0(r6)
    b260:	91fffc17 	ldw	r7,-16(r18)
    b264:	41c0031e 	bne	r8,r7,b274 <alt_up_sd_card_fopen+0x128>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
    b268:	8200000f 	ldh	r8,0(r16)
    b26c:	91fffd0f 	ldh	r7,-12(r18)
    b270:	41c00e26 	beq	r8,r7,b2ac <alt_up_sd_card_fopen+0x160>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
    b274:	10800044 	addi	r2,r2,1
    b278:	94801004 	addi	r18,r18,64
    b27c:	113ff11e 	bne	r2,r4,b244 <_gp+0xffff75f4>
    b280:	00000b06 	br	b2b0 <alt_up_sd_card_fopen+0x164>
							}
						}
					}

                }
                else if (create)
    b284:	a83fc526 	beq	r21,zero,b19c <_gp+0xffff754c>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
    b288:	d80d883a 	mov	r6,sp
    b28c:	800b883a 	mov	r5,r16
    b290:	a009883a 	mov	r4,r20
    b294:	000ac300 	call	ac30 <create_file>
    b298:	103fc026 	beq	r2,zero,b19c <_gp+0xffff754c>
                    {
                        active_files[file_record_index].in_use = true;
    b29c:	00800044 	movi	r2,1
    b2a0:	80800f15 	stw	r2,60(r16)
    					active_files[file_record_index].modified = true;
    b2a4:	80800e15 	stw	r2,56(r16)
    b2a8:	00000106 	br	b2b0 <alt_up_sd_card_fopen+0x164>
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
    b2ac:	047fff84 	movi	r17,-2
    b2b0:	8805883a 	mov	r2,r17
    b2b4:	00000106 	br	b2bc <alt_up_sd_card_fopen+0x170>
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
	short int file_record_index = -1;
    b2b8:	00bfffc4 	movi	r2,-1
    		}
        }
	}

	return file_record_index;
}
    b2bc:	dfc01717 	ldw	ra,92(sp)
    b2c0:	dd401617 	ldw	r21,88(sp)
    b2c4:	dd001517 	ldw	r20,84(sp)
    b2c8:	dcc01417 	ldw	r19,80(sp)
    b2cc:	dc801317 	ldw	r18,76(sp)
    b2d0:	dc401217 	ldw	r17,72(sp)
    b2d4:	dc001117 	ldw	r16,68(sp)
    b2d8:	dec01804 	addi	sp,sp,96
    b2dc:	f800283a 	ret

0000b2e0 <alt_up_sd_card_set_attributes>:

void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    b2e0:	20bfffcc 	andi	r2,r4,65535
    b2e4:	00c004c4 	movi	r3,19
    b2e8:	18800a36 	bltu	r3,r2,b314 <alt_up_sd_card_set_attributes+0x34>
    {
        if (active_files[file_handle].in_use)
    b2ec:	213fffcc 	andi	r4,r4,65535
    b2f0:	2120001c 	xori	r4,r4,32768
    b2f4:	21200004 	addi	r4,r4,-32768
    b2f8:	200891ba 	slli	r4,r4,6
    b2fc:	00800074 	movhi	r2,1
    b300:	10b04a04 	addi	r2,r2,-16088
    b304:	1109883a 	add	r4,r2,r4
    b308:	20800f17 	ldw	r2,60(r4)
    b30c:	10000126 	beq	r2,zero,b314 <alt_up_sd_card_set_attributes+0x34>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
    b310:	214002c5 	stb	r5,11(r4)
    b314:	f800283a 	ret

0000b318 <alt_up_sd_card_get_attributes>:
short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
	short int result = -1;
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    b318:	20bfffcc 	andi	r2,r4,65535
    b31c:	00c004c4 	movi	r3,19
    b320:	18800b36 	bltu	r3,r2,b350 <alt_up_sd_card_get_attributes+0x38>
    {
        if (active_files[file_handle].in_use)
    b324:	213fffcc 	andi	r4,r4,65535
    b328:	2120001c 	xori	r4,r4,32768
    b32c:	21200004 	addi	r4,r4,-32768
    b330:	200891ba 	slli	r4,r4,6
    b334:	00800074 	movhi	r2,1
    b338:	10b04a04 	addi	r2,r2,-16088
    b33c:	1109883a 	add	r4,r2,r4
    b340:	20800f17 	ldw	r2,60(r4)
    b344:	10000226 	beq	r2,zero,b350 <alt_up_sd_card_get_attributes+0x38>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
    b348:	208002c3 	ldbu	r2,11(r4)
    b34c:	f800283a 	ret

short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
	short int result = -1;
    b350:	00bfffc4 	movi	r2,-1
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
		}
	}
	return result;
}
    b354:	f800283a 	ret

0000b358 <alt_up_sd_card_read>:
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    b358:	20bfffcc 	andi	r2,r4,65535
    b35c:	00c004c4 	movi	r3,19
    b360:	18805036 	bltu	r3,r2,b4a4 <alt_up_sd_card_read+0x14c>
    {
        if (active_files[file_handle].in_use)
    b364:	213fffcc 	andi	r4,r4,65535
    b368:	2120001c 	xori	r4,r4,32768
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    b36c:	defff504 	addi	sp,sp,-44
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b370:	21200004 	addi	r4,r4,-32768
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    b374:	dc800315 	stw	r18,12(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b378:	202491ba 	slli	r18,r4,6
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    b37c:	dc000115 	stw	r16,4(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b380:	04000074 	movhi	r16,1
    b384:	84304a04 	addi	r16,r16,-16088
    b388:	8485883a 	add	r2,r16,r18
    b38c:	10c00f17 	ldw	r3,60(r2)
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    b390:	dfc00a15 	stw	ra,40(sp)
    b394:	df000915 	stw	fp,36(sp)
    b398:	ddc00815 	stw	r23,32(sp)
    b39c:	dd800715 	stw	r22,28(sp)
    b3a0:	dd400615 	stw	r21,24(sp)
    b3a4:	dd000515 	stw	r20,20(sp)
    b3a8:	dcc00415 	stw	r19,16(sp)
    b3ac:	dc400215 	stw	r17,8(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b3b0:	18003e26 	beq	r3,zero,b4ac <alt_up_sd_card_read+0x154>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
    b3b4:	15400917 	ldw	r21,36(r2)
    b3b8:	10c00617 	ldw	r3,24(r2)
    b3bc:	a8c03b2e 	bgeu	r21,r3,b4ac <alt_up_sd_card_read+0x154>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b3c0:	05800074 	movhi	r22,1
    b3c4:	15000704 	addi	r20,r2,28
    b3c8:	b5b03504 	addi	r22,r22,-16172
    b3cc:	a7000017 	ldw	fp,0(r20)
    b3d0:	b5c00383 	ldbu	r23,14(r22)
                                  active_files[file_handle].current_sector_in_cluster;
    b3d4:	14400804 	addi	r17,r2,32
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b3d8:	e13fff84 	addi	r4,fp,-2
    b3dc:	b80b883a 	mov	r5,r23
    b3e0:	00095140 	call	9514 <__mulsi3>
                                  active_files[file_handle].current_sector_in_cluster;
    b3e4:	8cc00017 	ldw	r19,0(r17)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b3e8:	b1001417 	ldw	r4,80(r22)
    b3ec:	9909883a 	add	r4,r19,r4
    b3f0:	1109883a 	add	r4,r2,r4
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
    b3f4:	a8001826 	beq	r21,zero,b458 <alt_up_sd_card_read+0x100>
    b3f8:	ad407fcc 	andi	r21,r21,511
    b3fc:	a800161e 	bne	r21,zero,b458 <alt_up_sd_card_read+0x100>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
    b400:	bdffffc4 	addi	r23,r23,-1
    b404:	9dc0111e 	bne	r19,r23,b44c <alt_up_sd_card_read+0xf4>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
    b408:	d80b883a 	mov	r5,sp
    b40c:	e009883a 	mov	r4,fp
    b410:	0009c700 	call	9c70 <get_cluster_flag>
    b414:	10002126 	beq	r2,zero,b49c <alt_up_sd_card_read+0x144>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
    b418:	d900000b 	ldhu	r4,0(sp)
    b41c:	00bffe14 	movui	r2,65528
    b420:	20fffe0c 	andi	r3,r4,65528
    b424:	18802126 	beq	r3,r2,b4ac <alt_up_sd_card_read+0x154>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b428:	b1400383 	ldbu	r5,14(r22)
                                /* End of file */
                                return -1;
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
    b42c:	213fffcc 	andi	r4,r4,65535
    b430:	a1000015 	stw	r4,0(r20)
								active_files[file_handle].current_sector_in_cluster = 0;
    b434:	88000015 	stw	zero,0(r17)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b438:	213fff84 	addi	r4,r4,-2
    b43c:	00095140 	call	9514 <__mulsi3>
    b440:	b1001417 	ldw	r4,80(r22)
    b444:	1109883a 	add	r4,r2,r4
    b448:	00000306 	br	b458 <alt_up_sd_card_read+0x100>
                            return -2;
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
    b44c:	9cc00044 	addi	r19,r19,1
    b450:	8cc00015 	stw	r19,0(r17)
                        data_sector = data_sector + 1;
    b454:	21000044 	addi	r4,r4,1
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
    b458:	d1608b17 	ldw	r5,-32212(gp)
    b45c:	d0a08717 	ldw	r2,-32228(gp)
    b460:	2147883a 	add	r3,r4,r5
    b464:	18800b1e 	bne	r3,r2,b494 <alt_up_sd_card_read+0x13c>
                    {
						return -2;
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
    b468:	84a1883a 	add	r16,r16,r18
    b46c:	84000904 	addi	r16,r16,36
    b470:	80c00017 	ldw	r3,0(r16)
    b474:	d1208c17 	ldw	r4,-32208(gp)
    b478:	18807fcc 	andi	r2,r3,511
    b47c:	2085883a 	add	r2,r4,r2
    b480:	10800023 	ldbuio	r2,0(r2)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
    b484:	18c00044 	addi	r3,r3,1
    b488:	80c00015 	stw	r3,0(r16)
                    {
						return -2;
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
    b48c:	10803fcc 	andi	r2,r2,255
    b490:	00000706 	br	b4b0 <alt_up_sd_card_read+0x158>
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
    b494:	0009bd00 	call	9bd0 <Read_Sector_Data>
    b498:	103ff31e 	bne	r2,zero,b468 <_gp+0xffff7818>
                    {
						return -2;
    b49c:	00bfff84 	movi	r2,-2
    b4a0:	00000306 	br	b4b0 <alt_up_sd_card_read+0x158>

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    b4a4:	00bfffc4 	movi	r2,-1
            }
        }
    }
    
    return ch;
}
    b4a8:	f800283a 	ret

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    b4ac:	00bfffc4 	movi	r2,-1
            }
        }
    }
    
    return ch;
}
    b4b0:	dfc00a17 	ldw	ra,40(sp)
    b4b4:	df000917 	ldw	fp,36(sp)
    b4b8:	ddc00817 	ldw	r23,32(sp)
    b4bc:	dd800717 	ldw	r22,28(sp)
    b4c0:	dd400617 	ldw	r21,24(sp)
    b4c4:	dd000517 	ldw	r20,20(sp)
    b4c8:	dcc00417 	ldw	r19,16(sp)
    b4cc:	dc800317 	ldw	r18,12(sp)
    b4d0:	dc400217 	ldw	r17,8(sp)
    b4d4:	dc000117 	ldw	r16,4(sp)
    b4d8:	dec00b04 	addi	sp,sp,44
    b4dc:	f800283a 	ret

0000b4e0 <alt_up_sd_card_write>:
bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    b4e0:	20bfffcc 	andi	r2,r4,65535
    b4e4:	00c004c4 	movi	r3,19
    b4e8:	1880a536 	bltu	r3,r2,b780 <alt_up_sd_card_write+0x2a0>
    {
        if (active_files[file_handle].in_use)
    b4ec:	213fffcc 	andi	r4,r4,65535
    b4f0:	2120001c 	xori	r4,r4,32768
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    b4f4:	defff104 	addi	sp,sp,-60
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b4f8:	21200004 	addi	r4,r4,-32768
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    b4fc:	dc400615 	stw	r17,24(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b500:	202291ba 	slli	r17,r4,6
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    b504:	dd000915 	stw	r20,36(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b508:	05000074 	movhi	r20,1
    b50c:	a5304a04 	addi	r20,r20,-16088
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    b510:	df000d15 	stw	fp,52(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b514:	a479883a 	add	fp,r20,r17
    b518:	e0800f17 	ldw	r2,60(fp)
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    b51c:	dfc00e15 	stw	ra,56(sp)
    b520:	ddc00c15 	stw	r23,48(sp)
    b524:	dd800b15 	stw	r22,44(sp)
    b528:	dd400a15 	stw	r21,40(sp)
    b52c:	dcc00815 	stw	r19,32(sp)
    b530:	dc800715 	stw	r18,28(sp)
    b534:	dc000515 	stw	r16,20(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    b538:	1000021e 	bne	r2,zero,b544 <alt_up_sd_card_write+0x64>


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    b53c:	0005883a 	mov	r2,zero
    b540:	00008306 	br	b750 <alt_up_sd_card_write+0x270>
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b544:	05000074 	movhi	r20,1
    b548:	a5303504 	addi	r20,r20,-16172
    b54c:	e5800704 	addi	r22,fp,28
    b550:	b2000017 	ldw	r8,0(r22)
    b554:	a4c00383 	ldbu	r19,14(r20)
    b558:	d9400115 	stw	r5,4(sp)
    b55c:	413fff84 	addi	r4,r8,-2
                              active_files[file_handle].current_sector_in_cluster;
    b560:	e5400804 	addi	r21,fp,32
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b564:	980b883a 	mov	r5,r19
                              active_files[file_handle].current_sector_in_cluster;
    b568:	adc00017 	ldw	r23,0(r21)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b56c:	da000415 	stw	r8,16(sp)
    b570:	00095140 	call	9514 <__mulsi3>
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    b574:	e1800917 	ldw	r6,36(fp)
    b578:	a1c0030b 	ldhu	r7,12(r20)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b57c:	a4001417 	ldw	r16,80(r20)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    b580:	3009883a 	mov	r4,r6
    b584:	380b883a 	mov	r5,r7
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b588:	bc21883a 	add	r16,r23,r16
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    b58c:	d9800215 	stw	r6,8(sp)
    b590:	d9c00315 	stw	r7,12(sp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b594:	1421883a 	add	r16,r2,r16
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    b598:	00084600 	call	8460 <__umodsi3>
    b59c:	1025883a 	mov	r18,r2

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
    b5a0:	d9800217 	ldw	r6,8(sp)
    b5a4:	e0800617 	ldw	r2,24(fp)
    b5a8:	d9c00317 	ldw	r7,12(sp)
    b5ac:	a039883a 	mov	fp,r20
    b5b0:	da000417 	ldw	r8,16(sp)
    b5b4:	3080192e 	bgeu	r6,r2,b61c <alt_up_sd_card_write+0x13c>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
    b5b8:	30004526 	beq	r6,zero,b6d0 <alt_up_sd_card_write+0x1f0>
    b5bc:	90bfffcc 	andi	r2,r18,65535
    b5c0:	10a0001c 	xori	r2,r2,32768
    b5c4:	10a00004 	addi	r2,r2,-32768
    b5c8:	1000411e 	bne	r2,zero,b6d0 <alt_up_sd_card_write+0x1f0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
    b5cc:	9cffffc4 	addi	r19,r19,-1
    b5d0:	bcc00e1e 	bne	r23,r19,b60c <alt_up_sd_card_write+0x12c>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
    b5d4:	d80b883a 	mov	r5,sp
    b5d8:	4009883a 	mov	r4,r8
    b5dc:	0009c700 	call	9c70 <get_cluster_flag>
    b5e0:	10005b26 	beq	r2,zero,b750 <alt_up_sd_card_write+0x270>
                        {
                            if (next_cluster < 0x0000fff8)
    b5e4:	d900000b 	ldhu	r4,0(sp)
    b5e8:	00bffdd4 	movui	r2,65527
    b5ec:	11003836 	bltu	r2,r4,b6d0 <alt_up_sd_card_write+0x1f0>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b5f0:	a1400383 	ldbu	r5,14(r20)
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
    b5f4:	b1000015 	stw	r4,0(r22)
								active_files[file_handle].current_sector_in_cluster = 0;
    b5f8:	a8000015 	stw	zero,0(r21)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b5fc:	213fff84 	addi	r4,r4,-2
    b600:	00095140 	call	9514 <__mulsi3>
    b604:	a4001417 	ldw	r16,80(r20)
    b608:	00003006 	br	b6cc <alt_up_sd_card_write+0x1ec>
                            return false;
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
    b60c:	b8c00044 	addi	r3,r23,1
    b610:	a8c00015 	stw	r3,0(r21)
                        data_sector = data_sector + 1;
    b614:	84000044 	addi	r16,r16,1
    b618:	00002d06 	br	b6d0 <alt_up_sd_card_write+0x1f0>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
    b61c:	30002c26 	beq	r6,zero,b6d0 <alt_up_sd_card_write+0x1f0>
    b620:	90bfffcc 	andi	r2,r18,65535
    b624:	10a0001c 	xori	r2,r2,32768
    b628:	10a00004 	addi	r2,r2,-32768
    b62c:	1000281e 	bne	r2,zero,b6d0 <alt_up_sd_card_write+0x1f0>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
    b630:	9cffffc4 	addi	r19,r19,-1
    b634:	bcc0171e 	bne	r23,r19,b694 <alt_up_sd_card_write+0x1b4>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
    b638:	d809883a 	mov	r4,sp
    b63c:	000a1300 	call	a130 <find_first_empty_cluster>
    b640:	10004326 	beq	r2,zero,b750 <alt_up_sd_card_write+0x270>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
    b644:	d940000f 	ldh	r5,0(sp)
    b648:	b1000017 	ldw	r4,0(r22)
    b64c:	01800044 	movi	r6,1
    b650:	0009cf00 	call	9cf0 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
    b654:	d9000017 	ldw	r4,0(sp)
    b658:	01800044 	movi	r6,1
    b65c:	017fffc4 	movi	r5,-1
    b660:	0009cf00 	call	9cf0 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
    b664:	d940000f 	ldh	r5,0(sp)
    b668:	b1000017 	ldw	r4,0(r22)
    b66c:	000d883a 	mov	r6,zero
    b670:	0009cf00 	call	9cf0 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
    b674:	d9000017 	ldw	r4,0(sp)
    b678:	000d883a 	mov	r6,zero
    b67c:	017fffc4 	movi	r5,-1
    b680:	0009cf00 	call	9cf0 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
    b684:	d8800017 	ldw	r2,0(sp)
							active_files[file_handle].current_sector_in_cluster = 0;
    b688:	a8000015 	stw	zero,0(r21)
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
							mark_cluster(cluster_number, 0xffff, true);
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
							mark_cluster(cluster_number, 0xffff, false);
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
    b68c:	b0800015 	stw	r2,0(r22)
    b690:	00000406 	br	b6a4 <alt_up_sd_card_write+0x1c4>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
    b694:	380b883a 	mov	r5,r7
    b698:	3009883a 	mov	r4,r6
    b69c:	00083fc0 	call	83fc <__udivsi3>
    b6a0:	a8800015 	stw	r2,0(r21)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    b6a4:	00800074 	movhi	r2,1
    b6a8:	10b04a04 	addi	r2,r2,-16088
    b6ac:	1467883a 	add	r19,r2,r17
    b6b0:	99000717 	ldw	r4,28(r19)
    b6b4:	e1400383 	ldbu	r5,14(fp)
    b6b8:	213fff84 	addi	r4,r4,-2
    b6bc:	00095140 	call	9514 <__mulsi3>
    b6c0:	98c00817 	ldw	r3,32(r19)
    b6c4:	e4001417 	ldw	r16,80(fp)
    b6c8:	80e1883a 	add	r16,r16,r3
    b6cc:	1421883a 	add	r16,r2,r16
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
    b6d0:	d1608b17 	ldw	r5,-32212(gp)
    b6d4:	d0a08717 	ldw	r2,-32228(gp)
    b6d8:	8147883a 	add	r3,r16,r5
    b6dc:	1880161e 	bne	r3,r2,b738 <alt_up_sd_card_write+0x258>
                {
					return false;
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
    b6e0:	d0a08c17 	ldw	r2,-32208(gp)
    b6e4:	94bfffcc 	andi	r18,r18,65535
    b6e8:	94a0001c 	xori	r18,r18,32768
    b6ec:	94a00004 	addi	r18,r18,-32768
    b6f0:	14a5883a 	add	r18,r2,r18
    b6f4:	d8800117 	ldw	r2,4(sp)
    b6f8:	90800025 	stbio	r2,0(r18)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
    b6fc:	00800074 	movhi	r2,1
    b700:	10b04a04 	addi	r2,r2,-16088
    b704:	1463883a 	add	r17,r2,r17
    b708:	88800904 	addi	r2,r17,36
    b70c:	10c00017 	ldw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
    b710:	89400604 	addi	r5,r17,24
    b714:	01000044 	movi	r4,1
					return false;
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
    b718:	18c00044 	addi	r3,r3,1
    b71c:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
    b720:	28800017 	ldw	r2,0(r5)
    b724:	18800836 	bltu	r3,r2,b748 <alt_up_sd_card_write+0x268>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
    b728:	10800044 	addi	r2,r2,1
    b72c:	28800015 	stw	r2,0(r5)
				active_files[file_handle].modified = true;
    b730:	89000e15 	stw	r4,56(r17)
    b734:	00000406 	br	b748 <alt_up_sd_card_write+0x268>
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
    b738:	8009883a 	mov	r4,r16
    b73c:	0009bd00 	call	9bd0 <Read_Sector_Data>
    b740:	103fe71e 	bne	r2,zero,b6e0 <_gp+0xffff7a90>
    b744:	003f7d06 	br	b53c <_gp+0xffff78ec>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
				active_files[file_handle].modified = true;
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
    b748:	d1208815 	stw	r4,-32224(gp)
			result = true;
    b74c:	00800044 	movi	r2,1
		}
    }
    
    return result;
}
    b750:	dfc00e17 	ldw	ra,56(sp)
    b754:	df000d17 	ldw	fp,52(sp)
    b758:	ddc00c17 	ldw	r23,48(sp)
    b75c:	dd800b17 	ldw	r22,44(sp)
    b760:	dd400a17 	ldw	r21,40(sp)
    b764:	dd000917 	ldw	r20,36(sp)
    b768:	dcc00817 	ldw	r19,32(sp)
    b76c:	dc800717 	ldw	r18,28(sp)
    b770:	dc400617 	ldw	r17,24(sp)
    b774:	dc000517 	ldw	r16,20(sp)
    b778:	dec00f04 	addi	sp,sp,60
    b77c:	f800283a 	ret


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    b780:	0005883a 	mov	r2,zero
			result = true;
		}
    }
    
    return result;
}
    b784:	f800283a 	ret

0000b788 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
    b788:	defffc04 	addi	sp,sp,-16
    b78c:	dc000015 	stw	r16,0(sp)
    b790:	dfc00315 	stw	ra,12(sp)
    b794:	dc800215 	stw	r18,8(sp)
    b798:	dc400115 	stw	r17,4(sp)
    b79c:	2021883a 	mov	r16,r4
    bool result = false;
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    b7a0:	0009acc0 	call	9acc <alt_up_sd_card_is_Present>
    b7a4:	10002726 	beq	r2,zero,b844 <alt_up_sd_card_fclose+0xbc>
    b7a8:	d0a09217 	ldw	r2,-32184(gp)
    b7ac:	10002526 	beq	r2,zero,b844 <alt_up_sd_card_fclose+0xbc>
    {
        if (active_files[file_handle].in_use) 
    b7b0:	813fffcc 	andi	r4,r16,65535
    b7b4:	2120001c 	xori	r4,r4,32768
    b7b8:	21200004 	addi	r4,r4,-32768
    b7bc:	202091ba 	slli	r16,r4,6
    b7c0:	04800074 	movhi	r18,1
    b7c4:	94b04a04 	addi	r18,r18,-16088
    b7c8:	9407883a 	add	r3,r18,r16
    b7cc:	18800f17 	ldw	r2,60(r3)
    b7d0:	10001c26 	beq	r2,zero,b844 <alt_up_sd_card_fclose+0xbc>
        {
			if (active_files[file_handle].modified)
    b7d4:	18800e17 	ldw	r2,56(r3)
    b7d8:	10001626 	beq	r2,zero,b834 <alt_up_sd_card_fclose+0xac>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
				if (active_files[file_handle].file_record_cluster == 0)
    b7dc:	19800a17 	ldw	r6,40(r3)
    b7e0:	01400074 	movhi	r5,1
    {
        if (active_files[file_handle].in_use) 
        {
			if (active_files[file_handle].modified)
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
    b7e4:	19000b17 	ldw	r4,44(r3)
    b7e8:	29703504 	addi	r5,r5,-16172
				if (active_files[file_handle].file_record_cluster == 0)
    b7ec:	3000031e 	bne	r6,zero,b7fc <alt_up_sd_card_fclose+0x74>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
    b7f0:	28c01317 	ldw	r3,76(r5)
    b7f4:	20c9883a 	add	r4,r4,r3
    b7f8:	00000606 	br	b814 <alt_up_sd_card_fclose+0x8c>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
    b7fc:	28c01417 	ldw	r3,80(r5)
    b800:	29400383 	ldbu	r5,14(r5)
    b804:	20e3883a 	add	r17,r4,r3
    b808:	313fff84 	addi	r4,r6,-2
    b80c:	00095140 	call	9514 <__mulsi3>
    b810:	1449883a 	add	r4,r2,r17
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
    b814:	d1608b17 	ldw	r5,-32212(gp)
    b818:	0009bd00 	call	9bd0 <Read_Sector_Data>
    b81c:	10000526 	beq	r2,zero,b834 <alt_up_sd_card_fclose+0xac>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
    b820:	940b883a 	add	r5,r18,r16
    b824:	29000c0f 	ldh	r4,48(r5)
    b828:	000aacc0 	call	aacc <Write_File_Record_At_Offset>
    b82c:	10000126 	beq	r2,zero,b834 <alt_up_sd_card_fclose+0xac>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
    b830:	0009bb40 	call	9bb4 <Save_Modified_Sector>
					}
				}
			}
			active_files[file_handle].in_use = false;
    b834:	9421883a 	add	r16,r18,r16
    b838:	80000f15 	stw	zero,60(r16)
			result = true;
    b83c:	00800044 	movi	r2,1
    b840:	00000106 	br	b848 <alt_up_sd_card_fclose+0xc0>


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
    bool result = false;
    b844:	0005883a 	mov	r2,zero
			result = true;
        }
    }
    
    return result;
}
    b848:	dfc00317 	ldw	ra,12(sp)
    b84c:	dc800217 	ldw	r18,8(sp)
    b850:	dc400117 	ldw	r17,4(sp)
    b854:	dc000017 	ldw	r16,0(sp)
    b858:	dec00404 	addi	sp,sp,16
    b85c:	f800283a 	ret

0000b860 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
    b860:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
    b864:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
    b868:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
    b86c:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
    b870:	2980072e 	bgeu	r5,r6,b890 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
    b874:	38c00037 	ldwio	r3,0(r7)
    b878:	18ffffec 	andhi	r3,r3,65535
    b87c:	183ffc26 	beq	r3,zero,b870 <_gp+0xffff7c20>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
    b880:	28c00007 	ldb	r3,0(r5)
    b884:	20c00035 	stwio	r3,0(r4)
    b888:	29400044 	addi	r5,r5,1
    b88c:	003ff806 	br	b870 <_gp+0xffff7c20>

  return count;
}
    b890:	f800283a 	ret

0000b894 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    b894:	f800283a 	ret

0000b898 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
    b898:	3005883a 	mov	r2,r6
    b89c:	f800283a 	ret

0000b8a0 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
    b8a0:	20000226 	beq	r4,zero,b8ac <alt_dev_llist_insert+0xc>
    b8a4:	20800217 	ldw	r2,8(r4)
    b8a8:	1000101e 	bne	r2,zero,b8ec <alt_dev_llist_insert+0x4c>
    b8ac:	d0a00817 	ldw	r2,-32736(gp)
    b8b0:	10000926 	beq	r2,zero,b8d8 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
    b8b4:	deffff04 	addi	sp,sp,-4
    b8b8:	dfc00015 	stw	ra,0(sp)
    b8bc:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
    b8c0:	00c00584 	movi	r3,22
    b8c4:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
    b8c8:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
    b8cc:	dfc00017 	ldw	ra,0(sp)
    b8d0:	dec00104 	addi	sp,sp,4
    b8d4:	f800283a 	ret
    b8d8:	d0a08304 	addi	r2,gp,-32244
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
    b8dc:	00c00584 	movi	r3,22
    b8e0:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
    b8e4:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
    b8e8:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
    b8ec:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
    b8f0:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
    b8f4:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
    b8f8:	28800017 	ldw	r2,0(r5)
    b8fc:	11000115 	stw	r4,4(r2)
  list->next           = entry;
    b900:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
    b904:	0005883a 	mov	r2,zero
    b908:	f800283a 	ret

0000b90c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
    b90c:	defffb04 	addi	sp,sp,-20
    b910:	dcc00315 	stw	r19,12(sp)
    b914:	dc800215 	stw	r18,8(sp)
    b918:	dc400115 	stw	r17,4(sp)
    b91c:	dc000015 	stw	r16,0(sp)
    b920:	dfc00415 	stw	ra,16(sp)
    b924:	2027883a 	mov	r19,r4
    b928:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
    b92c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
    b930:	00087780 	call	8778 <strlen>
    b934:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
    b938:	84400726 	beq	r16,r17,b958 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
    b93c:	81000217 	ldw	r4,8(r16)
    b940:	900d883a 	mov	r6,r18
    b944:	980b883a 	mov	r5,r19
    b948:	000b98c0 	call	b98c <memcmp>
    b94c:	10000426 	beq	r2,zero,b960 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
    b950:	84000017 	ldw	r16,0(r16)
    b954:	003ff806 	br	b938 <_gp+0xffff7ce8>
  }
  
  /* No match found */
  
  return NULL;
    b958:	0005883a 	mov	r2,zero
    b95c:	00000106 	br	b964 <alt_find_dev+0x58>
    b960:	8005883a 	mov	r2,r16
}
    b964:	dfc00417 	ldw	ra,16(sp)
    b968:	dcc00317 	ldw	r19,12(sp)
    b96c:	dc800217 	ldw	r18,8(sp)
    b970:	dc400117 	ldw	r17,4(sp)
    b974:	dc000017 	ldw	r16,0(sp)
    b978:	dec00504 	addi	sp,sp,20
    b97c:	f800283a 	ret

0000b980 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
    b980:	f800283a 	ret

0000b984 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    b984:	000170fa 	wrctl	ienable,zero
    b988:	f800283a 	ret

0000b98c <memcmp>:
    b98c:	218d883a 	add	r6,r4,r6
    b990:	21800826 	beq	r4,r6,b9b4 <memcmp+0x28>
    b994:	20800003 	ldbu	r2,0(r4)
    b998:	28c00003 	ldbu	r3,0(r5)
    b99c:	10c00226 	beq	r2,r3,b9a8 <memcmp+0x1c>
    b9a0:	10c5c83a 	sub	r2,r2,r3
    b9a4:	f800283a 	ret
    b9a8:	21000044 	addi	r4,r4,1
    b9ac:	29400044 	addi	r5,r5,1
    b9b0:	003ff706 	br	b990 <_gp+0xffff7d40>
    b9b4:	0005883a 	mov	r2,zero
    b9b8:	f800283a 	ret

0000b9bc <memcpy>:
    b9bc:	2005883a 	mov	r2,r4
    b9c0:	2007883a 	mov	r3,r4
    b9c4:	218d883a 	add	r6,r4,r6
    b9c8:	19800526 	beq	r3,r6,b9e0 <memcpy+0x24>
    b9cc:	29000003 	ldbu	r4,0(r5)
    b9d0:	18c00044 	addi	r3,r3,1
    b9d4:	29400044 	addi	r5,r5,1
    b9d8:	193fffc5 	stb	r4,-1(r3)
    b9dc:	003ffa06 	br	b9c8 <_gp+0xffff7d78>
    b9e0:	f800283a 	ret
