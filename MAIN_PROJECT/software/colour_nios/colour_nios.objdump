
colour_nios.elf:     file format elf32-littlenios2
colour_nios.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00008020

Program Header:
    LOAD off    0x00001000 vaddr 0x00008000 paddr 0x00008000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00008020 paddr 0x00008020 align 2**12
         filesz 0x00003250 memsz 0x00003250 flags r-x
    LOAD off    0x00004270 vaddr 0x0000b270 paddr 0x0000b5f8 align 2**12
         filesz 0x00000388 memsz 0x00000388 flags rw-
    LOAD off    0x00004980 vaddr 0x0000b980 paddr 0x0000b980 align 2**12
         filesz 0x00000000 memsz 0x000005c0 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00008000  00008000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00008020  00008020  000045f8  2**0
                  CONTENTS
  2 .text         00003148  00008020  00008020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00000108  0000b168  0000b168  00004168  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000388  0000b270  0000b5f8  00004270  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000005c0  0000b980  0000b980  00004980  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  0000bf40  0000bf40  000045f8  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000045f8  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 00000398  00000000  00000000  00004620  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   000071b8  00000000  00000000  000049b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001e42  00000000  00000000  0000bb70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0000274c  00000000  00000000  0000d9b2  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000a48  00000000  00000000  00010100  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001db8  00000000  00000000  00010b48  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    00003384  00000000  00000000  00012900  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000010  00000000  00000000  00015c84  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000528  00000000  00000000  00015c98  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  00017cfe  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00017d01  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  00017d0d  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  00017d0e  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  00017d0f  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  00017d1a  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  00017d25  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000004  00000000  00000000  00017d30  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000041  00000000  00000000  00017d34  2**0
                  CONTENTS, READONLY
 26 .jdi          00004c49  00000000  00000000  00017d75  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     00058255  00000000  00000000  0001c9be  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00008000 l    d  .entry	00000000 .entry
00008020 l    d  .exceptions	00000000 .exceptions
00008020 l    d  .text	00000000 .text
0000b168 l    d  .rodata	00000000 .rodata
0000b270 l    d  .rwdata	00000000 .rwdata
0000b980 l    d  .bss	00000000 .bss
0000bf40 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../colour_nios_bsp//obj/HAL/src/crt0.o
00008058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
0000859c l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
0000b470 l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_putstr.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0000b550 l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
0000b01c l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
0000b9cc g     O .bss	00000004 aux_status_register
00008d68 g     F .text	0000002c alt_main
000084ec g     F .text	00000080 _puts_r
0000b5f8 g       *ABS*	00000000 __flash_rwdata_start
00009500 g     F .text	00000108 Check_for_Master_Boot_Record
0000af0c g     F .text	000000d8 alt_up_sd_card_fclose
000084a0 g     F .text	0000004c printf
0000b9a8 g     O .bss	00000004 current_sector_modified
00009250 g     F .text	00000068 alt_up_sd_card_is_Present
00008080 g     F .text	00000060 grayScale
00009338 g     F .text	0000001c Save_Modified_Sector
00008d94 g     F .text	00000038 alt_putstr
0000b108 g     F .text	00000008 altera_nios2_gen2_irq_init
00008000 g     F .entry	0000000c __reset
0000b9b0 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
00008020 g       *ABS*	00000000 __flash_exceptions_start
0000b994 g     O .bss	00000004 errno
0000b99c g     O .bss	00000004 alt_argv
000135d4 g       *ABS*	00000000 _gp
0000a8d0 g     F .text	00000194 alt_up_sd_card_fopen
0000a848 g     F .text	00000088 alt_up_sd_card_find_first
0000b9bc g     O .bss	00000004 command_argument_register
0000b57c g     O .rwdata	00000030 alt_fd_list
00009af4 g     F .text	000000c8 find_first_empty_record_in_root_directory
0000b090 g     F .text	00000074 alt_find_dev
0000b140 g     F .text	00000028 memcpy
0000856c g     F .text	00000014 puts
000098b4 g     F .text	000000a4 find_first_empty_cluster
000091e8 g     F .text	00000068 alt_up_sd_card_open_dev
00008464 g     F .text	0000003c _printf_r
00008000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
000083a8 g     F .text	00000064 .hidden __udivsi3
00008f8c g     F .text	00000058 get_dir_divider_location
00008e5c g     F .text	00000054 filename_to_upper_case
0000aa64 g     F .text	00000038 alt_up_sd_card_set_attributes
00009bbc g     F .text	00000178 Read_File_Record_At_Offset
0000b5e0 g     O .rwdata	00000004 alt_max_fd
00009fec g     F .text	00000264 find_file_in_directory
0000a5d4 g     F .text	00000050 alt_up_sd_card_is_FAT16
0000b5d4 g     O .rwdata	00000004 _global_impure_ptr
00009d34 g     F .text	000002b8 get_home_directory_cluster_for_file
0000bf40 g       *ABS*	00000000 __bss_end
0000b9a4 g     O .bss	00000004 current_sector_index
0000b980 g     O .bss	00000004 SWITCHES
00008068 g     F .text	0000000c greenFilter
00009474 g     F .text	0000008c mark_cluster
0000b5ac g     O .rwdata	00000028 alt_dev_null
000090d0 g     F .text	00000098 convert_filename_to_name_extension
0000b018 g     F .text	00000004 alt_dcache_flush_all
0000b9d0 g     O .bss	00000004 is_sd_card_formated_as_FAT16
0000b984 g     O .bss	00000004 B
00009958 g     F .text	0000019c find_first_empty_record_in_a_subdirectory
0000b5f8 g       *ABS*	00000000 __ram_rwdata_end
0000b5e4 g     O .rwdata	00000008 alt_dev_list
00008dcc g     F .text	00000060 write
0000b9ac g     O .bss	00000004 device_pointer
0000b270 g       *ABS*	00000000 __ram_rodata_end
0000b5dc g     O .rwdata	00000004 jtag_uart_0
0000840c g     F .text	00000058 .hidden __umodsi3
0000bf40 g       *ABS*	00000000 end
00010000 g       *ABS*	00000000 __alt_stack_pointer
0000afe4 g     F .text	00000034 altera_avalon_jtag_uart_write
00008608 g     F .text	0000052c ___vfprintf_internal_r
00008020 g     F .text	0000003c _start
00008e4c g     F .text	00000010 alt_sys_init
0000b270 g     O .rwdata	00000200 buffer
00008c60 g     F .text	00000028 .hidden __mulsi3
0000b270 g       *ABS*	00000000 __ram_rwdata_start
0000b168 g       *ABS*	00000000 __ram_rodata_start
0000b988 g     O .bss	00000004 G
0000b9d4 g     O .bss	00000004 initialized
0000b9d8 g     O .bss	00000014 search_data
00008074 g     F .text	0000000c blueFilter
0000b110 g     F .text	00000030 memcmp
0000bf40 g       *ABS*	00000000 __alt_stack_base
0000b9ec g     O .bss	00000054 boot_sector_data
0000805c g     F .text	0000000c redFilter
0000b024 g     F .text	0000006c alt_dev_llist_insert
0000b98c g     O .bss	00000002 sd_fileh
00008b50 g     F .text	000000b8 __sfvwrite_small_dev
0000b980 g       *ABS*	00000000 __bss_start
000080e0 g     F .text	000001d0 main
0000b998 g     O .bss	00000004 alt_envp
0000aa9c g     F .text	00000040 alt_up_sd_card_get_attributes
000092b8 g     F .text	00000080 Write_Sector_Data
0000ac64 g     F .text	000002a8 alt_up_sd_card_write
0000b5f4 g     O .rwdata	00000004 alt_errno
000082b0 g     F .text	00000084 .hidden __divsi3
0000b9c8 g     O .bss	00000004 status_register
0000b9c0 g     O .bss	00000004 command_register
0000b168 g       *ABS*	00000000 __flash_rodata_start
00008e2c g     F .text	00000020 alt_irq_init
000093f4 g     F .text	00000080 get_cluster_flag
0000a250 g     F .text	00000164 Write_File_Record_At_Offset
0000b990 g     O .bss	00000004 R
00008c08 g     F .text	00000058 _write_r
00009608 g     F .text	000002ac Check_for_DOS_FAT
0000a3b4 g     F .text	00000188 create_file
0000b5d8 g     O .rwdata	00000004 _impure_ptr
0000b9c4 g     O .bss	00000004 CSD_register_w0
0000b9a0 g     O .bss	00000004 alt_argc
0000b5ec g     O .rwdata	00000008 alt_fs_list
00008eb0 g     F .text	000000dc check_file_name_for_FAT16_compliance
0000b9b8 g     O .bss	00000004 buffer_memory
00008020 g       *ABS*	00000000 __ram_exceptions_start
0000b9b4 g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
0000b5f8 g       *ABS*	00000000 _edata
0000bf40 g       *ABS*	00000000 _end
0000ba40 g     O .bss	00000500 active_files
00008020 g       *ABS*	00000000 __ram_exceptions_end
00009168 g     F .text	00000080 copy_file_record_name_to_string
0000a53c g     F .text	00000098 Look_for_FAT16
0000a624 g     F .text	00000224 alt_up_sd_card_find_next
00008334 g     F .text	00000074 .hidden __modsi3
00009354 g     F .text	000000a0 Read_Sector_Data
00010000 g       *ABS*	00000000 __alt_data_end
0000800c g       .entry	00000000 _exit
0000aadc g     F .text	00000188 alt_up_sd_card_read
00008580 g     F .text	0000001c strlen
0000b104 g     F .text	00000004 alt_icache_flush_all
00008b34 g     F .text	0000001c __vfprintf_internal
00008c88 g     F .text	000000e0 alt_load
00008fe4 g     F .text	000000ec match_file_record_to_name_ext



Disassembly of section .entry:

00008000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
    8000:	00400034 	movhi	at,0
    ori r1, r1, %lo(_start)
    8004:	08600814 	ori	at,at,32800
    jmp r1
    8008:	0800683a 	jmp	at

0000800c <_exit>:
	...

Disassembly of section .text:

00008020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
    8020:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
    8024:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
    8028:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
    802c:	d68d7514 	ori	gp,gp,13780
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
    8030:	00800034 	movhi	r2,0
    ori r2, r2, %lo(__bss_start)
    8034:	10ae6014 	ori	r2,r2,47488

    movhi r3, %hi(__bss_end)
    8038:	00c00034 	movhi	r3,0
    ori r3, r3, %lo(__bss_end)
    803c:	18efd014 	ori	r3,r3,48960

    beq r2, r3, 1f
    8040:	10c00326 	beq	r2,r3,8050 <_start+0x30>

0:
    stw zero, (r2)
    8044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
    8048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
    804c:	10fffd36 	bltu	r2,r3,8044 <_gp+0xffff4a70>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
    8050:	0008c880 	call	8c88 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
    8054:	0008d680 	call	8d68 <alt_main>

00008058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
    8058:	003fff06 	br	8058 <_gp+0xffff4a84>

0000805c <redFilter>:
    805c:	20000015 	stw	zero,0(r4)
    8060:	28000015 	stw	zero,0(r5)
    8064:	f800283a 	ret

00008068 <greenFilter>:
    8068:	20000015 	stw	zero,0(r4)
    806c:	28000015 	stw	zero,0(r5)
    8070:	f800283a 	ret

00008074 <blueFilter>:
	*B = 0;
	return;
}

void blueFilter(uint *R, uint *G){
	*R = 0;
    8074:	20000015 	stw	zero,0(r4)
	*G = 0;
    8078:	28000015 	stw	zero,0(r5)
    807c:	f800283a 	ret

00008080 <grayScale>:
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    8080:	defffc04 	addi	sp,sp,-16
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	*R = *G = *B = ((*R + *G + *B) / 3);
    8084:	30800017 	ldw	r2,0(r6)
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    8088:	dc000015 	stw	r16,0(sp)
    808c:	2021883a 	mov	r16,r4
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	*R = *G = *B = ((*R + *G + *B) / 3);
    8090:	29000017 	ldw	r4,0(r5)
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    8094:	dc400115 	stw	r17,4(sp)
    8098:	2823883a 	mov	r17,r5
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	*R = *G = *B = ((*R + *G + *B) / 3);
    809c:	2085883a 	add	r2,r4,r2
    80a0:	81000017 	ldw	r4,0(r16)
    80a4:	014000c4 	movi	r5,3
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    80a8:	dc800215 	stw	r18,8(sp)
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	*R = *G = *B = ((*R + *G + *B) / 3);
    80ac:	1109883a 	add	r4,r2,r4
	*R = 0;
	*G = 0;
	return;
}

void grayScale(uint *R, uint *G, uint *B){
    80b0:	3025883a 	mov	r18,r6
    80b4:	dfc00315 	stw	ra,12(sp)
	/**
	 * GRAYSCALE is calculated by forming a weighted sum of the Red, Green, and Blue colour and dividing it by 3
	 * This value then replaces the old RGB value;	 *
	 */
	*R = *G = *B = ((*R + *G + *B) / 3);
    80b8:	00083a80 	call	83a8 <__udivsi3>
    80bc:	90800015 	stw	r2,0(r18)
    80c0:	88800015 	stw	r2,0(r17)
    80c4:	80800015 	stw	r2,0(r16)
	return;
}
    80c8:	dfc00317 	ldw	ra,12(sp)
    80cc:	dc800217 	ldw	r18,8(sp)
    80d0:	dc400117 	ldw	r17,4(sp)
    80d4:	dc000017 	ldw	r16,0(sp)
    80d8:	dec00404 	addi	sp,sp,16
    80dc:	f800283a 	ret

000080e0 <main>:

int main()
{
  alt_putstr("Hello from Nios II!\n");
    80e0:	01000074 	movhi	r4,1
	*R = *G = *B = ((*R + *G + *B) / 3);
	return;
}

int main()
{
    80e4:	defffb04 	addi	sp,sp,-20
  alt_putstr("Hello from Nios II!\n");
    80e8:	212c5a04 	addi	r4,r4,-20120
	*R = *G = *B = ((*R + *G + *B) / 3);
	return;
}

int main()
{
    80ec:	dfc00415 	stw	ra,16(sp)
    80f0:	dcc00315 	stw	r19,12(sp)
    80f4:	dc800215 	stw	r18,8(sp)
    80f8:	dc400115 	stw	r17,4(sp)
    80fc:	dc000015 	stw	r16,0(sp)
  alt_putstr("Hello from Nios II!\n");
    8100:	0008d940 	call	8d94 <alt_putstr>
  printf("SD Card Access Test\n");
    8104:	01000074 	movhi	r4,1
    8108:	212c6004 	addi	r4,r4,-20096
    810c:	000856c0 	call	856c <puts>

  alt_up_sd_card_dev *sd_card_dev = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
    8110:	01000074 	movhi	r4,1
    8114:	212c6504 	addi	r4,r4,-20076
    8118:	00091e80 	call	91e8 <alt_up_sd_card_open_dev>

  if(sd_card_dev != 0)
    811c:	10001626 	beq	r2,zero,8178 <main+0x98>
    {
        if(alt_up_sd_card_is_Present())
    8120:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    8124:	10001426 	beq	r2,zero,8178 <main+0x98>
        {
            if(alt_up_sd_card_is_FAT16())
    8128:	000a5d40 	call	a5d4 <alt_up_sd_card_is_FAT16>
    812c:	10000326 	beq	r2,zero,813c <main+0x5c>
                printf("Card is FAT16\n");
    8130:	01000074 	movhi	r4,1
    8134:	212c7004 	addi	r4,r4,-20032
    8138:	00000206 	br	8144 <main+0x64>
            else
                printf("Card is not FAT16\n");
    813c:	01000074 	movhi	r4,1
    8140:	212c7404 	addi	r4,r4,-20016
    8144:	000856c0 	call	856c <puts>

            sd_fileh = alt_up_sd_card_fopen("file.txt", true);
    8148:	01000074 	movhi	r4,1
    814c:	01400044 	movi	r5,1
    8150:	212c7904 	addi	r4,r4,-19996
    8154:	000a8d00 	call	a8d0 <alt_up_sd_card_fopen>

            if (sd_fileh < 0)
    8158:	117fffcc 	andi	r5,r2,65535
    815c:	2960001c 	xori	r5,r5,32768
            if(alt_up_sd_card_is_FAT16())
                printf("Card is FAT16\n");
            else
                printf("Card is not FAT16\n");

            sd_fileh = alt_up_sd_card_fopen("file.txt", true);
    8160:	d0a0ee0d 	sth	r2,-31816(gp)

            if (sd_fileh < 0)
    8164:	29600004 	addi	r5,r5,-32768
    8168:	28000c0e 	bge	r5,zero,819c <main+0xbc>
                printf("Problem creating file. Error %i", sd_fileh);
    816c:	01000074 	movhi	r4,1
    8170:	212c7c04 	addi	r4,r4,-19984
    8174:	00084a00 	call	84a0 <printf>

  /* Event loop never exits. */

  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    8178:	04000074 	movhi	r16,1
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
    817c:	04400074 	movhi	r17,1
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
    8180:	04800074 	movhi	r18,1
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    8184:	04c00074 	movhi	r19,1

  /* Event loop never exits. */

  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    8188:	84050004 	addi	r16,r16,5120
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
    818c:	8c450404 	addi	r17,r17,5136
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
    8190:	94850804 	addi	r18,r18,5152
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    8194:	9cc50c04 	addi	r19,r19,5168
    8198:	00002d06 	br	8250 <main+0x170>

            if (sd_fileh < 0)
                printf("Problem creating file. Error %i", sd_fileh);
            else
            {
                printf("SD Accessed Successfully, writing data...");
    819c:	01000074 	movhi	r4,1
    81a0:	212c8404 	addi	r4,r4,-19952
                int index = 0;
                while (buffer[index] != '\0')
    81a4:	04400074 	movhi	r17,1

            if (sd_fileh < 0)
                printf("Problem creating file. Error %i", sd_fileh);
            else
            {
                printf("SD Accessed Successfully, writing data...");
    81a8:	00084a00 	call	84a0 <printf>
                int index = 0;
    81ac:	0021883a 	mov	r16,zero
                while (buffer[index] != '\0')
    81b0:	8c6c9c04 	addi	r17,r17,-19856
    81b4:	8445883a 	add	r2,r16,r17
    81b8:	11400007 	ldb	r5,0(r2)
    81bc:	28000426 	beq	r5,zero,81d0 <main+0xf0>
                {
                    alt_up_sd_card_write(sd_fileh, buffer[index]);
    81c0:	d120ee0f 	ldh	r4,-31816(gp)
                    index = index + 1;
    81c4:	84000044 	addi	r16,r16,1
            {
                printf("SD Accessed Successfully, writing data...");
                int index = 0;
                while (buffer[index] != '\0')
                {
                    alt_up_sd_card_write(sd_fileh, buffer[index]);
    81c8:	000ac640 	call	ac64 <alt_up_sd_card_write>
    81cc:	003ff906 	br	81b4 <_gp+0xffff4be0>
                    index = index + 1;
                }
                printf("Done!\n");
    81d0:	01000074 	movhi	r4,1
    81d4:	212c8f04 	addi	r4,r4,-19908
    81d8:	000856c0 	call	856c <puts>

                printf("Closing File...");
    81dc:	01000074 	movhi	r4,1
    81e0:	212c9104 	addi	r4,r4,-19900
    81e4:	00084a00 	call	84a0 <printf>
                alt_up_sd_card_fclose(sd_fileh);
    81e8:	d120ee0f 	ldh	r4,-31816(gp)
    81ec:	000af0c0 	call	af0c <alt_up_sd_card_fclose>
                printf("Done!\n");
    81f0:	01000074 	movhi	r4,1
    81f4:	212c8f04 	addi	r4,r4,-19908
    81f8:	000856c0 	call	856c <puts>
    81fc:	003fde06 	br	8178 <_gp+0xffff4ba4>

	if(R >= 0 && G >= 0 && B >= 0){
		if (SWITCHES == 1){
			redFilter(&G, &B);
		}
		else if (SWITCHES == 2){
    8200:	00c00084 	movi	r3,2
    8204:	10c01e1e 	bne	r2,r3,8280 <main+0x1a0>
	*B = 0;
	return;
}

void greenFilter(uint *R, uint *B){
	*R = 0;
    8208:	d020ef15 	stw	zero,-31812(gp)
	*B = 0;
    820c:	d020ec15 	stw	zero,-31824(gp)
			blueFilter(&R, &G);
		}
		else if (SWITCHES == 8){
			grayScale(&R, &G, &B);
		}
		IOWR_ALTERA_AVALON_PIO_DATA(RED_BASE, R);
    8210:	d0e0ef17 	ldw	r3,-31812(gp)
    8214:	00800074 	movhi	r2,1
    8218:	10850004 	addi	r2,r2,5120
    821c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(GREEN_BASE, G);
    8220:	d0e0ed17 	ldw	r3,-31820(gp)
    8224:	00800074 	movhi	r2,1
    8228:	10850404 	addi	r2,r2,5136
    822c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(BLUE_BASE, B);
    8230:	d0e0ec17 	ldw	r3,-31824(gp)
    8234:	00800074 	movhi	r2,1
    8238:	10850804 	addi	r2,r2,5152
    823c:	10c00035 	stwio	r3,0(r2)
		IOWR_ALTERA_AVALON_PIO_DATA(SW_BASE, SWITCHES);
    8240:	d0e0eb17 	ldw	r3,-31828(gp)
    8244:	00800074 	movhi	r2,1
    8248:	10850c04 	addi	r2,r2,5168
    824c:	10c00035 	stwio	r3,0(r2)

  /* Event loop never exits. */

  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
    8250:	80800037 	ldwio	r2,0(r16)
    8254:	d0a0ef15 	stw	r2,-31812(gp)
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
    8258:	88800037 	ldwio	r2,0(r17)
    825c:	d0a0ed15 	stw	r2,-31820(gp)
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
    8260:	90800037 	ldwio	r2,0(r18)
    8264:	d0a0ec15 	stw	r2,-31824(gp)
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    8268:	98800037 	ldwio	r2,0(r19)

	if(R >= 0 && G >= 0 && B >= 0){
		if (SWITCHES == 1){
    826c:	00c00044 	movi	r3,1
  while (1)
  {
	R = IORD_ALTERA_AVALON_PIO_DATA(RED_BASE);
	G = IORD_ALTERA_AVALON_PIO_DATA(GREEN_BASE);
	B = IORD_ALTERA_AVALON_PIO_DATA(BLUE_BASE);
	SWITCHES = IORD_ALTERA_AVALON_PIO_DATA(SW_BASE);
    8270:	d0a0eb15 	stw	r2,-31828(gp)

	if(R >= 0 && G >= 0 && B >= 0){
		if (SWITCHES == 1){
    8274:	10ffe21e 	bne	r2,r3,8200 <_gp+0xffff4c2c>

/***
 * FUNCTIONS TO USE
 */
void redFilter(uint *G, uint *B){
	*G = 0;
    8278:	d020ed15 	stw	zero,-31820(gp)
    827c:	003fe306 	br	820c <_gp+0xffff4c38>
			redFilter(&G, &B);
		}
		else if (SWITCHES == 2){
			greenFilter(&R, &B);
		}
		else if (SWITCHES == 4){
    8280:	00c00104 	movi	r3,4
    8284:	10c0031e 	bne	r2,r3,8294 <main+0x1b4>
	*B = 0;
	return;
}

void blueFilter(uint *R, uint *G){
	*R = 0;
    8288:	d020ef15 	stw	zero,-31812(gp)
	*G = 0;
    828c:	d020ed15 	stw	zero,-31820(gp)
    8290:	003fdf06 	br	8210 <_gp+0xffff4c3c>
			greenFilter(&R, &B);
		}
		else if (SWITCHES == 4){
			blueFilter(&R, &G);
		}
		else if (SWITCHES == 8){
    8294:	00c00204 	movi	r3,8
    8298:	10ffdd1e 	bne	r2,r3,8210 <_gp+0xffff4c3c>
			grayScale(&R, &G, &B);
    829c:	d1a0ec04 	addi	r6,gp,-31824
    82a0:	d160ed04 	addi	r5,gp,-31820
    82a4:	d120ef04 	addi	r4,gp,-31812
    82a8:	00080800 	call	8080 <grayScale>
    82ac:	003fd806 	br	8210 <_gp+0xffff4c3c>

000082b0 <__divsi3>:
    82b0:	20001b16 	blt	r4,zero,8320 <__divsi3+0x70>
    82b4:	000f883a 	mov	r7,zero
    82b8:	28001616 	blt	r5,zero,8314 <__divsi3+0x64>
    82bc:	200d883a 	mov	r6,r4
    82c0:	29001a2e 	bgeu	r5,r4,832c <__divsi3+0x7c>
    82c4:	00800804 	movi	r2,32
    82c8:	00c00044 	movi	r3,1
    82cc:	00000106 	br	82d4 <__divsi3+0x24>
    82d0:	10000d26 	beq	r2,zero,8308 <__divsi3+0x58>
    82d4:	294b883a 	add	r5,r5,r5
    82d8:	10bfffc4 	addi	r2,r2,-1
    82dc:	18c7883a 	add	r3,r3,r3
    82e0:	293ffb36 	bltu	r5,r4,82d0 <_gp+0xffff4cfc>
    82e4:	0005883a 	mov	r2,zero
    82e8:	18000726 	beq	r3,zero,8308 <__divsi3+0x58>
    82ec:	0005883a 	mov	r2,zero
    82f0:	31400236 	bltu	r6,r5,82fc <__divsi3+0x4c>
    82f4:	314dc83a 	sub	r6,r6,r5
    82f8:	10c4b03a 	or	r2,r2,r3
    82fc:	1806d07a 	srli	r3,r3,1
    8300:	280ad07a 	srli	r5,r5,1
    8304:	183ffa1e 	bne	r3,zero,82f0 <_gp+0xffff4d1c>
    8308:	38000126 	beq	r7,zero,8310 <__divsi3+0x60>
    830c:	0085c83a 	sub	r2,zero,r2
    8310:	f800283a 	ret
    8314:	014bc83a 	sub	r5,zero,r5
    8318:	39c0005c 	xori	r7,r7,1
    831c:	003fe706 	br	82bc <_gp+0xffff4ce8>
    8320:	0109c83a 	sub	r4,zero,r4
    8324:	01c00044 	movi	r7,1
    8328:	003fe306 	br	82b8 <_gp+0xffff4ce4>
    832c:	00c00044 	movi	r3,1
    8330:	003fee06 	br	82ec <_gp+0xffff4d18>

00008334 <__modsi3>:
    8334:	20001716 	blt	r4,zero,8394 <__modsi3+0x60>
    8338:	000f883a 	mov	r7,zero
    833c:	2005883a 	mov	r2,r4
    8340:	28001216 	blt	r5,zero,838c <__modsi3+0x58>
    8344:	2900162e 	bgeu	r5,r4,83a0 <__modsi3+0x6c>
    8348:	01800804 	movi	r6,32
    834c:	00c00044 	movi	r3,1
    8350:	00000106 	br	8358 <__modsi3+0x24>
    8354:	30000a26 	beq	r6,zero,8380 <__modsi3+0x4c>
    8358:	294b883a 	add	r5,r5,r5
    835c:	31bfffc4 	addi	r6,r6,-1
    8360:	18c7883a 	add	r3,r3,r3
    8364:	293ffb36 	bltu	r5,r4,8354 <_gp+0xffff4d80>
    8368:	18000526 	beq	r3,zero,8380 <__modsi3+0x4c>
    836c:	1806d07a 	srli	r3,r3,1
    8370:	11400136 	bltu	r2,r5,8378 <__modsi3+0x44>
    8374:	1145c83a 	sub	r2,r2,r5
    8378:	280ad07a 	srli	r5,r5,1
    837c:	183ffb1e 	bne	r3,zero,836c <_gp+0xffff4d98>
    8380:	38000126 	beq	r7,zero,8388 <__modsi3+0x54>
    8384:	0085c83a 	sub	r2,zero,r2
    8388:	f800283a 	ret
    838c:	014bc83a 	sub	r5,zero,r5
    8390:	003fec06 	br	8344 <_gp+0xffff4d70>
    8394:	0109c83a 	sub	r4,zero,r4
    8398:	01c00044 	movi	r7,1
    839c:	003fe706 	br	833c <_gp+0xffff4d68>
    83a0:	00c00044 	movi	r3,1
    83a4:	003ff106 	br	836c <_gp+0xffff4d98>

000083a8 <__udivsi3>:
    83a8:	200d883a 	mov	r6,r4
    83ac:	2900152e 	bgeu	r5,r4,8404 <__udivsi3+0x5c>
    83b0:	28001416 	blt	r5,zero,8404 <__udivsi3+0x5c>
    83b4:	00800804 	movi	r2,32
    83b8:	00c00044 	movi	r3,1
    83bc:	00000206 	br	83c8 <__udivsi3+0x20>
    83c0:	10000e26 	beq	r2,zero,83fc <__udivsi3+0x54>
    83c4:	28000516 	blt	r5,zero,83dc <__udivsi3+0x34>
    83c8:	294b883a 	add	r5,r5,r5
    83cc:	10bfffc4 	addi	r2,r2,-1
    83d0:	18c7883a 	add	r3,r3,r3
    83d4:	293ffa36 	bltu	r5,r4,83c0 <_gp+0xffff4dec>
    83d8:	18000826 	beq	r3,zero,83fc <__udivsi3+0x54>
    83dc:	0005883a 	mov	r2,zero
    83e0:	31400236 	bltu	r6,r5,83ec <__udivsi3+0x44>
    83e4:	314dc83a 	sub	r6,r6,r5
    83e8:	10c4b03a 	or	r2,r2,r3
    83ec:	1806d07a 	srli	r3,r3,1
    83f0:	280ad07a 	srli	r5,r5,1
    83f4:	183ffa1e 	bne	r3,zero,83e0 <_gp+0xffff4e0c>
    83f8:	f800283a 	ret
    83fc:	0005883a 	mov	r2,zero
    8400:	f800283a 	ret
    8404:	00c00044 	movi	r3,1
    8408:	003ff406 	br	83dc <_gp+0xffff4e08>

0000840c <__umodsi3>:
    840c:	2005883a 	mov	r2,r4
    8410:	2900122e 	bgeu	r5,r4,845c <__umodsi3+0x50>
    8414:	28001116 	blt	r5,zero,845c <__umodsi3+0x50>
    8418:	01800804 	movi	r6,32
    841c:	00c00044 	movi	r3,1
    8420:	00000206 	br	842c <__umodsi3+0x20>
    8424:	30000c26 	beq	r6,zero,8458 <__umodsi3+0x4c>
    8428:	28000516 	blt	r5,zero,8440 <__umodsi3+0x34>
    842c:	294b883a 	add	r5,r5,r5
    8430:	31bfffc4 	addi	r6,r6,-1
    8434:	18c7883a 	add	r3,r3,r3
    8438:	293ffa36 	bltu	r5,r4,8424 <_gp+0xffff4e50>
    843c:	18000626 	beq	r3,zero,8458 <__umodsi3+0x4c>
    8440:	1806d07a 	srli	r3,r3,1
    8444:	11400136 	bltu	r2,r5,844c <__umodsi3+0x40>
    8448:	1145c83a 	sub	r2,r2,r5
    844c:	280ad07a 	srli	r5,r5,1
    8450:	183ffb1e 	bne	r3,zero,8440 <_gp+0xffff4e6c>
    8454:	f800283a 	ret
    8458:	f800283a 	ret
    845c:	00c00044 	movi	r3,1
    8460:	003ff706 	br	8440 <_gp+0xffff4e6c>

00008464 <_printf_r>:
    8464:	defffd04 	addi	sp,sp,-12
    8468:	dfc00015 	stw	ra,0(sp)
    846c:	d9800115 	stw	r6,4(sp)
    8470:	d9c00215 	stw	r7,8(sp)
    8474:	20c00217 	ldw	r3,8(r4)
    8478:	01800074 	movhi	r6,1
    847c:	31a2d404 	addi	r6,r6,-29872
    8480:	19800115 	stw	r6,4(r3)
    8484:	280d883a 	mov	r6,r5
    8488:	21400217 	ldw	r5,8(r4)
    848c:	d9c00104 	addi	r7,sp,4
    8490:	00086080 	call	8608 <___vfprintf_internal_r>
    8494:	dfc00017 	ldw	ra,0(sp)
    8498:	dec00304 	addi	sp,sp,12
    849c:	f800283a 	ret

000084a0 <printf>:
    84a0:	defffc04 	addi	sp,sp,-16
    84a4:	dfc00015 	stw	ra,0(sp)
    84a8:	d9400115 	stw	r5,4(sp)
    84ac:	d9800215 	stw	r6,8(sp)
    84b0:	d9c00315 	stw	r7,12(sp)
    84b4:	00800074 	movhi	r2,1
    84b8:	10ad7604 	addi	r2,r2,-18984
    84bc:	10800017 	ldw	r2,0(r2)
    84c0:	01400074 	movhi	r5,1
    84c4:	2962d404 	addi	r5,r5,-29872
    84c8:	10c00217 	ldw	r3,8(r2)
    84cc:	d9800104 	addi	r6,sp,4
    84d0:	19400115 	stw	r5,4(r3)
    84d4:	200b883a 	mov	r5,r4
    84d8:	11000217 	ldw	r4,8(r2)
    84dc:	0008b340 	call	8b34 <__vfprintf_internal>
    84e0:	dfc00017 	ldw	ra,0(sp)
    84e4:	dec00404 	addi	sp,sp,16
    84e8:	f800283a 	ret

000084ec <_puts_r>:
    84ec:	defffd04 	addi	sp,sp,-12
    84f0:	dc000015 	stw	r16,0(sp)
    84f4:	2021883a 	mov	r16,r4
    84f8:	2809883a 	mov	r4,r5
    84fc:	dfc00215 	stw	ra,8(sp)
    8500:	dc400115 	stw	r17,4(sp)
    8504:	2823883a 	mov	r17,r5
    8508:	00085800 	call	8580 <strlen>
    850c:	81400217 	ldw	r5,8(r16)
    8510:	01000074 	movhi	r4,1
    8514:	2122d404 	addi	r4,r4,-29872
    8518:	29000115 	stw	r4,4(r5)
    851c:	100f883a 	mov	r7,r2
    8520:	880d883a 	mov	r6,r17
    8524:	8009883a 	mov	r4,r16
    8528:	0008b500 	call	8b50 <__sfvwrite_small_dev>
    852c:	00ffffc4 	movi	r3,-1
    8530:	10c00926 	beq	r2,r3,8558 <_puts_r+0x6c>
    8534:	81400217 	ldw	r5,8(r16)
    8538:	01800074 	movhi	r6,1
    853c:	01c00044 	movi	r7,1
    8540:	28800117 	ldw	r2,4(r5)
    8544:	31ac9504 	addi	r6,r6,-19884
    8548:	8009883a 	mov	r4,r16
    854c:	103ee83a 	callr	r2
    8550:	10bfffe0 	cmpeqi	r2,r2,-1
    8554:	0085c83a 	sub	r2,zero,r2
    8558:	dfc00217 	ldw	ra,8(sp)
    855c:	dc400117 	ldw	r17,4(sp)
    8560:	dc000017 	ldw	r16,0(sp)
    8564:	dec00304 	addi	sp,sp,12
    8568:	f800283a 	ret

0000856c <puts>:
    856c:	00800074 	movhi	r2,1
    8570:	10ad7604 	addi	r2,r2,-18984
    8574:	200b883a 	mov	r5,r4
    8578:	11000017 	ldw	r4,0(r2)
    857c:	00084ec1 	jmpi	84ec <_puts_r>

00008580 <strlen>:
    8580:	2005883a 	mov	r2,r4
    8584:	10c00007 	ldb	r3,0(r2)
    8588:	18000226 	beq	r3,zero,8594 <strlen+0x14>
    858c:	10800044 	addi	r2,r2,1
    8590:	003ffc06 	br	8584 <_gp+0xffff4fb0>
    8594:	1105c83a 	sub	r2,r2,r4
    8598:	f800283a 	ret

0000859c <print_repeat>:
    859c:	defffb04 	addi	sp,sp,-20
    85a0:	dc800315 	stw	r18,12(sp)
    85a4:	dc400215 	stw	r17,8(sp)
    85a8:	dc000115 	stw	r16,4(sp)
    85ac:	dfc00415 	stw	ra,16(sp)
    85b0:	2025883a 	mov	r18,r4
    85b4:	2823883a 	mov	r17,r5
    85b8:	d9800005 	stb	r6,0(sp)
    85bc:	3821883a 	mov	r16,r7
    85c0:	04000a0e 	bge	zero,r16,85ec <print_repeat+0x50>
    85c4:	88800117 	ldw	r2,4(r17)
    85c8:	01c00044 	movi	r7,1
    85cc:	d80d883a 	mov	r6,sp
    85d0:	880b883a 	mov	r5,r17
    85d4:	9009883a 	mov	r4,r18
    85d8:	103ee83a 	callr	r2
    85dc:	843fffc4 	addi	r16,r16,-1
    85e0:	103ff726 	beq	r2,zero,85c0 <_gp+0xffff4fec>
    85e4:	00bfffc4 	movi	r2,-1
    85e8:	00000106 	br	85f0 <print_repeat+0x54>
    85ec:	0005883a 	mov	r2,zero
    85f0:	dfc00417 	ldw	ra,16(sp)
    85f4:	dc800317 	ldw	r18,12(sp)
    85f8:	dc400217 	ldw	r17,8(sp)
    85fc:	dc000117 	ldw	r16,4(sp)
    8600:	dec00504 	addi	sp,sp,20
    8604:	f800283a 	ret

00008608 <___vfprintf_internal_r>:
    8608:	deffe504 	addi	sp,sp,-108
    860c:	d8c00804 	addi	r3,sp,32
    8610:	ddc01815 	stw	r23,96(sp)
    8614:	dd801715 	stw	r22,92(sp)
    8618:	dd401615 	stw	r21,88(sp)
    861c:	dd001515 	stw	r20,84(sp)
    8620:	dcc01415 	stw	r19,80(sp)
    8624:	dc801315 	stw	r18,76(sp)
    8628:	dc401215 	stw	r17,72(sp)
    862c:	dc001115 	stw	r16,68(sp)
    8630:	dfc01a15 	stw	ra,104(sp)
    8634:	df001915 	stw	fp,100(sp)
    8638:	2029883a 	mov	r20,r4
    863c:	2823883a 	mov	r17,r5
    8640:	382d883a 	mov	r22,r7
    8644:	d9800f15 	stw	r6,60(sp)
    8648:	0021883a 	mov	r16,zero
    864c:	d8000e15 	stw	zero,56(sp)
    8650:	d8000a15 	stw	zero,40(sp)
    8654:	002b883a 	mov	r21,zero
    8658:	0027883a 	mov	r19,zero
    865c:	0025883a 	mov	r18,zero
    8660:	d8000c15 	stw	zero,48(sp)
    8664:	d8000b15 	stw	zero,44(sp)
    8668:	002f883a 	mov	r23,zero
    866c:	d8c00915 	stw	r3,36(sp)
    8670:	d8c00f17 	ldw	r3,60(sp)
    8674:	19000003 	ldbu	r4,0(r3)
    8678:	20803fcc 	andi	r2,r4,255
    867c:	1080201c 	xori	r2,r2,128
    8680:	10bfe004 	addi	r2,r2,-128
    8684:	10011e26 	beq	r2,zero,8b00 <___vfprintf_internal_r+0x4f8>
    8688:	00c00044 	movi	r3,1
    868c:	b8c01426 	beq	r23,r3,86e0 <___vfprintf_internal_r+0xd8>
    8690:	1dc00216 	blt	r3,r23,869c <___vfprintf_internal_r+0x94>
    8694:	b8000626 	beq	r23,zero,86b0 <___vfprintf_internal_r+0xa8>
    8698:	00011506 	br	8af0 <___vfprintf_internal_r+0x4e8>
    869c:	01400084 	movi	r5,2
    86a0:	b9401d26 	beq	r23,r5,8718 <___vfprintf_internal_r+0x110>
    86a4:	014000c4 	movi	r5,3
    86a8:	b9402b26 	beq	r23,r5,8758 <___vfprintf_internal_r+0x150>
    86ac:	00011006 	br	8af0 <___vfprintf_internal_r+0x4e8>
    86b0:	01400944 	movi	r5,37
    86b4:	1140fc26 	beq	r2,r5,8aa8 <___vfprintf_internal_r+0x4a0>
    86b8:	88800117 	ldw	r2,4(r17)
    86bc:	d9000005 	stb	r4,0(sp)
    86c0:	01c00044 	movi	r7,1
    86c4:	d80d883a 	mov	r6,sp
    86c8:	880b883a 	mov	r5,r17
    86cc:	a009883a 	mov	r4,r20
    86d0:	103ee83a 	callr	r2
    86d4:	1000d81e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    86d8:	84000044 	addi	r16,r16,1
    86dc:	00010406 	br	8af0 <___vfprintf_internal_r+0x4e8>
    86e0:	01400c04 	movi	r5,48
    86e4:	1140fa26 	beq	r2,r5,8ad0 <___vfprintf_internal_r+0x4c8>
    86e8:	01400944 	movi	r5,37
    86ec:	11400a1e 	bne	r2,r5,8718 <___vfprintf_internal_r+0x110>
    86f0:	d8800005 	stb	r2,0(sp)
    86f4:	88800117 	ldw	r2,4(r17)
    86f8:	b80f883a 	mov	r7,r23
    86fc:	d80d883a 	mov	r6,sp
    8700:	880b883a 	mov	r5,r17
    8704:	a009883a 	mov	r4,r20
    8708:	103ee83a 	callr	r2
    870c:	1000ca1e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8710:	84000044 	addi	r16,r16,1
    8714:	0000f506 	br	8aec <___vfprintf_internal_r+0x4e4>
    8718:	25fff404 	addi	r23,r4,-48
    871c:	bdc03fcc 	andi	r23,r23,255
    8720:	00c00244 	movi	r3,9
    8724:	1dc00936 	bltu	r3,r23,874c <___vfprintf_internal_r+0x144>
    8728:	00bfffc4 	movi	r2,-1
    872c:	90800426 	beq	r18,r2,8740 <___vfprintf_internal_r+0x138>
    8730:	01400284 	movi	r5,10
    8734:	9009883a 	mov	r4,r18
    8738:	0008c600 	call	8c60 <__mulsi3>
    873c:	00000106 	br	8744 <___vfprintf_internal_r+0x13c>
    8740:	0005883a 	mov	r2,zero
    8744:	b8a5883a 	add	r18,r23,r2
    8748:	0000e206 	br	8ad4 <___vfprintf_internal_r+0x4cc>
    874c:	01400b84 	movi	r5,46
    8750:	1140e426 	beq	r2,r5,8ae4 <___vfprintf_internal_r+0x4dc>
    8754:	05c00084 	movi	r23,2
    8758:	213ff404 	addi	r4,r4,-48
    875c:	27003fcc 	andi	fp,r4,255
    8760:	00c00244 	movi	r3,9
    8764:	1f000936 	bltu	r3,fp,878c <___vfprintf_internal_r+0x184>
    8768:	00bfffc4 	movi	r2,-1
    876c:	98800426 	beq	r19,r2,8780 <___vfprintf_internal_r+0x178>
    8770:	01400284 	movi	r5,10
    8774:	9809883a 	mov	r4,r19
    8778:	0008c600 	call	8c60 <__mulsi3>
    877c:	00000106 	br	8784 <___vfprintf_internal_r+0x17c>
    8780:	0005883a 	mov	r2,zero
    8784:	e0a7883a 	add	r19,fp,r2
    8788:	0000d906 	br	8af0 <___vfprintf_internal_r+0x4e8>
    878c:	00c01b04 	movi	r3,108
    8790:	10c0d226 	beq	r2,r3,8adc <___vfprintf_internal_r+0x4d4>
    8794:	013fffc4 	movi	r4,-1
    8798:	99000226 	beq	r19,r4,87a4 <___vfprintf_internal_r+0x19c>
    879c:	d8000b15 	stw	zero,44(sp)
    87a0:	00000106 	br	87a8 <___vfprintf_internal_r+0x1a0>
    87a4:	04c00044 	movi	r19,1
    87a8:	01001a44 	movi	r4,105
    87ac:	11001626 	beq	r2,r4,8808 <___vfprintf_internal_r+0x200>
    87b0:	20800916 	blt	r4,r2,87d8 <___vfprintf_internal_r+0x1d0>
    87b4:	010018c4 	movi	r4,99
    87b8:	11008826 	beq	r2,r4,89dc <___vfprintf_internal_r+0x3d4>
    87bc:	01001904 	movi	r4,100
    87c0:	11001126 	beq	r2,r4,8808 <___vfprintf_internal_r+0x200>
    87c4:	01001604 	movi	r4,88
    87c8:	1100c81e 	bne	r2,r4,8aec <___vfprintf_internal_r+0x4e4>
    87cc:	00c00044 	movi	r3,1
    87d0:	d8c00e15 	stw	r3,56(sp)
    87d4:	00001506 	br	882c <___vfprintf_internal_r+0x224>
    87d8:	01001cc4 	movi	r4,115
    87dc:	11009826 	beq	r2,r4,8a40 <___vfprintf_internal_r+0x438>
    87e0:	20800416 	blt	r4,r2,87f4 <___vfprintf_internal_r+0x1ec>
    87e4:	01001bc4 	movi	r4,111
    87e8:	1100c01e 	bne	r2,r4,8aec <___vfprintf_internal_r+0x4e4>
    87ec:	05400204 	movi	r21,8
    87f0:	00000f06 	br	8830 <___vfprintf_internal_r+0x228>
    87f4:	01001d44 	movi	r4,117
    87f8:	11000d26 	beq	r2,r4,8830 <___vfprintf_internal_r+0x228>
    87fc:	01001e04 	movi	r4,120
    8800:	11000a26 	beq	r2,r4,882c <___vfprintf_internal_r+0x224>
    8804:	0000b906 	br	8aec <___vfprintf_internal_r+0x4e4>
    8808:	d8c00a17 	ldw	r3,40(sp)
    880c:	b7000104 	addi	fp,r22,4
    8810:	18000726 	beq	r3,zero,8830 <___vfprintf_internal_r+0x228>
    8814:	df000d15 	stw	fp,52(sp)
    8818:	b5c00017 	ldw	r23,0(r22)
    881c:	b800080e 	bge	r23,zero,8840 <___vfprintf_internal_r+0x238>
    8820:	05efc83a 	sub	r23,zero,r23
    8824:	02400044 	movi	r9,1
    8828:	00000606 	br	8844 <___vfprintf_internal_r+0x23c>
    882c:	05400404 	movi	r21,16
    8830:	b0c00104 	addi	r3,r22,4
    8834:	d8c00d15 	stw	r3,52(sp)
    8838:	b5c00017 	ldw	r23,0(r22)
    883c:	d8000a15 	stw	zero,40(sp)
    8840:	0013883a 	mov	r9,zero
    8844:	d839883a 	mov	fp,sp
    8848:	b8001726 	beq	r23,zero,88a8 <___vfprintf_internal_r+0x2a0>
    884c:	a80b883a 	mov	r5,r21
    8850:	b809883a 	mov	r4,r23
    8854:	da401015 	stw	r9,64(sp)
    8858:	00083a80 	call	83a8 <__udivsi3>
    885c:	a80b883a 	mov	r5,r21
    8860:	1009883a 	mov	r4,r2
    8864:	102d883a 	mov	r22,r2
    8868:	0008c600 	call	8c60 <__mulsi3>
    886c:	b885c83a 	sub	r2,r23,r2
    8870:	00c00244 	movi	r3,9
    8874:	da401017 	ldw	r9,64(sp)
    8878:	18800216 	blt	r3,r2,8884 <___vfprintf_internal_r+0x27c>
    887c:	10800c04 	addi	r2,r2,48
    8880:	00000506 	br	8898 <___vfprintf_internal_r+0x290>
    8884:	d8c00e17 	ldw	r3,56(sp)
    8888:	18000226 	beq	r3,zero,8894 <___vfprintf_internal_r+0x28c>
    888c:	10800dc4 	addi	r2,r2,55
    8890:	00000106 	br	8898 <___vfprintf_internal_r+0x290>
    8894:	108015c4 	addi	r2,r2,87
    8898:	e0800005 	stb	r2,0(fp)
    889c:	b02f883a 	mov	r23,r22
    88a0:	e7000044 	addi	fp,fp,1
    88a4:	003fe806 	br	8848 <_gp+0xffff5274>
    88a8:	e6efc83a 	sub	r23,fp,sp
    88ac:	9dc5c83a 	sub	r2,r19,r23
    88b0:	0080090e 	bge	zero,r2,88d8 <___vfprintf_internal_r+0x2d0>
    88b4:	e085883a 	add	r2,fp,r2
    88b8:	01400c04 	movi	r5,48
    88bc:	d8c00917 	ldw	r3,36(sp)
    88c0:	e009883a 	mov	r4,fp
    88c4:	e0c0032e 	bgeu	fp,r3,88d4 <___vfprintf_internal_r+0x2cc>
    88c8:	e7000044 	addi	fp,fp,1
    88cc:	21400005 	stb	r5,0(r4)
    88d0:	e0bffa1e 	bne	fp,r2,88bc <_gp+0xffff52e8>
    88d4:	e6efc83a 	sub	r23,fp,sp
    88d8:	d8c00b17 	ldw	r3,44(sp)
    88dc:	4dd1883a 	add	r8,r9,r23
    88e0:	922dc83a 	sub	r22,r18,r8
    88e4:	18001626 	beq	r3,zero,8940 <___vfprintf_internal_r+0x338>
    88e8:	48000a26 	beq	r9,zero,8914 <___vfprintf_internal_r+0x30c>
    88ec:	00800b44 	movi	r2,45
    88f0:	d8800805 	stb	r2,32(sp)
    88f4:	88800117 	ldw	r2,4(r17)
    88f8:	01c00044 	movi	r7,1
    88fc:	d9800804 	addi	r6,sp,32
    8900:	880b883a 	mov	r5,r17
    8904:	a009883a 	mov	r4,r20
    8908:	103ee83a 	callr	r2
    890c:	10004a1e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8910:	84000044 	addi	r16,r16,1
    8914:	0580070e 	bge	zero,r22,8934 <___vfprintf_internal_r+0x32c>
    8918:	b00f883a 	mov	r7,r22
    891c:	01800c04 	movi	r6,48
    8920:	880b883a 	mov	r5,r17
    8924:	a009883a 	mov	r4,r20
    8928:	000859c0 	call	859c <print_repeat>
    892c:	1000421e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8930:	85a1883a 	add	r16,r16,r22
    8934:	e02d883a 	mov	r22,fp
    8938:	bf2fc83a 	sub	r23,r23,fp
    893c:	00002006 	br	89c0 <___vfprintf_internal_r+0x3b8>
    8940:	0580090e 	bge	zero,r22,8968 <___vfprintf_internal_r+0x360>
    8944:	b00f883a 	mov	r7,r22
    8948:	01800804 	movi	r6,32
    894c:	880b883a 	mov	r5,r17
    8950:	a009883a 	mov	r4,r20
    8954:	da401015 	stw	r9,64(sp)
    8958:	000859c0 	call	859c <print_repeat>
    895c:	da401017 	ldw	r9,64(sp)
    8960:	1000351e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8964:	85a1883a 	add	r16,r16,r22
    8968:	483ff226 	beq	r9,zero,8934 <_gp+0xffff5360>
    896c:	00800b44 	movi	r2,45
    8970:	d8800805 	stb	r2,32(sp)
    8974:	88800117 	ldw	r2,4(r17)
    8978:	01c00044 	movi	r7,1
    897c:	d9800804 	addi	r6,sp,32
    8980:	880b883a 	mov	r5,r17
    8984:	a009883a 	mov	r4,r20
    8988:	103ee83a 	callr	r2
    898c:	10002a1e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8990:	84000044 	addi	r16,r16,1
    8994:	003fe706 	br	8934 <_gp+0xffff5360>
    8998:	b5bfffc4 	addi	r22,r22,-1
    899c:	b0800003 	ldbu	r2,0(r22)
    89a0:	01c00044 	movi	r7,1
    89a4:	d9800804 	addi	r6,sp,32
    89a8:	d8800805 	stb	r2,32(sp)
    89ac:	88800117 	ldw	r2,4(r17)
    89b0:	880b883a 	mov	r5,r17
    89b4:	a009883a 	mov	r4,r20
    89b8:	103ee83a 	callr	r2
    89bc:	10001e1e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    89c0:	8585c83a 	sub	r2,r16,r22
    89c4:	b5c9883a 	add	r4,r22,r23
    89c8:	e085883a 	add	r2,fp,r2
    89cc:	013ff216 	blt	zero,r4,8998 <_gp+0xffff53c4>
    89d0:	1021883a 	mov	r16,r2
    89d4:	dd800d17 	ldw	r22,52(sp)
    89d8:	00004406 	br	8aec <___vfprintf_internal_r+0x4e4>
    89dc:	00800044 	movi	r2,1
    89e0:	1480080e 	bge	r2,r18,8a04 <___vfprintf_internal_r+0x3fc>
    89e4:	95ffffc4 	addi	r23,r18,-1
    89e8:	b80f883a 	mov	r7,r23
    89ec:	01800804 	movi	r6,32
    89f0:	880b883a 	mov	r5,r17
    89f4:	a009883a 	mov	r4,r20
    89f8:	000859c0 	call	859c <print_repeat>
    89fc:	10000e1e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8a00:	85e1883a 	add	r16,r16,r23
    8a04:	b0800017 	ldw	r2,0(r22)
    8a08:	01c00044 	movi	r7,1
    8a0c:	d80d883a 	mov	r6,sp
    8a10:	d8800005 	stb	r2,0(sp)
    8a14:	88800117 	ldw	r2,4(r17)
    8a18:	880b883a 	mov	r5,r17
    8a1c:	a009883a 	mov	r4,r20
    8a20:	b5c00104 	addi	r23,r22,4
    8a24:	103ee83a 	callr	r2
    8a28:	1000031e 	bne	r2,zero,8a38 <___vfprintf_internal_r+0x430>
    8a2c:	84000044 	addi	r16,r16,1
    8a30:	b82d883a 	mov	r22,r23
    8a34:	00002d06 	br	8aec <___vfprintf_internal_r+0x4e4>
    8a38:	00bfffc4 	movi	r2,-1
    8a3c:	00003106 	br	8b04 <___vfprintf_internal_r+0x4fc>
    8a40:	b5c00017 	ldw	r23,0(r22)
    8a44:	b7000104 	addi	fp,r22,4
    8a48:	b809883a 	mov	r4,r23
    8a4c:	00085800 	call	8580 <strlen>
    8a50:	9091c83a 	sub	r8,r18,r2
    8a54:	102d883a 	mov	r22,r2
    8a58:	0200090e 	bge	zero,r8,8a80 <___vfprintf_internal_r+0x478>
    8a5c:	400f883a 	mov	r7,r8
    8a60:	01800804 	movi	r6,32
    8a64:	880b883a 	mov	r5,r17
    8a68:	a009883a 	mov	r4,r20
    8a6c:	da001015 	stw	r8,64(sp)
    8a70:	000859c0 	call	859c <print_repeat>
    8a74:	da001017 	ldw	r8,64(sp)
    8a78:	103fef1e 	bne	r2,zero,8a38 <_gp+0xffff5464>
    8a7c:	8221883a 	add	r16,r16,r8
    8a80:	88800117 	ldw	r2,4(r17)
    8a84:	b00f883a 	mov	r7,r22
    8a88:	b80d883a 	mov	r6,r23
    8a8c:	880b883a 	mov	r5,r17
    8a90:	a009883a 	mov	r4,r20
    8a94:	103ee83a 	callr	r2
    8a98:	103fe71e 	bne	r2,zero,8a38 <_gp+0xffff5464>
    8a9c:	85a1883a 	add	r16,r16,r22
    8aa0:	e02d883a 	mov	r22,fp
    8aa4:	00001106 	br	8aec <___vfprintf_internal_r+0x4e4>
    8aa8:	00c00044 	movi	r3,1
    8aac:	04ffffc4 	movi	r19,-1
    8ab0:	d8000e15 	stw	zero,56(sp)
    8ab4:	d8c00a15 	stw	r3,40(sp)
    8ab8:	05400284 	movi	r21,10
    8abc:	9825883a 	mov	r18,r19
    8ac0:	d8000c15 	stw	zero,48(sp)
    8ac4:	d8000b15 	stw	zero,44(sp)
    8ac8:	182f883a 	mov	r23,r3
    8acc:	00000806 	br	8af0 <___vfprintf_internal_r+0x4e8>
    8ad0:	ddc00b15 	stw	r23,44(sp)
    8ad4:	05c00084 	movi	r23,2
    8ad8:	00000506 	br	8af0 <___vfprintf_internal_r+0x4e8>
    8adc:	00c00044 	movi	r3,1
    8ae0:	d8c00c15 	stw	r3,48(sp)
    8ae4:	05c000c4 	movi	r23,3
    8ae8:	00000106 	br	8af0 <___vfprintf_internal_r+0x4e8>
    8aec:	002f883a 	mov	r23,zero
    8af0:	d8c00f17 	ldw	r3,60(sp)
    8af4:	18c00044 	addi	r3,r3,1
    8af8:	d8c00f15 	stw	r3,60(sp)
    8afc:	003edc06 	br	8670 <_gp+0xffff509c>
    8b00:	8005883a 	mov	r2,r16
    8b04:	dfc01a17 	ldw	ra,104(sp)
    8b08:	df001917 	ldw	fp,100(sp)
    8b0c:	ddc01817 	ldw	r23,96(sp)
    8b10:	dd801717 	ldw	r22,92(sp)
    8b14:	dd401617 	ldw	r21,88(sp)
    8b18:	dd001517 	ldw	r20,84(sp)
    8b1c:	dcc01417 	ldw	r19,80(sp)
    8b20:	dc801317 	ldw	r18,76(sp)
    8b24:	dc401217 	ldw	r17,72(sp)
    8b28:	dc001117 	ldw	r16,68(sp)
    8b2c:	dec01b04 	addi	sp,sp,108
    8b30:	f800283a 	ret

00008b34 <__vfprintf_internal>:
    8b34:	00800074 	movhi	r2,1
    8b38:	10ad7604 	addi	r2,r2,-18984
    8b3c:	300f883a 	mov	r7,r6
    8b40:	280d883a 	mov	r6,r5
    8b44:	200b883a 	mov	r5,r4
    8b48:	11000017 	ldw	r4,0(r2)
    8b4c:	00086081 	jmpi	8608 <___vfprintf_internal_r>

00008b50 <__sfvwrite_small_dev>:
    8b50:	2880000b 	ldhu	r2,0(r5)
    8b54:	1080020c 	andi	r2,r2,8
    8b58:	10002126 	beq	r2,zero,8be0 <__sfvwrite_small_dev+0x90>
    8b5c:	2880008f 	ldh	r2,2(r5)
    8b60:	defffa04 	addi	sp,sp,-24
    8b64:	dc000015 	stw	r16,0(sp)
    8b68:	dfc00515 	stw	ra,20(sp)
    8b6c:	dd000415 	stw	r20,16(sp)
    8b70:	dcc00315 	stw	r19,12(sp)
    8b74:	dc800215 	stw	r18,8(sp)
    8b78:	dc400115 	stw	r17,4(sp)
    8b7c:	2821883a 	mov	r16,r5
    8b80:	10001216 	blt	r2,zero,8bcc <__sfvwrite_small_dev+0x7c>
    8b84:	2027883a 	mov	r19,r4
    8b88:	3025883a 	mov	r18,r6
    8b8c:	3823883a 	mov	r17,r7
    8b90:	05010004 	movi	r20,1024
    8b94:	04400b0e 	bge	zero,r17,8bc4 <__sfvwrite_small_dev+0x74>
    8b98:	880f883a 	mov	r7,r17
    8b9c:	a440010e 	bge	r20,r17,8ba4 <__sfvwrite_small_dev+0x54>
    8ba0:	01c10004 	movi	r7,1024
    8ba4:	8140008f 	ldh	r5,2(r16)
    8ba8:	900d883a 	mov	r6,r18
    8bac:	9809883a 	mov	r4,r19
    8bb0:	0008c080 	call	8c08 <_write_r>
    8bb4:	0080050e 	bge	zero,r2,8bcc <__sfvwrite_small_dev+0x7c>
    8bb8:	88a3c83a 	sub	r17,r17,r2
    8bbc:	90a5883a 	add	r18,r18,r2
    8bc0:	003ff406 	br	8b94 <_gp+0xffff55c0>
    8bc4:	0005883a 	mov	r2,zero
    8bc8:	00000706 	br	8be8 <__sfvwrite_small_dev+0x98>
    8bcc:	8080000b 	ldhu	r2,0(r16)
    8bd0:	10801014 	ori	r2,r2,64
    8bd4:	8080000d 	sth	r2,0(r16)
    8bd8:	00bfffc4 	movi	r2,-1
    8bdc:	00000206 	br	8be8 <__sfvwrite_small_dev+0x98>
    8be0:	00bfffc4 	movi	r2,-1
    8be4:	f800283a 	ret
    8be8:	dfc00517 	ldw	ra,20(sp)
    8bec:	dd000417 	ldw	r20,16(sp)
    8bf0:	dcc00317 	ldw	r19,12(sp)
    8bf4:	dc800217 	ldw	r18,8(sp)
    8bf8:	dc400117 	ldw	r17,4(sp)
    8bfc:	dc000017 	ldw	r16,0(sp)
    8c00:	dec00604 	addi	sp,sp,24
    8c04:	f800283a 	ret

00008c08 <_write_r>:
    8c08:	defffd04 	addi	sp,sp,-12
    8c0c:	dc000015 	stw	r16,0(sp)
    8c10:	04000074 	movhi	r16,1
    8c14:	dc400115 	stw	r17,4(sp)
    8c18:	842e6504 	addi	r16,r16,-18028
    8c1c:	2023883a 	mov	r17,r4
    8c20:	2809883a 	mov	r4,r5
    8c24:	300b883a 	mov	r5,r6
    8c28:	380d883a 	mov	r6,r7
    8c2c:	dfc00215 	stw	ra,8(sp)
    8c30:	80000015 	stw	zero,0(r16)
    8c34:	0008dcc0 	call	8dcc <write>
    8c38:	00ffffc4 	movi	r3,-1
    8c3c:	10c0031e 	bne	r2,r3,8c4c <_write_r+0x44>
    8c40:	80c00017 	ldw	r3,0(r16)
    8c44:	18000126 	beq	r3,zero,8c4c <_write_r+0x44>
    8c48:	88c00015 	stw	r3,0(r17)
    8c4c:	dfc00217 	ldw	ra,8(sp)
    8c50:	dc400117 	ldw	r17,4(sp)
    8c54:	dc000017 	ldw	r16,0(sp)
    8c58:	dec00304 	addi	sp,sp,12
    8c5c:	f800283a 	ret

00008c60 <__mulsi3>:
    8c60:	0005883a 	mov	r2,zero
    8c64:	20000726 	beq	r4,zero,8c84 <__mulsi3+0x24>
    8c68:	20c0004c 	andi	r3,r4,1
    8c6c:	2008d07a 	srli	r4,r4,1
    8c70:	18000126 	beq	r3,zero,8c78 <__mulsi3+0x18>
    8c74:	1145883a 	add	r2,r2,r5
    8c78:	294b883a 	add	r5,r5,r5
    8c7c:	203ffa1e 	bne	r4,zero,8c68 <_gp+0xffff5694>
    8c80:	f800283a 	ret
    8c84:	f800283a 	ret

00008c88 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
    8c88:	deffff04 	addi	sp,sp,-4
    8c8c:	01000074 	movhi	r4,1
    8c90:	01400074 	movhi	r5,1
    8c94:	dfc00015 	stw	ra,0(sp)
    8c98:	212c9c04 	addi	r4,r4,-19856
    8c9c:	296d7e04 	addi	r5,r5,-18952

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    8ca0:	2140061e 	bne	r4,r5,8cbc <alt_load+0x34>
    8ca4:	01000074 	movhi	r4,1
    8ca8:	01400074 	movhi	r5,1
    8cac:	21200804 	addi	r4,r4,-32736
    8cb0:	29600804 	addi	r5,r5,-32736
    8cb4:	2140121e 	bne	r4,r5,8d00 <alt_load+0x78>
    8cb8:	00000b06 	br	8ce8 <alt_load+0x60>
    8cbc:	00c00074 	movhi	r3,1
    8cc0:	18ed7e04 	addi	r3,r3,-18952
    8cc4:	1907c83a 	sub	r3,r3,r4
    8cc8:	0005883a 	mov	r2,zero
  {
    while( to != end )
    8ccc:	10fff526 	beq	r2,r3,8ca4 <_gp+0xffff56d0>
    {
      *to++ = *from++;
    8cd0:	114f883a 	add	r7,r2,r5
    8cd4:	39c00017 	ldw	r7,0(r7)
    8cd8:	110d883a 	add	r6,r2,r4
    8cdc:	10800104 	addi	r2,r2,4
    8ce0:	31c00015 	stw	r7,0(r6)
    8ce4:	003ff906 	br	8ccc <_gp+0xffff56f8>
    8ce8:	01000074 	movhi	r4,1
    8cec:	01400074 	movhi	r5,1
    8cf0:	212c5a04 	addi	r4,r4,-20120
    8cf4:	296c5a04 	addi	r5,r5,-20120

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    8cf8:	2140101e 	bne	r4,r5,8d3c <alt_load+0xb4>
    8cfc:	00000b06 	br	8d2c <alt_load+0xa4>
    8d00:	00c00074 	movhi	r3,1
    8d04:	18e00804 	addi	r3,r3,-32736
    8d08:	1907c83a 	sub	r3,r3,r4
    8d0c:	0005883a 	mov	r2,zero
  {
    while( to != end )
    8d10:	10fff526 	beq	r2,r3,8ce8 <_gp+0xffff5714>
    {
      *to++ = *from++;
    8d14:	114f883a 	add	r7,r2,r5
    8d18:	39c00017 	ldw	r7,0(r7)
    8d1c:	110d883a 	add	r6,r2,r4
    8d20:	10800104 	addi	r2,r2,4
    8d24:	31c00015 	stw	r7,0(r6)
    8d28:	003ff906 	br	8d10 <_gp+0xffff573c>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
    8d2c:	000b0180 	call	b018 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
    8d30:	dfc00017 	ldw	ra,0(sp)
    8d34:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
    8d38:	000b1041 	jmpi	b104 <alt_icache_flush_all>
    8d3c:	00c00074 	movhi	r3,1
    8d40:	18ec9c04 	addi	r3,r3,-19856
    8d44:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
    8d48:	0005883a 	mov	r2,zero
  {
    while( to != end )
    8d4c:	18bff726 	beq	r3,r2,8d2c <_gp+0xffff5758>
    {
      *to++ = *from++;
    8d50:	114f883a 	add	r7,r2,r5
    8d54:	39c00017 	ldw	r7,0(r7)
    8d58:	110d883a 	add	r6,r2,r4
    8d5c:	10800104 	addi	r2,r2,4
    8d60:	31c00015 	stw	r7,0(r6)
    8d64:	003ff906 	br	8d4c <_gp+0xffff5778>

00008d68 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    8d68:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    8d6c:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
    8d70:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
    8d74:	0008e2c0 	call	8e2c <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
    8d78:	0008e4c0 	call	8e4c <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    8d7c:	d1a0f117 	ldw	r6,-31804(gp)
    8d80:	d160f217 	ldw	r5,-31800(gp)
    8d84:	d120f317 	ldw	r4,-31796(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
    8d88:	dfc00017 	ldw	ra,0(sp)
    8d8c:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
    8d90:	00080e01 	jmpi	80e0 <main>

00008d94 <alt_putstr>:
 * Uses the ALT_DRIVER_WRITE() macro to call directly to driver if available.
 * Otherwise, uses newlib provided fputs() routine.
 */
int 
alt_putstr(const char* str)
{
    8d94:	defffe04 	addi	sp,sp,-8
    8d98:	dc000015 	stw	r16,0(sp)
    8d9c:	dfc00115 	stw	ra,4(sp)
    8da0:	2021883a 	mov	r16,r4
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
    8da4:	00085800 	call	8580 <strlen>
    8da8:	01000074 	movhi	r4,1
    8dac:	000f883a 	mov	r7,zero
    8db0:	100d883a 	mov	r6,r2
    8db4:	800b883a 	mov	r5,r16
    8db8:	212d7704 	addi	r4,r4,-18980
#else
    return fputs(str, stdout);
#endif
#endif
}
    8dbc:	dfc00117 	ldw	ra,4(sp)
    8dc0:	dc000017 	ldw	r16,0(sp)
    8dc4:	dec00204 	addi	sp,sp,8
#ifdef ALT_SEMIHOSTING
    return write(STDOUT_FILENO,str,strlen(str));
#else
#ifdef ALT_USE_DIRECT_DRIVERS
    ALT_DRIVER_WRITE_EXTERNS(ALT_STDOUT_DEV);
    return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, str, strlen(str), 0);
    8dc8:	000afe41 	jmpi	afe4 <altera_avalon_jtag_uart_write>

00008dcc <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
    8dcc:	00800044 	movi	r2,1
    8dd0:	20800226 	beq	r4,r2,8ddc <write+0x10>
    8dd4:	00800084 	movi	r2,2
    8dd8:	2080041e 	bne	r4,r2,8dec <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
    8ddc:	01000074 	movhi	r4,1
    8de0:	000f883a 	mov	r7,zero
    8de4:	212d7704 	addi	r4,r4,-18980
    8de8:	000afe41 	jmpi	afe4 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
    8dec:	d0a00817 	ldw	r2,-32736(gp)
    8df0:	10000926 	beq	r2,zero,8e18 <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
    8df4:	deffff04 	addi	sp,sp,-4
    8df8:	dfc00015 	stw	ra,0(sp)
    8dfc:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
    8e00:	00c01444 	movi	r3,81
    8e04:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
    8e08:	00bfffc4 	movi	r2,-1
    8e0c:	dfc00017 	ldw	ra,0(sp)
    8e10:	dec00104 	addi	sp,sp,4
    8e14:	f800283a 	ret
    8e18:	d0a0f004 	addi	r2,gp,-31808
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
    8e1c:	00c01444 	movi	r3,81
    8e20:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
    8e24:	00bfffc4 	movi	r2,-1
    8e28:	f800283a 	ret

00008e2c <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
    8e2c:	deffff04 	addi	sp,sp,-4
    8e30:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
    8e34:	000b1080 	call	b108 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
    8e38:	00800044 	movi	r2,1
    8e3c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
    8e40:	dfc00017 	ldw	ra,0(sp)
    8e44:	dec00104 	addi	sp,sp,4
    8e48:	f800283a 	ret

00008e4c <alt_sys_init>:

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
    8e4c:	01000074 	movhi	r4,1
    8e50:	d1600404 	addi	r5,gp,-32752
    8e54:	212d5404 	addi	r4,r4,-19120
    8e58:	000b0241 	jmpi	b024 <alt_dev_llist_insert>

00008e5c <filename_to_upper_case>:
}
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
    8e5c:	defffe04 	addi	sp,sp,-8
    8e60:	dc000015 	stw	r16,0(sp)
    8e64:	dfc00115 	stw	ra,4(sp)
    8e68:	2021883a 	mov	r16,r4
    int index;
    int length = strlen(file_name);
    8e6c:	00085800 	call	8580 <strlen>
    
    for (index = 0; index < length; index++)
    8e70:	8007883a 	mov	r3,r16
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
    8e74:	01800644 	movi	r6,25
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
    8e78:	1c09c83a 	sub	r4,r3,r16
    8e7c:	2080080e 	bge	r4,r2,8ea0 <filename_to_upper_case+0x44>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
    8e80:	19000003 	ldbu	r4,0(r3)
    8e84:	217fe7c4 	addi	r5,r4,-97
    8e88:	29403fcc 	andi	r5,r5,255
    8e8c:	31400236 	bltu	r6,r5,8e98 <filename_to_upper_case+0x3c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
    8e90:	213ff804 	addi	r4,r4,-32
    8e94:	19000005 	stb	r4,0(r3)
    8e98:	18c00044 	addi	r3,r3,1
    8e9c:	003ff606 	br	8e78 <_gp+0xffff58a4>
        }
    }
}
    8ea0:	dfc00117 	ldw	ra,4(sp)
    8ea4:	dc000017 	ldw	r16,0(sp)
    8ea8:	dec00204 	addi	sp,sp,8
    8eac:	f800283a 	ret

00008eb0 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
    8eb0:	defffe04 	addi	sp,sp,-8
    8eb4:	dc000015 	stw	r16,0(sp)
    8eb8:	dfc00115 	stw	ra,4(sp)
    8ebc:	2021883a 	mov	r16,r4
    int length = strlen(file_name);
    8ec0:	00085800 	call	8580 <strlen>
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    8ec4:	013fffc4 	movi	r4,-1
bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
    int length = strlen(file_name);
    int index;
    int last_dir_break_position = -1;
    8ec8:	200d883a 	mov	r6,r4
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    8ecc:	0007883a 	mov	r3,zero
    {
        if ((file_name[index] == ' ') ||
    8ed0:	02c00804 	movi	r11,32
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
    8ed4:	01c01704 	movi	r7,92
    8ed8:	02000bc4 	movi	r8,47
    8edc:	03000244 	movi	r12,9
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
        {
            last_period = index;
            last_dir_break_position = index;
        }
        if (file_name[index] == '.')
    8ee0:	02400b84 	movi	r9,46
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
    8ee4:	034000c4 	movi	r13,3
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    8ee8:	1880180e 	bge	r3,r2,8f4c <check_file_name_for_FAT16_compliance+0x9c>
    {
        if ((file_name[index] == ' ') ||
    8eec:	80cb883a 	add	r5,r16,r3
    8ef0:	29400007 	ldb	r5,0(r5)
    8ef4:	2ac01826 	beq	r5,r11,8f58 <check_file_name_for_FAT16_compliance+0xa8>
    8ef8:	1abfffc4 	addi	r10,r3,-1
    8efc:	3280021e 	bne	r6,r10,8f08 <check_file_name_for_FAT16_compliance+0x58>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
    8f00:	29c01526 	beq	r5,r7,8f58 <check_file_name_for_FAT16_compliance+0xa8>
    8f04:	2a001426 	beq	r5,r8,8f58 <check_file_name_for_FAT16_compliance+0xa8>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
    8f08:	1915c83a 	sub	r10,r3,r4
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
    8f0c:	5300021e 	bne	r10,r12,8f18 <check_file_name_for_FAT16_compliance+0x68>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
    8f10:	2a401026 	beq	r5,r9,8f54 <check_file_name_for_FAT16_compliance+0xa4>
    8f14:	00001006 	br	8f58 <check_file_name_for_FAT16_compliance+0xa8>
    8f18:	31000426 	beq	r6,r4,8f2c <check_file_name_for_FAT16_compliance+0x7c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
    8f1c:	6a80030e 	bge	r13,r10,8f2c <check_file_name_for_FAT16_compliance+0x7c>
    8f20:	29c00626 	beq	r5,r7,8f3c <check_file_name_for_FAT16_compliance+0x8c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
    8f24:	2a000526 	beq	r5,r8,8f3c <check_file_name_for_FAT16_compliance+0x8c>
    8f28:	00000b06 	br	8f58 <check_file_name_for_FAT16_compliance+0xa8>
           )
        {
            result = false;
            break;
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
    8f2c:	29c00326 	beq	r5,r7,8f3c <check_file_name_for_FAT16_compliance+0x8c>
    8f30:	2a000226 	beq	r5,r8,8f3c <check_file_name_for_FAT16_compliance+0x8c>
        {
            last_period = index;
            last_dir_break_position = index;
        }
        if (file_name[index] == '.')
    8f34:	2a40031e 	bne	r5,r9,8f44 <check_file_name_for_FAT16_compliance+0x94>
    8f38:	00000106 	br	8f40 <check_file_name_for_FAT16_compliance+0x90>
    8f3c:	180d883a 	mov	r6,r3
    8f40:	1809883a 	mov	r4,r3
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
    8f44:	18c00044 	addi	r3,r3,1
    8f48:	003fe706 	br	8ee8 <_gp+0xffff5914>
{
    int length = strlen(file_name);
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    8f4c:	00c00044 	movi	r3,1
    8f50:	00000206 	br	8f5c <check_file_name_for_FAT16_compliance+0xac>
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
    8f54:	313ffa26 	beq	r6,r4,8f40 <_gp+0xffff596c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
             (file_name[index] != '\\') && (file_name[index] != '/'))
           )
        {
            result = false;
    8f58:	0007883a 	mov	r3,zero
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
    8f5c:	8085883a 	add	r2,r16,r2
    8f60:	10bfffc7 	ldb	r2,-1(r2)
    8f64:	01001704 	movi	r4,92
    8f68:	11000226 	beq	r2,r4,8f74 <check_file_name_for_FAT16_compliance+0xc4>
    8f6c:	01000bc4 	movi	r4,47
    8f70:	1100011e 	bne	r2,r4,8f78 <check_file_name_for_FAT16_compliance+0xc8>
    {
        result = false;
    8f74:	0007883a 	mov	r3,zero
    }
    return result;
}
    8f78:	1805883a 	mov	r2,r3
    8f7c:	dfc00117 	ldw	ra,4(sp)
    8f80:	dc000017 	ldw	r16,0(sp)
    8f84:	dec00204 	addi	sp,sp,8
    8f88:	f800283a 	ret

00008f8c <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
    8f8c:	defffe04 	addi	sp,sp,-8
    8f90:	dc000015 	stw	r16,0(sp)
    8f94:	dfc00115 	stw	ra,4(sp)
    8f98:	2021883a 	mov	r16,r4
    int index = 0;
    int length = strlen(name);
    8f9c:	00085800 	call	8580 <strlen>
    8fa0:	1009883a 	mov	r4,r2
    
    for(index = 0; index < length; index++)
    8fa4:	8007883a 	mov	r3,r16
    {
        if ((name[index] == '\\') || (name[index] == '/'))
    8fa8:	01801704 	movi	r6,92
    8fac:	01c00bc4 	movi	r7,47
    8fb0:	1c05c83a 	sub	r2,r3,r16
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
    8fb4:	1100050e 	bge	r2,r4,8fcc <get_dir_divider_location+0x40>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
    8fb8:	19400007 	ldb	r5,0(r3)
    8fbc:	29800526 	beq	r5,r6,8fd4 <get_dir_divider_location+0x48>
    8fc0:	18c00044 	addi	r3,r3,1
    8fc4:	29fffa1e 	bne	r5,r7,8fb0 <_gp+0xffff59dc>
    8fc8:	00000206 	br	8fd4 <get_dir_divider_location+0x48>
        {
            break;
        }
    }
    
    if (index == length)
    8fcc:	2080011e 	bne	r4,r2,8fd4 <get_dir_divider_location+0x48>
    {
        index = -1;
    8fd0:	00bfffc4 	movi	r2,-1
    }
    
    return index;
}
    8fd4:	dfc00117 	ldw	ra,4(sp)
    8fd8:	dc000017 	ldw	r16,0(sp)
    8fdc:	dec00204 	addi	sp,sp,8
    8fe0:	f800283a 	ret

00008fe4 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    8fe4:	2011883a 	mov	r8,r4
    8fe8:	21c00204 	addi	r7,r4,8
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
    8fec:	02800644 	movi	r10,25
    8ff0:	40800003 	ldbu	r2,0(r8)
    8ff4:	10ffe7c4 	addi	r3,r2,-97
    8ff8:	18c03fcc 	andi	r3,r3,255
    8ffc:	50c00336 	bltu	r10,r3,900c <match_file_record_to_name_ext+0x28>
    9000:	10bff804 	addi	r2,r2,-32
    9004:	10c03fcc 	andi	r3,r2,255
    9008:	00000306 	br	9018 <match_file_record_to_name_ext+0x34>
    900c:	10c03fcc 	andi	r3,r2,255
    9010:	18c0201c 	xori	r3,r3,128
    9014:	18ffe004 	addi	r3,r3,-128
    9018:	28800003 	ldbu	r2,0(r5)
    901c:	127fe7c4 	addi	r9,r2,-97
    9020:	4a403fcc 	andi	r9,r9,255
    9024:	52400336 	bltu	r10,r9,9034 <match_file_record_to_name_ext+0x50>
    9028:	10bff804 	addi	r2,r2,-32
    902c:	10803fcc 	andi	r2,r2,255
    9030:	00000306 	br	9040 <match_file_record_to_name_ext+0x5c>
    9034:	10803fcc 	andi	r2,r2,255
    9038:	1080201c 	xori	r2,r2,128
    903c:	10bfe004 	addi	r2,r2,-128
    9040:	1880051e 	bne	r3,r2,9058 <match_file_record_to_name_ext+0x74>
    9044:	42000044 	addi	r8,r8,1
    9048:	29400044 	addi	r5,r5,1
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
    904c:	3a3fe81e 	bne	r7,r8,8ff0 <_gp+0xffff5a1c>


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
    9050:	00800044 	movi	r2,1
    9054:	00000106 	br	905c <match_file_record_to_name_ext+0x78>

    for (index = 0; index < 8; index++)
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
        {
            match = false;
    9058:	0005883a 	mov	r2,zero
    905c:	210002c4 	addi	r4,r4,11
			break;
        }
    }
    for (index = 0; index < 3; index++)
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
    9060:	02400644 	movi	r9,25
    9064:	38c00003 	ldbu	r3,0(r7)
    9068:	197fe7c4 	addi	r5,r3,-97
    906c:	29403fcc 	andi	r5,r5,255
    9070:	49400336 	bltu	r9,r5,9080 <match_file_record_to_name_ext+0x9c>
    9074:	18fff804 	addi	r3,r3,-32
    9078:	19403fcc 	andi	r5,r3,255
    907c:	00000306 	br	908c <match_file_record_to_name_ext+0xa8>
    9080:	19403fcc 	andi	r5,r3,255
    9084:	2940201c 	xori	r5,r5,128
    9088:	297fe004 	addi	r5,r5,-128
    908c:	30c00003 	ldbu	r3,0(r6)
    9090:	1a3fe7c4 	addi	r8,r3,-97
    9094:	42003fcc 	andi	r8,r8,255
    9098:	4a000336 	bltu	r9,r8,90a8 <match_file_record_to_name_ext+0xc4>
    909c:	18fff804 	addi	r3,r3,-32
    90a0:	18c03fcc 	andi	r3,r3,255
    90a4:	00000306 	br	90b4 <match_file_record_to_name_ext+0xd0>
    90a8:	18c03fcc 	andi	r3,r3,255
    90ac:	18c0201c 	xori	r3,r3,128
    90b0:	18ffe004 	addi	r3,r3,-128
    90b4:	28c0041e 	bne	r5,r3,90c8 <match_file_record_to_name_ext+0xe4>
    90b8:	39c00044 	addi	r7,r7,1
    90bc:	31800044 	addi	r6,r6,1
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
    90c0:	21ffe81e 	bne	r4,r7,9064 <_gp+0xffff5a90>
    90c4:	f800283a 	ret
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
        {
            match = false;
    90c8:	0005883a 	mov	r2,zero
			break;
        }
    }
	return match;
}
    90cc:	f800283a 	ret

000090d0 <convert_filename_to_name_extension>:
    return result;
}

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
    90d0:	2a000204 	addi	r8,r5,8
    int counter;
    int local = 0;
    90d4:	0005883a 	mov	r2,zero
    
    for(counter = 0; counter < 8; counter++)
    {
        if (filename[local] != '.')
    90d8:	02400b84 	movi	r9,46
            name[counter] = filename[local];
            if (filename[local] != 0) local++;
        }
        else
        {
            name[counter] = ' ';
    90dc:	02800804 	movi	r10,32
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
    {
        if (filename[local] != '.')
    90e0:	2087883a 	add	r3,r4,r2
    90e4:	19c00003 	ldbu	r7,0(r3)
    90e8:	3ac03fcc 	andi	r11,r7,255
    90ec:	5ac0201c 	xori	r11,r11,128
    90f0:	5affe004 	addi	r11,r11,-128
    90f4:	5a400526 	beq	r11,r9,910c <convert_filename_to_name_extension+0x3c>
        {
            name[counter] = filename[local];
    90f8:	29c00005 	stb	r7,0(r5)
            if (filename[local] != 0) local++;
    90fc:	18c00007 	ldb	r3,0(r3)
    9100:	18000326 	beq	r3,zero,9110 <convert_filename_to_name_extension+0x40>
    9104:	10800044 	addi	r2,r2,1
    9108:	00000106 	br	9110 <convert_filename_to_name_extension+0x40>
        }
        else
        {
            name[counter] = ' ';
    910c:	2a800005 	stb	r10,0(r5)
    9110:	29400044 	addi	r5,r5,1
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
    9114:	2a3ff21e 	bne	r5,r8,90e0 <_gp+0xffff5b0c>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    9118:	2087883a 	add	r3,r4,r2
    911c:	19400007 	ldb	r5,0(r3)
    9120:	00c00b84 	movi	r3,46
    9124:	28c0011e 	bne	r5,r3,912c <convert_filename_to_name_extension+0x5c>
    9128:	10800044 	addi	r2,r2,1
    912c:	314000c4 	addi	r5,r6,3
            extension[counter] = filename[local];
            local++;
        }
        else
        {
            extension[counter] = ' ';
    9130:	01c00804 	movi	r7,32
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
    {
        if (filename[local] != 0)
    9134:	2087883a 	add	r3,r4,r2
    9138:	18c00003 	ldbu	r3,0(r3)
    913c:	1a003fcc 	andi	r8,r3,255
    9140:	4200201c 	xori	r8,r8,128
    9144:	423fe004 	addi	r8,r8,-128
    9148:	40000326 	beq	r8,zero,9158 <convert_filename_to_name_extension+0x88>
        {
            extension[counter] = filename[local];
    914c:	30c00005 	stb	r3,0(r6)
            local++;
    9150:	10800044 	addi	r2,r2,1
    9154:	00000106 	br	915c <convert_filename_to_name_extension+0x8c>
        }
        else
        {
            extension[counter] = ' ';
    9158:	31c00005 	stb	r7,0(r6)
    915c:	31800044 	addi	r6,r6,1
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
    9160:	29bff41e 	bne	r5,r6,9134 <_gp+0xffff5b60>
        {
            extension[counter] = ' ';
        }
    }

}
    9164:	f800283a 	ret

00009168 <copy_file_record_name_to_string>:
}


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
    9168:	200d883a 	mov	r6,r4
    916c:	20c00204 	addi	r3,r4,8
	int index;
	int flength = 0;
    9170:	0005883a 	mov	r2,zero

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
	{
		if (file_record->name[index] != ' ')
    9174:	02000804 	movi	r8,32
    9178:	31c00003 	ldbu	r7,0(r6)
    917c:	3a403fcc 	andi	r9,r7,255
    9180:	4a000326 	beq	r9,r8,9190 <copy_file_record_name_to_string+0x28>
		{
			file_name[flength] = file_record->name[index];
    9184:	2893883a 	add	r9,r5,r2
    9188:	49c00005 	stb	r7,0(r9)
			flength = flength + 1;
    918c:	10800044 	addi	r2,r2,1
    9190:	31800044 	addi	r6,r6,1
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
    9194:	30fff81e 	bne	r6,r3,9178 <_gp+0xffff5ba4>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
    9198:	21c00203 	ldbu	r7,8(r4)
    919c:	01800804 	movi	r6,32
    91a0:	39800e26 	beq	r7,r6,91dc <copy_file_record_name_to_string+0x74>
	{
		file_name[flength] = '.';
    91a4:	288d883a 	add	r6,r5,r2
    91a8:	01c00b84 	movi	r7,46
    91ac:	31c00005 	stb	r7,0(r6)
		flength = flength + 1;
    91b0:	10800044 	addi	r2,r2,1
    91b4:	210002c4 	addi	r4,r4,11
		for (index = 0; index < 3; index++)
		{
			if (file_record->extension[index] != ' ')
    91b8:	01c00804 	movi	r7,32
    91bc:	19800003 	ldbu	r6,0(r3)
    91c0:	32003fcc 	andi	r8,r6,255
    91c4:	41c00326 	beq	r8,r7,91d4 <copy_file_record_name_to_string+0x6c>
			{
				file_name[flength] = file_record->extension[index];
    91c8:	2891883a 	add	r8,r5,r2
    91cc:	41800005 	stb	r6,0(r8)
				flength = flength + 1;
    91d0:	10800044 	addi	r2,r2,1
    91d4:	18c00044 	addi	r3,r3,1
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
    91d8:	20fff81e 	bne	r4,r3,91bc <_gp+0xffff5be8>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
    91dc:	2885883a 	add	r2,r5,r2
    91e0:	10000005 	stb	zero,0(r2)
    91e4:	f800283a 	ret

000091e8 <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
    91e8:	deffff04 	addi	sp,sp,-4
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
    91ec:	d1600404 	addi	r5,gp,-32752
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
    91f0:	dfc00015 	stw	ra,0(sp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
    91f4:	000b0900 	call	b090 <alt_find_dev>

	if (dev != NULL)
    91f8:	10001226 	beq	r2,zero,9244 <alt_up_sd_card_open_dev+0x5c>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
    91fc:	10c00a17 	ldw	r3,40(r2)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
    9200:	d0a0f615 	stw	r2,-31784(gp)
		initialized = false;
    9204:	d0210015 	stw	zero,-31744(gp)
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);

	if (dev != NULL)
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
    9208:	19008d04 	addi	r4,r3,564
    920c:	d120fe15 	stw	r4,-31752(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
    9210:	19008904 	addi	r4,r3,548
    9214:	d120fd15 	stw	r4,-31756(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
    9218:	19008404 	addi	r4,r3,528
    921c:	d120fc15 	stw	r4,-31760(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
    9220:	19008c04 	addi	r4,r3,560
    9224:	d120fb15 	stw	r4,-31764(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
    9228:	d0e0f915 	stw	r3,-31772(gp)
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
    922c:	19008b04 	addi	r4,r3,556
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
		search_data.valid = false;
    9230:	00c00074 	movhi	r3,1
    9234:	18ee7604 	addi	r3,r3,-17960
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
    9238:	d120fa15 	stw	r4,-31768(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
    923c:	d020ff15 	stw	zero,-31748(gp)
		search_data.valid = false;
    9240:	18000415 	stw	zero,16(r3)
	}
	return dev;
}
    9244:	dfc00017 	ldw	ra,0(sp)
    9248:	dec00104 	addi	sp,sp,4
    924c:	f800283a 	ret

00009250 <alt_up_sd_card_is_Present>:
bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
    9250:	d0e0f617 	ldw	r3,-31784(gp)
    9254:	00800044 	movi	r2,1
    9258:	1800031e 	bne	r3,zero,9268 <alt_up_sd_card_is_Present+0x18>
    {
        result = true;
    }
	else if (initialized == true)
    925c:	d0e10017 	ldw	r3,-31744(gp)
    9260:	1880131e 	bne	r3,r2,92b0 <alt_up_sd_card_is_Present+0x60>
    9264:	00000506 	br	927c <alt_up_sd_card_is_Present+0x2c>
bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
    9268:	d0e0fe17 	ldw	r3,-31752(gp)
    926c:	18c0002b 	ldhuio	r3,0(r3)
    9270:	18c0008c 	andi	r3,r3,2
    9274:	183ff926 	beq	r3,zero,925c <_gp+0xffff5c88>
    9278:	f800283a 	ret
	else if (initialized == true)
	{
		int index;

		initialized = false;
		search_data.valid = false;
    927c:	00800074 	movhi	r2,1
    9280:	10ae7604 	addi	r2,r2,-17960
    9284:	10000415 	stw	zero,16(r2)
    9288:	00800074 	movhi	r2,1
    }
	else if (initialized == true)
	{
		int index;

		initialized = false;
    928c:	d0210015 	stw	zero,-31744(gp)
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;
    9290:	d020ff15 	stw	zero,-31748(gp)
    9294:	10ae9f04 	addi	r2,r2,-17796
    9298:	00c00504 	movi	r3,20

		for(index = 0; index < MAX_FILES_OPENED; index++)
		{
			active_files[index].in_use = false;
    929c:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
    92a0:	103fff15 	stw	zero,-4(r2)
    92a4:	18ffffc4 	addi	r3,r3,-1
    92a8:	10801004 	addi	r2,r2,64

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
    92ac:	183ffb1e 	bne	r3,zero,929c <_gp+0xffff5cc8>


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;
    92b0:	0005883a 	mov	r2,zero
    92b4:	f800283a 	ret

000092b8 <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
    92b8:	defffd04 	addi	sp,sp,-12
    92bc:	dc400115 	stw	r17,4(sp)
    92c0:	dc000015 	stw	r16,0(sp)
    92c4:	dfc00215 	stw	ra,8(sp)
    92c8:	2023883a 	mov	r17,r4
    92cc:	2821883a 	mov	r16,r5
    bool result = false;
    
    if (alt_up_sd_card_is_Present())
    92d0:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    92d4:	1000021e 	bne	r2,zero,92e0 <Write_Sector_Data+0x28>

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
    bool result = false;
    92d8:	0005883a 	mov	r2,zero
    92dc:	00001106 	br	9324 <Write_Sector_Data+0x6c>
    {
        short int reg_state = 0xff;

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
    92e0:	8c09883a 	add	r4,r17,r16
    92e4:	2006927a 	slli	r3,r4,9
    92e8:	d0a0fa17 	ldw	r2,-31768(gp)
    92ec:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
    92f0:	d0a0fb17 	ldw	r2,-31764(gp)
    92f4:	00c00604 	movi	r3,24
    92f8:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
    92fc:	d0a0fe17 	ldw	r2,-31752(gp)
    9300:	1080002b 	ldhuio	r2,0(r2)
    9304:	10bfffcc 	andi	r2,r2,65535
        } while ((reg_state & 0x04)!=0);
    9308:	10c0010c 	andi	r3,r2,4
    930c:	183ffb1e 	bne	r3,zero,92fc <_gp+0xffff5d28>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
    9310:	1080040c 	andi	r2,r2,16
    9314:	103ff01e 	bne	r2,zero,92d8 <_gp+0xffff5d04>
        {
            result = true;
            current_sector_modified = false;
    9318:	d020f515 	stw	zero,-31788(gp)
            current_sector_index = sector_index+partition_offset;
    931c:	d120f415 	stw	r4,-31792(gp)
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
        } while ((reg_state & 0x04)!=0);
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
        {
            result = true;
    9320:	00800044 	movi	r2,1
            current_sector_modified = false;
            current_sector_index = sector_index+partition_offset;
        }
    }
    return result;
}
    9324:	dfc00217 	ldw	ra,8(sp)
    9328:	dc400117 	ldw	r17,4(sp)
    932c:	dc000017 	ldw	r16,0(sp)
    9330:	dec00304 	addi	sp,sp,12
    9334:	f800283a 	ret

00009338 <Save_Modified_Sector>:

bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
    bool result = true;
    if (current_sector_modified)
    9338:	d0a0f517 	ldw	r2,-31788(gp)
    933c:	10000326 	beq	r2,zero,934c <Save_Modified_Sector+0x14>
    {
        result = Write_Sector_Data(current_sector_index, 0);
    9340:	d120f417 	ldw	r4,-31792(gp)
    9344:	000b883a 	mov	r5,zero
    9348:	00092b81 	jmpi	92b8 <Write_Sector_Data>
    }
    return result;
}
    934c:	00800044 	movi	r2,1
    9350:	f800283a 	ret

00009354 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
    9354:	defffd04 	addi	sp,sp,-12
    9358:	dc400115 	stw	r17,4(sp)
    935c:	dc000015 	stw	r16,0(sp)
    9360:	dfc00215 	stw	ra,8(sp)
    9364:	2023883a 	mov	r17,r4
    9368:	2821883a 	mov	r16,r5
	bool result = false;
    
	if (alt_up_sd_card_is_Present())
    936c:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    9370:	1000021e 	bne	r2,zero,937c <Read_Sector_Data+0x28>


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
	bool result = false;
    9374:	0005883a 	mov	r2,zero
    9378:	00001906 	br	93e0 <Read_Sector_Data+0x8c>
	if (alt_up_sd_card_is_Present())
	{
		short int reg_state = 0xff;
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
    937c:	d0a0f517 	ldw	r2,-31788(gp)
    9380:	1000081e 	bne	r2,zero,93a4 <Read_Sector_Data+0x50>
                return false;
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
    9384:	8c09883a 	add	r4,r17,r16
    9388:	2006927a 	slli	r3,r4,9
    938c:	d0a0fa17 	ldw	r2,-31768(gp)
    9390:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
    9394:	d0a0fb17 	ldw	r2,-31764(gp)
    9398:	00c00444 	movi	r3,17
    939c:	10c0002d 	sthio	r3,0(r2)
    93a0:	00000506 	br	93b8 <Read_Sector_Data+0x64>
		short int reg_state = 0xff;
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
    93a4:	d120f417 	ldw	r4,-31792(gp)
    93a8:	000b883a 	mov	r5,zero
    93ac:	00092b80 	call	92b8 <Write_Sector_Data>
    93b0:	103ff41e 	bne	r2,zero,9384 <_gp+0xffff5db0>
    93b4:	003fef06 	br	9374 <_gp+0xffff5da0>
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
    93b8:	d0a0fe17 	ldw	r2,-31752(gp)
    93bc:	1080002b 	ldhuio	r2,0(r2)
    93c0:	10bfffcc 	andi	r2,r2,65535
		} while ((reg_state & 0x04)!=0);
    93c4:	10c0010c 	andi	r3,r2,4
    93c8:	183ffb1e 	bne	r3,zero,93b8 <_gp+0xffff5de4>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
    93cc:	1080040c 	andi	r2,r2,16
    93d0:	103fe81e 	bne	r2,zero,9374 <_gp+0xffff5da0>
		{
			result = true;
            current_sector_modified = false;
    93d4:	d020f515 	stw	zero,-31788(gp)
            current_sector_index = sector_index+partition_offset;
    93d8:	d120f415 	stw	r4,-31792(gp)
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
		} while ((reg_state & 0x04)!=0);
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
		{
			result = true;
    93dc:	00800044 	movi	r2,1
            current_sector_modified = false;
            current_sector_index = sector_index+partition_offset;
		}
	}
	return result;
}
    93e0:	dfc00217 	ldw	ra,8(sp)
    93e4:	dc400117 	ldw	r17,4(sp)
    93e8:	dc000017 	ldw	r16,0(sp)
    93ec:	dec00304 	addi	sp,sp,12
    93f0:	f800283a 	ret

000093f4 <get_cluster_flag>:
bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    93f4:	00800074 	movhi	r2,1
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    93f8:	defffd04 	addi	sp,sp,-12
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    93fc:	10ae7b04 	addi	r2,r2,-17940
    9400:	10801117 	ldw	r2,68(r2)
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9404:	dc000015 	stw	r16,0(sp)
    9408:	2021883a 	mov	r16,r4
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    940c:	d120f817 	ldw	r4,-31776(gp)
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9410:	dc400115 	stw	r17,4(sp)
    9414:	dfc00215 	stw	ra,8(sp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9418:	2089883a 	add	r4,r4,r2
    941c:	8004d23a 	srli	r2,r16,8
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    9420:	2823883a 	mov	r17,r5
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    9424:	2089883a 	add	r4,r4,r2
     
    if (sector_index != current_sector_index)
    9428:	d0a0f417 	ldw	r2,-31792(gp)
    942c:	2080091e 	bne	r4,r2,9454 <get_cluster_flag+0x60>
        if (Read_Sector_Data(sector_index, 0) == false)
        {
            return false;
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
    9430:	d0a0f617 	ldw	r2,-31784(gp)
    9434:	84003fcc 	andi	r16,r16,255
    9438:	8421883a 	add	r16,r16,r16
    943c:	10800a17 	ldw	r2,40(r2)
    9440:	80a1883a 	add	r16,r16,r2
    9444:	8080002b 	ldhuio	r2,0(r16)
    9448:	8880000d 	sth	r2,0(r17)
    return true;
    944c:	00800044 	movi	r2,1
    9450:	00000306 	br	9460 <get_cluster_flag+0x6c>
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
     
    if (sector_index != current_sector_index)
    {
        if (Read_Sector_Data(sector_index, 0) == false)
    9454:	000b883a 	mov	r5,zero
    9458:	00093540 	call	9354 <Read_Sector_Data>
    945c:	103ff41e 	bne	r2,zero,9430 <_gp+0xffff5e5c>
            return false;
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
    return true;
}
    9460:	dfc00217 	ldw	ra,8(sp)
    9464:	dc400117 	ldw	r17,4(sp)
    9468:	dc000017 	ldw	r16,0(sp)
    946c:	dec00304 	addi	sp,sp,12
    9470:	f800283a 	ret

00009474 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9474:	defffd04 	addi	sp,sp,-12
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    9478:	d0a0f817 	ldw	r2,-31776(gp)
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    947c:	dc000015 	stw	r16,0(sp)
    9480:	2021883a 	mov	r16,r4
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    9484:	2008d23a 	srli	r4,r4,8
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9488:	dc400115 	stw	r17,4(sp)
    948c:	dfc00215 	stw	ra,8(sp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    9490:	2089883a 	add	r4,r4,r2
    9494:	00800074 	movhi	r2,1
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
    9498:	2823883a 	mov	r17,r5
    949c:	10ae7b04 	addi	r2,r2,-17940
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    
    if (first_fat)
    94a0:	30000226 	beq	r6,zero,94ac <mark_cluster+0x38>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
    94a4:	10801117 	ldw	r2,68(r2)
    94a8:	00000106 	br	94b0 <mark_cluster+0x3c>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
    94ac:	10801217 	ldw	r2,72(r2)
    94b0:	2089883a 	add	r4,r4,r2
    }
     
    if (sector_index != current_sector_index)
    94b4:	d0a0f417 	ldw	r2,-31792(gp)
    94b8:	2080091e 	bne	r4,r2,94e0 <mark_cluster+0x6c>
        if (Read_Sector_Data(sector_index, 0) == false)
        {
            return false;
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
    94bc:	d0a0f617 	ldw	r2,-31784(gp)
    94c0:	84003fcc 	andi	r16,r16,255
    94c4:	8421883a 	add	r16,r16,r16
    94c8:	10800a17 	ldw	r2,40(r2)
    94cc:	80a1883a 	add	r16,r16,r2
    94d0:	8440002d 	sthio	r17,0(r16)
    current_sector_modified = true;
    94d4:	00800044 	movi	r2,1
    94d8:	d0a0f515 	stw	r2,-31788(gp)
    return true;
    94dc:	00000306 	br	94ec <mark_cluster+0x78>
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
    }
     
    if (sector_index != current_sector_index)
    {
        if (Read_Sector_Data(sector_index, 0) == false)
    94e0:	000b883a 	mov	r5,zero
    94e4:	00093540 	call	9354 <Read_Sector_Data>
    94e8:	103ff41e 	bne	r2,zero,94bc <_gp+0xffff5ee8>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
    current_sector_modified = true;
    return true;
}
    94ec:	dfc00217 	ldw	ra,8(sp)
    94f0:	dc400117 	ldw	r17,4(sp)
    94f4:	dc000017 	ldw	r16,0(sp)
    94f8:	dec00304 	addi	sp,sp,12
    94fc:	f800283a 	ret

00009500 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
    9500:	deffff04 	addi	sp,sp,-4
	bool result = false;
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
    9504:	000b883a 	mov	r5,zero
    9508:	0009883a 	mov	r4,zero

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
    950c:	dfc00015 	stw	ra,0(sp)
	bool result = false;
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
    9510:	00093540 	call	9354 <Read_Sector_Data>
    9514:	1000021e 	bne	r2,zero,9520 <Check_for_Master_Boot_Record+0x20>
bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
	bool result = false;
    9518:	0005883a 	mov	r2,zero
    951c:	00003706 	br	95fc <Check_for_Master_Boot_Record+0xfc>
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
    9520:	d1e0f617 	ldw	r7,-31784(gp)
    9524:	38800a17 	ldw	r2,40(r7)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
    9528:	10807faf 	ldhio	r2,510(r2)
    952c:	00ea9554 	movui	r3,43605
    9530:	10bfffcc 	andi	r2,r2,65535
    9534:	10fff81e 	bne	r2,r3,9518 <_gp+0xffff5f44>
    9538:	00806f84 	movi	r2,446
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
    953c:	02400044 	movi	r9,1
    9540:	02bfff44 	movi	r10,-3
    9544:	02c00104 	movi	r11,4
    9548:	03000384 	movi	r12,14

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
    954c:	02007f84 	movi	r8,510
			{
				int partition_data_offset = (index * 16) + 0x01be;
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
    9550:	38c00a17 	ldw	r3,40(r7)
    9554:	18c00104 	addi	r3,r3,4
    9558:	1887883a 	add	r3,r3,r2
    955c:	18c00023 	ldbuio	r3,0(r3)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
    9560:	19003fcc 	andi	r4,r3,255
    9564:	2100201c 	xori	r4,r4,128
    9568:	213fe004 	addi	r4,r4,-128
    956c:	22400626 	beq	r4,r9,9588 <Check_for_Master_Boot_Record+0x88>
    9570:	50c6703a 	and	r3,r10,r3
    9574:	18c03fcc 	andi	r3,r3,255
    9578:	18c0201c 	xori	r3,r3,128
    957c:	18ffe004 	addi	r3,r3,-128
    9580:	1ac00126 	beq	r3,r11,9588 <Check_for_Master_Boot_Record+0x88>
    9584:	23001a1e 	bne	r4,r12,95f0 <Check_for_Master_Boot_Record+0xf0>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
    9588:	38c00a17 	ldw	r3,40(r7)
    958c:	19000284 	addi	r4,r3,10
    9590:	2089883a 	add	r4,r4,r2
    9594:	2140002b 	ldhuio	r5,0(r4)
    9598:	19000204 	addi	r4,r3,8
    959c:	297fffcc 	andi	r5,r5,65535
    95a0:	2089883a 	add	r4,r4,r2
    95a4:	2100002b 	ldhuio	r4,0(r4)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
    95a8:	19800384 	addi	r6,r3,14

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
    95ac:	213fffcc 	andi	r4,r4,65535
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
    95b0:	308d883a 	add	r6,r6,r2
    95b4:	3180002b 	ldhuio	r6,0(r6)
    95b8:	18c00304 	addi	r3,r3,12
    95bc:	31bfffcc 	andi	r6,r6,65535
    95c0:	1887883a 	add	r3,r3,r2
    95c4:	18c0002b 	ldhuio	r3,0(r3)
    95c8:	300c943a 	slli	r6,r6,16
    95cc:	18ffffcc 	andi	r3,r3,65535
    95d0:	30c6b03a 	or	r3,r6,r3
		            
					// Check if the partition is valid
					if (partition_size > 0)
    95d4:	00c0060e 	bge	zero,r3,95f0 <Check_for_Master_Boot_Record+0xf0>
					{
						result = true;
						fat_partition_size_in_512_byte_sectors = partition_size;
						fat_partition_offset_in_512_byte_sectors = offset;
    95d8:	2804943a 	slli	r2,r5,16
		            
					// Check if the partition is valid
					if (partition_size > 0)
					{
						result = true;
						fat_partition_size_in_512_byte_sectors = partition_size;
    95dc:	d0e0f715 	stw	r3,-31780(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
    95e0:	1104b03a 	or	r2,r2,r4
    95e4:	d0a0f815 	stw	r2,-31776(gp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
		            
					// Check if the partition is valid
					if (partition_size > 0)
					{
						result = true;
    95e8:	00800044 	movi	r2,1
    95ec:	00000306 	br	95fc <Check_for_Master_Boot_Record+0xfc>
    95f0:	10800404 	addi	r2,r2,16

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
    95f4:	123fd61e 	bne	r2,r8,9550 <_gp+0xffff5f7c>
    95f8:	003fc706 	br	9518 <_gp+0xffff5f44>
			}
		}
	}

	return result;
}
    95fc:	dfc00017 	ldw	ra,0(sp)
    9600:	dec00104 	addi	sp,sp,4
    9604:	f800283a 	ret

00009608 <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
    9608:	defffa04 	addi	sp,sp,-24
	bool result = false;
	int counter = 0;
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
    960c:	200b883a 	mov	r5,r4
    9610:	0009883a 	mov	r4,zero
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
    9614:	dcc00315 	stw	r19,12(sp)
    9618:	dfc00515 	stw	ra,20(sp)
    961c:	dd000415 	stw	r20,16(sp)
    9620:	dc800215 	stw	r18,8(sp)
    9624:	dc400115 	stw	r17,4(sp)
    9628:	dc000015 	stw	r16,0(sp)
	bool result = false;
	int counter = 0;
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
    962c:	00093540 	call	9354 <Read_Sector_Data>
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
    9630:	d4e0f617 	ldw	r19,-31784(gp)
    9634:	98c00a17 	ldw	r3,40(r19)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
    9638:	19007faf 	ldhio	r4,510(r3)
    963c:	016a9554 	movui	r5,43605
    9640:	213fffcc 	andi	r4,r4,65535
    9644:	2140921e 	bne	r4,r5,9890 <Check_for_DOS_FAT+0x288>
    9648:	10009226 	beq	r2,zero,9894 <Check_for_DOS_FAT+0x28c>
	{
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
    964c:	18800023 	ldbuio	r2,0(r3)
    9650:	04000074 	movhi	r16,1
    9654:	842e7b04 	addi	r16,r16,-17940
    9658:	80800005 	stb	r2,0(r16)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
    965c:	18800063 	ldbuio	r2,1(r3)
    9660:	80800045 	stb	r2,1(r16)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
    9664:	188000a3 	ldbuio	r2,2(r3)
		for (counter = 0; counter < 8; counter++)
    9668:	0007883a 	mov	r3,zero
	{
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
    966c:	80800085 	stb	r2,2(r16)
    9670:	810000c4 	addi	r4,r16,3
		for (counter = 0; counter < 8; counter++)
    9674:	01400204 	movi	r5,8
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
    9678:	98800a17 	ldw	r2,40(r19)
    967c:	108000c4 	addi	r2,r2,3
    9680:	10c5883a 	add	r2,r2,r3
    9684:	10800023 	ldbuio	r2,0(r2)
    9688:	20800005 	stb	r2,0(r4)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
    968c:	18c00044 	addi	r3,r3,1
    9690:	21000044 	addi	r4,r4,1
    9694:	197ff81e 	bne	r3,r5,9678 <_gp+0xffff60a4>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
    9698:	98800a17 	ldw	r2,40(r19)
    969c:	11000323 	ldbuio	r4,12(r2)
    96a0:	21003fcc 	andi	r4,r4,255
    96a4:	10c002e3 	ldbuio	r3,11(r2)
    96a8:	2008923a 	slli	r4,r4,8
    96ac:	18c03fcc 	andi	r3,r3,255
    96b0:	18c0201c 	xori	r3,r3,128
    96b4:	18ffe004 	addi	r3,r3,-128
    96b8:	20c6b03a 	or	r3,r4,r3
    96bc:	80c0030d 	sth	r3,12(r16)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
    96c0:	10c00363 	ldbuio	r3,13(r2)
    96c4:	80c00385 	stb	r3,14(r16)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
    96c8:	10c003ab 	ldhuio	r3,14(r2)
    96cc:	80c0040d 	sth	r3,16(r16)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
    96d0:	10c00423 	ldbuio	r3,16(r2)
    96d4:	80c00485 	stb	r3,18(r16)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
    96d8:	110004a3 	ldbuio	r4,18(r2)
    96dc:	21003fcc 	andi	r4,r4,255
    96e0:	10c00463 	ldbuio	r3,17(r2)
    96e4:	2008923a 	slli	r4,r4,8
    96e8:	18c03fcc 	andi	r3,r3,255
    96ec:	20c6b03a 	or	r3,r4,r3
    96f0:	80c0050d 	sth	r3,20(r16)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
    96f4:	10c00523 	ldbuio	r3,20(r2)
    96f8:	18c03fcc 	andi	r3,r3,255
    96fc:	148004e3 	ldbuio	r18,19(r2)
    9700:	1806923a 	slli	r3,r3,8
    9704:	94803fcc 	andi	r18,r18,255
    9708:	1ca4b03a 	or	r18,r3,r18
    970c:	8480058d 	sth	r18,22(r16)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
    9710:	10c00563 	ldbuio	r3,21(r2)
    9714:	80c00605 	stb	r3,24(r16)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
    9718:	10c005ab 	ldhuio	r3,22(r2)
    971c:	80c0068d 	sth	r3,26(r16)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
    9720:	10c0062b 	ldhuio	r3,24(r2)
    9724:	80c0070d 	sth	r3,28(r16)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
    9728:	10c006ab 	ldhuio	r3,26(r2)
    972c:	80c0078d 	sth	r3,30(r16)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
    9730:	10c00737 	ldwio	r3,28(r2)
    9734:	80c00815 	stw	r3,32(r16)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
    9738:	15000837 	ldwio	r20,32(r2)
    973c:	85000915 	stw	r20,36(r16)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
    9740:	10800923 	ldbuio	r2,36(r2)
    9744:	80800a05 	stb	r2,40(r16)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
    9748:	98800a17 	ldw	r2,40(r19)
    974c:	10800963 	ldbuio	r2,37(r2)
    9750:	80800a45 	stb	r2,41(r16)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
    9754:	98800a17 	ldw	r2,40(r19)
    9758:	108009a3 	ldbuio	r2,38(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
    975c:	8100050b 	ldhu	r4,20(r16)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
    9760:	80800a85 	stb	r2,42(r16)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
    9764:	8440068b 	ldhu	r17,26(r16)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
    9768:	8080040b 	ldhu	r2,16(r16)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
    976c:	8140030b 	ldhu	r5,12(r16)
    9770:	2008917a 	slli	r4,r4,5
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
    9774:	80801115 	stw	r2,68(r16)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
    9778:	1445883a 	add	r2,r2,r17
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
    977c:	88a3883a 	add	r17,r17,r2
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
    9780:	80801215 	stw	r2,72(r16)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
    9784:	84401315 	stw	r17,76(r16)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
    9788:	00082b00 	call	82b0 <__divsi3>
    978c:	1445883a 	add	r2,r2,r17
    9790:	80801415 	stw	r2,80(r16)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
    9794:	913fffcc 	andi	r4,r18,65535
    9798:	81400383 	ldbu	r5,14(r16)
    979c:	20000226 	beq	r4,zero,97a8 <Check_for_DOS_FAT+0x1a0>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
    97a0:	00082b00 	call	82b0 <__divsi3>
    97a4:	00000206 	br	97b0 <Check_for_DOS_FAT+0x1a8>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
    97a8:	a009883a 	mov	r4,r20
    97ac:	00083a80 	call	83a8 <__udivsi3>
		}
		if (num_clusters < 4087)
    97b0:	00c3fd84 	movi	r3,4086
    97b4:	18800216 	blt	r3,r2,97c0 <Check_for_DOS_FAT+0x1b8>
		{
			boot_sector_data.bits_for_cluster_index = 12;
    97b8:	00800304 	movi	r2,12
    97bc:	00000506 	br	97d4 <Check_for_DOS_FAT+0x1cc>
		}
		else if (num_clusters <= 65517)
    97c0:	00fffb54 	movui	r3,65517
    97c4:	18800216 	blt	r3,r2,97d0 <Check_for_DOS_FAT+0x1c8>
		{
			boot_sector_data.bits_for_cluster_index = 16;
    97c8:	00800404 	movi	r2,16
    97cc:	00000106 	br	97d4 <Check_for_DOS_FAT+0x1cc>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
    97d0:	00800804 	movi	r2,32
    97d4:	01000074 	movhi	r4,1
    97d8:	80801085 	stb	r2,66(r16)
    97dc:	212e85c4 	addi	r4,r4,-17897
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
    97e0:	0007883a 	mov	r3,zero
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
    97e4:	01400104 	movi	r5,4
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
    97e8:	98800a17 	ldw	r2,40(r19)
    97ec:	108009c4 	addi	r2,r2,39
    97f0:	10c5883a 	add	r2,r2,r3
    97f4:	10800023 	ldbuio	r2,0(r2)
    97f8:	20800005 	stb	r2,0(r4)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
    97fc:	18c00044 	addi	r3,r3,1
    9800:	21000044 	addi	r4,r4,1
    9804:	197ff81e 	bne	r3,r5,97e8 <_gp+0xffff6214>
    9808:	01000074 	movhi	r4,1
    980c:	212e86c4 	addi	r4,r4,-17893
    9810:	0007883a 	mov	r3,zero
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
    9814:	014002c4 	movi	r5,11
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
    9818:	98800a17 	ldw	r2,40(r19)
    981c:	10800ac4 	addi	r2,r2,43
    9820:	10c5883a 	add	r2,r2,r3
    9824:	10800023 	ldbuio	r2,0(r2)
    9828:	20800005 	stb	r2,0(r4)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
    982c:	18c00044 	addi	r3,r3,1
    9830:	21000044 	addi	r4,r4,1
    9834:	197ff81e 	bne	r3,r5,9818 <_gp+0xffff6244>
    9838:	01000074 	movhi	r4,1
    983c:	212e8984 	addi	r4,r4,-17882
    9840:	0007883a 	mov	r3,zero
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
    9844:	01400204 	movi	r5,8
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
    9848:	98800a17 	ldw	r2,40(r19)
    984c:	10800d84 	addi	r2,r2,54
    9850:	10c5883a 	add	r2,r2,r3
    9854:	10800023 	ldbuio	r2,0(r2)
    9858:	20800005 	stb	r2,0(r4)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
    985c:	18c00044 	addi	r3,r3,1
    9860:	21000044 	addi	r4,r4,1
    9864:	197ff81e 	bne	r3,r5,9848 <_gp+0xffff6274>
    9868:	00c00074 	movhi	r3,1
    986c:	18ee9f04 	addi	r3,r3,-17796
    9870:	0005883a 	mov	r2,zero
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
    9874:	01000504 	movi	r4,20
		{
			active_files[counter].in_use = false;
    9878:	18000015 	stw	zero,0(r3)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
    987c:	10800044 	addi	r2,r2,1
    9880:	18c01004 	addi	r3,r3,64
    9884:	113ffc1e 	bne	r2,r4,9878 <_gp+0xffff62a4>
    9888:	00800044 	movi	r2,1
    988c:	00000106 	br	9894 <Check_for_DOS_FAT+0x28c>
		}
		result = true;
	}
    else
    {
        result = false;
    9890:	0005883a 	mov	r2,zero
    }
	return result;
}
    9894:	dfc00517 	ldw	ra,20(sp)
    9898:	dd000417 	ldw	r20,16(sp)
    989c:	dcc00317 	ldw	r19,12(sp)
    98a0:	dc800217 	ldw	r18,8(sp)
    98a4:	dc400117 	ldw	r17,4(sp)
    98a8:	dc000017 	ldw	r16,0(sp)
    98ac:	dec00604 	addi	sp,sp,24
    98b0:	f800283a 	ret

000098b4 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    98b4:	00800074 	movhi	r2,1
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    98b8:	defffb04 	addi	sp,sp,-20
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    98bc:	10ae7b04 	addi	r2,r2,-17940
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    98c0:	dc400115 	stw	r17,4(sp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    98c4:	14401117 	ldw	r17,68(r2)
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    98c8:	dcc00315 	stw	r19,12(sp)
    98cc:	dc800215 	stw	r18,8(sp)
    98d0:	dc000015 	stw	r16,0(sp)
    98d4:	dfc00415 	stw	ra,16(sp)
    98d8:	2027883a 	mov	r19,r4
    98dc:	04000084 	movi	r16,2
    98e0:	1025883a 	mov	r18,r2
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
    98e4:	90801217 	ldw	r2,72(r18)
    98e8:	88801026 	beq	r17,r2,992c <find_first_empty_cluster+0x78>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
    98ec:	d160f817 	ldw	r5,-31776(gp)
    98f0:	8809883a 	mov	r4,r17
    98f4:	00093540 	call	9354 <Read_Sector_Data>
    98f8:	10000a26 	beq	r2,zero,9924 <find_first_empty_cluster+0x70>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
    98fc:	d0e0f617 	ldw	r3,-31784(gp)
    9900:	80803fcc 	andi	r2,r16,255
    9904:	1085883a 	add	r2,r2,r2
    9908:	18c00a17 	ldw	r3,40(r3)
    990c:	10c5883a 	add	r2,r2,r3
                if (cluster == 0)
    9910:	1080002f 	ldhio	r2,0(r2)
    9914:	10000726 	beq	r2,zero,9934 <find_first_empty_cluster+0x80>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
    9918:	84000044 	addi	r16,r16,1
                } 
            } while ((cluster_index % 256) != 0);
    991c:	80803fcc 	andi	r2,r16,255
    9920:	003ff506 	br	98f8 <_gp+0xffff6324>
        }
        if (cluster == 0)
        {
            break;
        }
        sector++;
    9924:	8c400044 	addi	r17,r17,1
    9928:	003fee06 	br	98e4 <_gp+0xffff6310>
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    unsigned int cluster_index = 2;
    short int cluster = -1;
    bool result = false;
    992c:	0005883a 	mov	r2,zero
    9930:	00000206 	br	993c <find_first_empty_cluster+0x88>
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
    {
        *cluster_number = cluster_index;
    9934:	9c000015 	stw	r16,0(r19)
		result = true;
    9938:	00800044 	movi	r2,1
    }
    return result;
}
    993c:	dfc00417 	ldw	ra,16(sp)
    9940:	dcc00317 	ldw	r19,12(sp)
    9944:	dc800217 	ldw	r18,8(sp)
    9948:	dc400117 	ldw	r17,4(sp)
    994c:	dc000017 	ldw	r16,0(sp)
    9950:	dec00504 	addi	sp,sp,20
    9954:	f800283a 	ret

00009958 <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    9958:	defff504 	addi	sp,sp,-44
    995c:	dcc00515 	stw	r19,20(sp)
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    9960:	04c00074 	movhi	r19,1
}


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    9964:	dd400715 	stw	r21,28(sp)
    9968:	dd000615 	stw	r20,24(sp)
    996c:	dc000215 	stw	r16,8(sp)
    9970:	dfc00a15 	stw	ra,40(sp)
    9974:	ddc00915 	stw	r23,36(sp)
    9978:	dd800815 	stw	r22,32(sp)
    997c:	dc800415 	stw	r18,16(sp)
    9980:	dc400315 	stw	r17,12(sp)
    9984:	2021883a 	mov	r16,r4
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    9988:	9cee7b04 	addi	r19,r19,-17940
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                    if ((leading_char == 0x00e5) || (leading_char == 0))
    998c:	05003944 	movi	r20,229
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    9990:	05400404 	movi	r21,16
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    9994:	99400383 	ldbu	r5,14(r19)
    9998:	813fff84 	addi	r4,r16,-2
    999c:	05c00074 	movhi	r23,1
    99a0:	0008c600 	call	8c60 <__mulsi3>
    99a4:	9c801417 	ldw	r18,80(r19)
    99a8:	bdee7b04 	addi	r23,r23,-17940
    99ac:	14a5883a 	add	r18,r2,r18
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    99b0:	902d883a 	mov	r22,r18
    99b4:	b8800383 	ldbu	r2,14(r23)
    99b8:	b4a3c83a 	sub	r17,r22,r18
    99bc:	8880040e 	bge	r17,r2,99d0 <find_first_empty_record_in_a_subdirectory+0x78>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    99c0:	d160f817 	ldw	r5,-31776(gp)
    99c4:	b009883a 	mov	r4,r22
    99c8:	00093540 	call	9354 <Read_Sector_Data>
    99cc:	1000051e 	bne	r2,zero,99e4 <find_first_empty_record_in_a_subdirectory+0x8c>
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
    99d0:	d9400104 	addi	r5,sp,4
    99d4:	8009883a 	mov	r4,r16
    99d8:	00093f40 	call	93f4 <get_cluster_flag>
    99dc:	1000131e 	bne	r2,zero,9a2c <find_first_empty_record_in_a_subdirectory+0xd4>
    99e0:	00003406 	br	9ab4 <find_first_empty_record_in_a_subdirectory+0x15c>
    99e4:	0007883a 	mov	r3,zero
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
    99e8:	d120f617 	ldw	r4,-31784(gp)
    99ec:	1804917a 	slli	r2,r3,5
    99f0:	21000a17 	ldw	r4,40(r4)
    99f4:	1105883a 	add	r2,r2,r4
    99f8:	10800023 	ldbuio	r2,0(r2)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
    99fc:	10803fcc 	andi	r2,r2,255
    9a00:	1500051e 	bne	r2,r20,9a18 <find_first_empty_record_in_a_subdirectory+0xc0>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
    9a04:	8804913a 	slli	r2,r17,4
    9a08:	10c5883a 	add	r2,r2,r3
    9a0c:	1004943a 	slli	r2,r2,16
    9a10:	1404b03a 	or	r2,r2,r16
                        return result;
    9a14:	00002c06 	br	9ac8 <find_first_empty_record_in_a_subdirectory+0x170>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                    if ((leading_char == 0x00e5) || (leading_char == 0))
    9a18:	103ffa26 	beq	r2,zero,9a04 <_gp+0xffff6430>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    9a1c:	18c00044 	addi	r3,r3,1
    9a20:	1d7ff11e 	bne	r3,r21,99e8 <_gp+0xffff6414>
    9a24:	b5800044 	addi	r22,r22,1
    9a28:	003fe206 	br	99b4 <_gp+0xffff63e0>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
    9a2c:	d880010b 	ldhu	r2,4(sp)
    9a30:	00fffe14 	movui	r3,65528
    9a34:	10bffe0c 	andi	r2,r2,65528
    9a38:	10c01e1e 	bne	r2,r3,9ab4 <find_first_empty_record_in_a_subdirectory+0x15c>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
    9a3c:	d809883a 	mov	r4,sp
    9a40:	00098b40 	call	98b4 <find_first_empty_cluster>
    9a44:	1000021e 	bne	r2,zero,9a50 <find_first_empty_record_in_a_subdirectory+0xf8>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    9a48:	00bfffc4 	movi	r2,-1
    9a4c:	00001606 	br	9aa8 <find_first_empty_record_in_a_subdirectory+0x150>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
    9a50:	d940000f 	ldh	r5,0(sp)
    9a54:	01800044 	movi	r6,1
    9a58:	8009883a 	mov	r4,r16
    9a5c:	00094740 	call	9474 <mark_cluster>
    9a60:	103ff926 	beq	r2,zero,9a48 <_gp+0xffff6474>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
    9a64:	d9000017 	ldw	r4,0(sp)
    9a68:	01800044 	movi	r6,1
    9a6c:	017fffc4 	movi	r5,-1
    9a70:	00094740 	call	9474 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
    9a74:	103ff426 	beq	r2,zero,9a48 <_gp+0xffff6474>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
    9a78:	d940000f 	ldh	r5,0(sp)
    9a7c:	000d883a 	mov	r6,zero
    9a80:	8009883a 	mov	r4,r16
    9a84:	00094740 	call	9474 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
    9a88:	103fef26 	beq	r2,zero,9a48 <_gp+0xffff6474>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
    9a8c:	d9000017 	ldw	r4,0(sp)
    9a90:	000d883a 	mov	r6,zero
    9a94:	017fffc4 	movi	r5,-1
    9a98:	00094740 	call	9474 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
    9a9c:	103fea26 	beq	r2,zero,9a48 <_gp+0xffff6474>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
    9aa0:	00093380 	call	9338 <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
    9aa4:	d8800017 	ldw	r2,0(sp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
    9aa8:	dc00010b 	ldhu	r16,4(sp)
    9aac:	843ffe0c 	andi	r16,r16,65528
    9ab0:	00000106 	br	9ab8 <find_first_empty_record_in_a_subdirectory+0x160>
    9ab4:	00bfffc4 	movi	r2,-1
			{
				// Error encountered.                 
				result = -1;
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
    9ab8:	00fffdd4 	movui	r3,65527
    9abc:	1c000216 	blt	r3,r16,9ac8 <find_first_empty_record_in_a_subdirectory+0x170>
    9ac0:	00ffffc4 	movi	r3,-1
    9ac4:	10ffb326 	beq	r2,r3,9994 <_gp+0xffff63c0>
    return result; 
}
    9ac8:	dfc00a17 	ldw	ra,40(sp)
    9acc:	ddc00917 	ldw	r23,36(sp)
    9ad0:	dd800817 	ldw	r22,32(sp)
    9ad4:	dd400717 	ldw	r21,28(sp)
    9ad8:	dd000617 	ldw	r20,24(sp)
    9adc:	dcc00517 	ldw	r19,20(sp)
    9ae0:	dc800417 	ldw	r18,16(sp)
    9ae4:	dc400317 	ldw	r17,12(sp)
    9ae8:	dc000217 	ldw	r16,8(sp)
    9aec:	dec00b04 	addi	sp,sp,44
    9af0:	f800283a 	ret

00009af4 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
    9af4:	defffa04 	addi	sp,sp,-24
    9af8:	dc400115 	stw	r17,4(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    9afc:	04400074 	movhi	r17,1
    9b00:	8c6e7b04 	addi	r17,r17,-17940
    9b04:	8900050b 	ldhu	r4,20(r17)
    9b08:	8940030b 	ldhu	r5,12(r17)
}


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
    9b0c:	dd000415 	stw	r20,16(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    9b10:	2008917a 	slli	r4,r4,5
}


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
    9b14:	dcc00315 	stw	r19,12(sp)
    9b18:	dc800215 	stw	r18,8(sp)
    9b1c:	dc000015 	stw	r16,0(sp)
    9b20:	dfc00515 	stw	ra,20(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    9b24:	00082b00 	call	82b0 <__divsi3>
    9b28:	1025883a 	mov	r18,r2
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    9b2c:	0021883a 	mov	r16,zero
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                if ((leading_char == 0x00e5) || (leading_char == 0))
    9b30:	04c03944 	movi	r19,229
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
    9b34:	05000404 	movi	r20,16
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    9b38:	84800526 	beq	r16,r18,9b50 <find_first_empty_record_in_root_directory+0x5c>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
    9b3c:	89001317 	ldw	r4,76(r17)
    9b40:	d160f817 	ldw	r5,-31776(gp)
    9b44:	8109883a 	add	r4,r16,r4
    9b48:	00093540 	call	9354 <Read_Sector_Data>
    9b4c:	1000021e 	bne	r2,zero,9b58 <find_first_empty_record_in_root_directory+0x64>
        else
        {
            break;
        }
    }
    return result;
    9b50:	00bfffc4 	movi	r2,-1
    9b54:	00001106 	br	9b9c <find_first_empty_record_in_root_directory+0xa8>
    9b58:	0005883a 	mov	r2,zero
            for (file_counter = 0; file_counter < 16; file_counter++)
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
    9b5c:	d120f617 	ldw	r4,-31784(gp)
    9b60:	1006917a 	slli	r3,r2,5
    9b64:	21000a17 	ldw	r4,40(r4)
    9b68:	1907883a 	add	r3,r3,r4
    9b6c:	18c00023 	ldbuio	r3,0(r3)
                if ((leading_char == 0x00e5) || (leading_char == 0))
    9b70:	18c03fcc 	andi	r3,r3,255
    9b74:	1cc0041e 	bne	r3,r19,9b88 <find_first_empty_record_in_root_directory+0x94>
                {
                    result = (sector_index*16 + file_counter) << 16;
    9b78:	8020913a 	slli	r16,r16,4
    9b7c:	8085883a 	add	r2,r16,r2
    9b80:	1004943a 	slli	r2,r2,16
                    return result;
    9b84:	00000506 	br	9b9c <find_first_empty_record_in_root_directory+0xa8>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                if ((leading_char == 0x00e5) || (leading_char == 0))
    9b88:	183ffb26 	beq	r3,zero,9b78 <_gp+0xffff65a4>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
    9b8c:	10800044 	addi	r2,r2,1
    9b90:	153ff21e 	bne	r2,r20,9b5c <_gp+0xffff6588>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    9b94:	84000044 	addi	r16,r16,1
    9b98:	003fe706 	br	9b38 <_gp+0xffff6564>
        {
            break;
        }
    }
    return result;
}
    9b9c:	dfc00517 	ldw	ra,20(sp)
    9ba0:	dd000417 	ldw	r20,16(sp)
    9ba4:	dcc00317 	ldw	r19,12(sp)
    9ba8:	dc800217 	ldw	r18,8(sp)
    9bac:	dc400117 	ldw	r17,4(sp)
    9bb0:	dc000017 	ldw	r16,0(sp)
    9bb4:	dec00604 	addi	sp,sp,24
    9bb8:	f800283a 	ret

00009bbc <Read_File_Record_At_Offset>:

bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    9bbc:	208007cc 	andi	r2,r4,31
    9bc0:	10005a1e 	bne	r2,zero,9d2c <Read_File_Record_At_Offset+0x170>
}


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
    9bc4:	defffb04 	addi	sp,sp,-20
    9bc8:	dcc00315 	stw	r19,12(sp)
    9bcc:	dc800215 	stw	r18,8(sp)
    9bd0:	dc400115 	stw	r17,4(sp)
    9bd4:	dc000015 	stw	r16,0(sp)
    9bd8:	dfc00415 	stw	ra,16(sp)
    9bdc:	3825883a 	mov	r18,r7
    9be0:	3027883a 	mov	r19,r6
    9be4:	2821883a 	mov	r16,r5
    9be8:	2023883a 	mov	r17,r4
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    9bec:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    9bf0:	1000021e 	bne	r2,zero,9bfc <Read_File_Record_At_Offset+0x40>


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
    9bf4:	0005883a 	mov	r2,zero
    9bf8:	00004506 	br	9d10 <Read_File_Record_At_Offset+0x154>
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    9bfc:	d0a0ff17 	ldw	r2,-31748(gp)
    9c00:	103ffc26 	beq	r2,zero,9bf4 <_gp+0xffff6620>
    9c04:	80800204 	addi	r2,r16,8
    9c08:	8007883a 	mov	r3,r16
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
    9c0c:	8c0dc83a 	sub	r6,r17,r16
    9c10:	d120f617 	ldw	r4,-31784(gp)
    9c14:	30cb883a 	add	r5,r6,r3
    9c18:	21000a17 	ldw	r4,40(r4)
    9c1c:	2909883a 	add	r4,r5,r4
    9c20:	21000023 	ldbuio	r4,0(r4)
    9c24:	19000005 	stb	r4,0(r3)
    9c28:	18c00044 	addi	r3,r3,1
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
    9c2c:	18bff81e 	bne	r3,r2,9c10 <_gp+0xffff663c>
    9c30:	814002c4 	addi	r5,r16,11
    9c34:	8809883a 	mov	r4,r17
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
    9c38:	d0e0f617 	ldw	r3,-31784(gp)
    9c3c:	18c00a17 	ldw	r3,40(r3)
    9c40:	18c00204 	addi	r3,r3,8
    9c44:	1907883a 	add	r3,r3,r4
    9c48:	18c00023 	ldbuio	r3,0(r3)
    9c4c:	10c00005 	stb	r3,0(r2)
    9c50:	10800044 	addi	r2,r2,1
    9c54:	21000044 	addi	r4,r4,1

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
    9c58:	28bff71e 	bne	r5,r2,9c38 <_gp+0xffff6664>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
    9c5c:	d0a0f617 	ldw	r2,-31784(gp)
    9c60:	10c00a17 	ldw	r3,40(r2)
    9c64:	18c002c4 	addi	r3,r3,11
    9c68:	1c47883a 	add	r3,r3,r17
    9c6c:	18c00023 	ldbuio	r3,0(r3)
    9c70:	80c002c5 	stb	r3,11(r16)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
    9c74:	10c00a17 	ldw	r3,40(r2)
    9c78:	18c00384 	addi	r3,r3,14
    9c7c:	1c47883a 	add	r3,r3,r17
    9c80:	18c0002b 	ldhuio	r3,0(r3)
    9c84:	80c0030d 	sth	r3,12(r16)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
    9c88:	10c00a17 	ldw	r3,40(r2)
    9c8c:	18c00404 	addi	r3,r3,16
    9c90:	1c47883a 	add	r3,r3,r17
    9c94:	18c0002b 	ldhuio	r3,0(r3)
    9c98:	80c0038d 	sth	r3,14(r16)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
    9c9c:	10c00a17 	ldw	r3,40(r2)
    9ca0:	18c00484 	addi	r3,r3,18
    9ca4:	1c47883a 	add	r3,r3,r17
    9ca8:	18c0002b 	ldhuio	r3,0(r3)
    9cac:	80c0040d 	sth	r3,16(r16)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
    9cb0:	10c00a17 	ldw	r3,40(r2)
    9cb4:	18c00584 	addi	r3,r3,22
    9cb8:	1c47883a 	add	r3,r3,r17
    9cbc:	18c0002b 	ldhuio	r3,0(r3)
    9cc0:	80c0048d 	sth	r3,18(r16)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
    9cc4:	10c00a17 	ldw	r3,40(r2)
    9cc8:	18c00604 	addi	r3,r3,24
    9ccc:	1c47883a 	add	r3,r3,r17
    9cd0:	18c0002b 	ldhuio	r3,0(r3)
    9cd4:	80c0050d 	sth	r3,20(r16)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
    9cd8:	10c00a17 	ldw	r3,40(r2)
    9cdc:	18c00684 	addi	r3,r3,26
    9ce0:	1c47883a 	add	r3,r3,r17
    9ce4:	18c0002b 	ldhuio	r3,0(r3)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
    9ce8:	10800a17 	ldw	r2,40(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
    9cec:	80c0058d 	sth	r3,22(r16)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
    9cf0:	10800704 	addi	r2,r2,28
    9cf4:	1445883a 	add	r2,r2,r17
    9cf8:	10800037 	ldwio	r2,0(r2)
    9cfc:	80800615 	stw	r2,24(r16)
		record->file_record_cluster = cluster_index;
    9d00:	84c00a15 	stw	r19,40(r16)
		record->file_record_sector_in_cluster = sector_in_cluster;
    9d04:	84800b15 	stw	r18,44(r16)
		record->file_record_offset = offset;
    9d08:	84400c0d 	sth	r17,48(r16)
    9d0c:	00800044 	movi	r2,1
		result = true;
	}
	return result;
}
    9d10:	dfc00417 	ldw	ra,16(sp)
    9d14:	dcc00317 	ldw	r19,12(sp)
    9d18:	dc800217 	ldw	r18,8(sp)
    9d1c:	dc400117 	ldw	r17,4(sp)
    9d20:	dc000017 	ldw	r16,0(sp)
    9d24:	dec00504 	addi	sp,sp,20
    9d28:	f800283a 	ret


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
    9d2c:	0005883a 	mov	r2,zero
		record->file_record_sector_in_cluster = sector_in_cluster;
		record->file_record_offset = offset;
		result = true;
	}
	return result;
}
    9d30:	f800283a 	ret

00009d34 <get_home_directory_cluster_for_file>:
}


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    9d34:	deffef04 	addi	sp,sp,-68
    9d38:	dd800d15 	stw	r22,52(sp)
    9d3c:	dd400c15 	stw	r21,48(sp)
    9d40:	dd000b15 	stw	r20,44(sp)
    9d44:	dcc00a15 	stw	r19,40(sp)
    9d48:	dc800915 	stw	r18,36(sp)
    9d4c:	dc400815 	stw	r17,32(sp)
    9d50:	dc000715 	stw	r16,28(sp)
    9d54:	dfc01015 	stw	ra,64(sp)
    9d58:	df000f15 	stw	fp,60(sp)
    9d5c:	ddc00e15 	stw	r23,56(sp)
    9d60:	202b883a 	mov	r21,r4
    9d64:	d9400515 	stw	r5,20(sp)
    9d68:	3023883a 	mov	r17,r6
    9d6c:	05000074 	movhi	r20,1
    int home_dir_cluster = 0;
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    9d70:	0008f8c0 	call	8f8c <get_dir_divider_location>
    9d74:	1021883a 	mov	r16,r2
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    int home_dir_cluster = 0;
    int location, index;
    int start_location = 0;
    9d78:	0027883a 	mov	r19,zero

bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    int home_dir_cluster = 0;
    9d7c:	002d883a 	mov	r22,zero


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    9d80:	0025883a 	mov	r18,zero
    9d84:	a52e7b04 	addi	r20,r20,-17940
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
    9d88:	0400850e 	bge	zero,r16,9fa0 <get_home_directory_cluster_for_file+0x26c>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
    9d8c:	01400074 	movhi	r5,1
    9d90:	01800204 	movi	r6,8
    9d94:	296c9584 	addi	r5,r5,-19882
    9d98:	d809883a 	mov	r4,sp
    9d9c:	000b1400 	call	b140 <memcpy>
        char extension[3] = { ' ', ' ', ' ' };
    9da0:	01400074 	movhi	r5,1
    9da4:	d9000204 	addi	r4,sp,8
    9da8:	018000c4 	movi	r6,3
    9dac:	296c9784 	addi	r5,r5,-19874
    9db0:	000b1400 	call	b140 <memcpy>
        int ext_index = -1;
    9db4:	013fffc4 	movi	r4,-1
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
    9db8:	0005883a 	mov	r2,zero
        {
            if (file_name[index+start_location] == '.')
    9dbc:	01c00b84 	movi	r7,46
            {
                ext_index = index;
            }
            else if (ext_index < 0)
    9dc0:	2011883a 	mov	r8,r4
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
        {
            if (file_name[index+start_location] == '.')
    9dc4:	988b883a 	add	r5,r19,r2
    9dc8:	a94b883a 	add	r5,r21,r5
    9dcc:	29800003 	ldbu	r6,0(r5)
    9dd0:	31403fcc 	andi	r5,r6,255
    9dd4:	2940201c 	xori	r5,r5,128
    9dd8:	297fe004 	addi	r5,r5,-128
    9ddc:	29c00826 	beq	r5,r7,9e00 <get_home_directory_cluster_for_file+0xcc>
            {
                ext_index = index;
            }
            else if (ext_index < 0)
    9de0:	2200021e 	bne	r4,r8,9dec <get_home_directory_cluster_for_file+0xb8>
            {
                name[index] = file_name[index+start_location];
    9de4:	d88b883a 	add	r5,sp,r2
    9de8:	00000306 	br	9df8 <get_home_directory_cluster_for_file+0xc4>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
    9dec:	110bc83a 	sub	r5,r2,r4
    9df0:	d8c00204 	addi	r3,sp,8
    9df4:	194b883a 	add	r5,r3,r5
    9df8:	29800005 	stb	r6,0(r5)
    9dfc:	00000106 	br	9e04 <get_home_directory_cluster_for_file+0xd0>
    9e00:	1009883a 	mov	r4,r2
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
    9e04:	10800044 	addi	r2,r2,1
    9e08:	80bfee1e 	bne	r16,r2,9dc4 <_gp+0xffff67f0>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
    9e0c:	b000261e 	bne	r22,zero,9ea8 <get_home_directory_cluster_for_file+0x174>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    9e10:	a100050b 	ldhu	r4,20(r20)
    9e14:	a140030b 	ldhu	r5,12(r20)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    9e18:	002f883a 	mov	r23,zero
        }
        
        if (home_dir_cluster == 0)
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    9e1c:	2008917a 	slli	r4,r4,5
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
                            if (match)
                            {
                                new_cluster = file_record->start_cluster_index;
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
    9e20:	07000044 	movi	fp,1
        }
        
        if (home_dir_cluster == 0)
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    9e24:	00082b00 	call	82b0 <__divsi3>
    9e28:	d8800415 	stw	r2,16(sp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    9e2c:	d8c00417 	ldw	r3,16(sp)
    9e30:	b8c05926 	beq	r23,r3,9f98 <get_home_directory_cluster_for_file+0x264>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
    9e34:	a1001317 	ldw	r4,76(r20)
    9e38:	d160f817 	ldw	r5,-31776(gp)
    9e3c:	b909883a 	add	r4,r23,r4
    9e40:	00093540 	call	9354 <Read_Sector_Data>
    9e44:	10005426 	beq	r2,zero,9f98 <get_home_directory_cluster_for_file+0x264>
    9e48:	002d883a 	mov	r22,zero
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
    9e4c:	b80f883a 	mov	r7,r23
    9e50:	000d883a 	mov	r6,zero
    9e54:	880b883a 	mov	r5,r17
    9e58:	b009883a 	mov	r4,r22
    9e5c:	0009bbc0 	call	9bbc <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    9e60:	88800003 	ldbu	r2,0(r17)
    9e64:	00c03944 	movi	r3,229
    9e68:	10c00b26 	beq	r2,r3,9e98 <get_home_directory_cluster_for_file+0x164>
    9e6c:	10000a26 	beq	r2,zero,9e98 <get_home_directory_cluster_for_file+0x164>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
    9e70:	d9800204 	addi	r6,sp,8
    9e74:	d80b883a 	mov	r5,sp
    9e78:	8809883a 	mov	r4,r17
    9e7c:	0008fe40 	call	8fe4 <match_file_record_to_name_ext>
                            if (match)
    9e80:	10000526 	beq	r2,zero,9e98 <get_home_directory_cluster_for_file+0x164>
                            {
                                new_cluster = file_record->start_cluster_index;
    9e84:	8d80058b 	ldhu	r22,22(r17)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
    9e88:	8f000a15 	stw	fp,40(r17)
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
    9e8c:	b0003a1e 	bne	r22,zero,9f78 <get_home_directory_cluster_for_file+0x244>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    9e90:	bdc00044 	addi	r23,r23,1
    9e94:	003fe506 	br	9e2c <_gp+0xffff6858>
    9e98:	b5800804 	addi	r22,r22,32
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
    9e9c:	00808004 	movi	r2,512
    9ea0:	b0bfea1e 	bne	r22,r2,9e4c <_gp+0xffff6878>
    9ea4:	003ffa06 	br	9e90 <_gp+0xffff68bc>
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    9ea8:	b0ffff84 	addi	r3,r22,-2
    9eac:	d8c00615 	stw	r3,24(sp)
    9eb0:	a1400383 	ldbu	r5,14(r20)
    9eb4:	d9000617 	ldw	r4,24(sp)
    9eb8:	0008c600 	call	8c60 <__mulsi3>
    9ebc:	a5c01417 	ldw	r23,80(r20)
    9ec0:	15ef883a 	add	r23,r2,r23
    9ec4:	ddc00415 	stw	r23,16(sp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    9ec8:	002f883a 	mov	r23,zero
    9ecc:	a0800383 	ldbu	r2,14(r20)
    9ed0:	b880050e 	bge	r23,r2,9ee8 <get_home_directory_cluster_for_file+0x1b4>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    9ed4:	d8c00417 	ldw	r3,16(sp)
    9ed8:	d160f817 	ldw	r5,-31776(gp)
    9edc:	1dc9883a 	add	r4,r3,r23
    9ee0:	00093540 	call	9354 <Read_Sector_Data>
    9ee4:	1000051e 	bne	r2,zero,9efc <get_home_directory_cluster_for_file+0x1c8>
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
    9ee8:	d9400304 	addi	r5,sp,12
    9eec:	b009883a 	mov	r4,r22
    9ef0:	00093f40 	call	93f4 <get_cluster_flag>
    9ef4:	1000181e 	bne	r2,zero,9f58 <get_home_directory_cluster_for_file+0x224>
    9ef8:	00002706 	br	9f98 <get_home_directory_cluster_for_file+0x264>
    9efc:	0039883a 	mov	fp,zero
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
    9f00:	b80f883a 	mov	r7,r23
    9f04:	b00d883a 	mov	r6,r22
    9f08:	880b883a 	mov	r5,r17
    9f0c:	e009883a 	mov	r4,fp
    9f10:	0009bbc0 	call	9bbc <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    9f14:	88800003 	ldbu	r2,0(r17)
    9f18:	00c03944 	movi	r3,229
    9f1c:	10c00926 	beq	r2,r3,9f44 <get_home_directory_cluster_for_file+0x210>
    9f20:	10000826 	beq	r2,zero,9f44 <get_home_directory_cluster_for_file+0x210>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
    9f24:	d9800204 	addi	r6,sp,8
    9f28:	d80b883a 	mov	r5,sp
    9f2c:	8809883a 	mov	r4,r17
    9f30:	0008fe40 	call	8fe4 <match_file_record_to_name_ext>
                                if (match)
    9f34:	10000326 	beq	r2,zero,9f44 <get_home_directory_cluster_for_file+0x210>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
    9f38:	8880058b 	ldhu	r2,22(r17)
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
    9f3c:	b0800426 	beq	r22,r2,9f50 <get_home_directory_cluster_for_file+0x21c>
    9f40:	00000c06 	br	9f74 <get_home_directory_cluster_for_file+0x240>
    9f44:	e7000804 	addi	fp,fp,32
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
    9f48:	00808004 	movi	r2,512
    9f4c:	e0bfec1e 	bne	fp,r2,9f00 <_gp+0xffff692c>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    9f50:	bdc00044 	addi	r23,r23,1
    9f54:	003fdd06 	br	9ecc <_gp+0xffff68f8>
    9f58:	d880030b 	ldhu	r2,12(sp)
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
    9f5c:	013ffe14 	movui	r4,65528
    9f60:	10bffe0c 	andi	r2,r2,65528
    9f64:	11000c26 	beq	r2,r4,9f98 <get_home_directory_cluster_for_file+0x264>
					{
						// Directory path is invalid.                 
						return false;
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
    9f68:	013ffdd4 	movui	r4,65527
    9f6c:	25800116 	blt	r4,r22,9f74 <get_home_directory_cluster_for_file+0x240>
    9f70:	b0bfcf26 	beq	r22,r2,9eb0 <_gp+0xffff68dc>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    9f74:	102d883a 	mov	r22,r2
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
            if (new_cluster != home_dir_cluster)
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
                start_location = start_location+location+1;
    9f78:	84e1883a 	add	r16,r16,r19
    9f7c:	84c00044 	addi	r19,r16,1
            {
                // Directory path is invalid. 
                return false;
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
    9f80:	acc9883a 	add	r4,r21,r19
    9f84:	0008f8c0 	call	8f8c <get_dir_divider_location>
    9f88:	1021883a 	mov	r16,r2
        if (location < 0)
    9f8c:	103f7e0e 	bge	r2,zero,9d88 <_gp+0xffff67b4>
        {
            // Directory has been located.
            result = true;
    9f90:	04800044 	movi	r18,1
    9f94:	003f7c06 	br	9d88 <_gp+0xffff67b4>
                start_location = start_location+location+1;
            }
            else
            {
                // Directory path is invalid. 
                return false;
    9f98:	0005883a 	mov	r2,zero
    9f9c:	00000706 	br	9fbc <get_home_directory_cluster_for_file+0x288>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
    9fa0:	d8c00517 	ldw	r3,20(sp)
    9fa4:	1d800015 	stw	r22,0(r3)
    if (home_dir_cluster == 0)
    9fa8:	b000031e 	bne	r22,zero,9fb8 <get_home_directory_cluster_for_file+0x284>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
    9fac:	88000a15 	stw	zero,40(r17)
		result = true;
    9fb0:	00800044 	movi	r2,1
    9fb4:	00000106 	br	9fbc <get_home_directory_cluster_for_file+0x288>
    9fb8:	9005883a 	mov	r2,r18
    }
    return result;
}
    9fbc:	dfc01017 	ldw	ra,64(sp)
    9fc0:	df000f17 	ldw	fp,60(sp)
    9fc4:	ddc00e17 	ldw	r23,56(sp)
    9fc8:	dd800d17 	ldw	r22,52(sp)
    9fcc:	dd400c17 	ldw	r21,48(sp)
    9fd0:	dd000b17 	ldw	r20,44(sp)
    9fd4:	dcc00a17 	ldw	r19,40(sp)
    9fd8:	dc800917 	ldw	r18,36(sp)
    9fdc:	dc400817 	ldw	r17,32(sp)
    9fe0:	dc000717 	ldw	r16,28(sp)
    9fe4:	dec01104 	addi	sp,sp,68
    9fe8:	f800283a 	ret

00009fec <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    9fec:	defff204 	addi	sp,sp,-56
    9ff0:	dc000415 	stw	r16,16(sp)
    9ff4:	2021883a 	mov	r16,r4
    int location = get_dir_divider_location( file_name );
    9ff8:	2809883a 	mov	r4,r5
}


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    9ffc:	dfc00d15 	stw	ra,52(sp)
    a000:	dd400915 	stw	r21,36(sp)
    a004:	dd000815 	stw	r20,32(sp)
    a008:	dcc00715 	stw	r19,28(sp)
    a00c:	dc800615 	stw	r18,24(sp)
    a010:	dc400515 	stw	r17,20(sp)
    a014:	2825883a 	mov	r18,r5
    a018:	3027883a 	mov	r19,r6
    a01c:	df000c15 	stw	fp,48(sp)
    a020:	ddc00b15 	stw	r23,44(sp)
    a024:	dd800a15 	stw	r22,40(sp)
    int location = get_dir_divider_location( file_name );
    a028:	0008f8c0 	call	8f8c <get_dir_divider_location>
    int last_dir_separator = 0;
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
    a02c:	01400074 	movhi	r5,1
    a030:	01800204 	movi	r6,8
    a034:	296c9584 	addi	r5,r5,-19882
    a038:	d809883a 	mov	r4,sp


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    int location = get_dir_divider_location( file_name );
    a03c:	1029883a 	mov	r20,r2
    int last_dir_separator = 0;
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
    a040:	000b1400 	call	b140 <memcpy>
    char extension[3] = { ' ', ' ', ' ' };
    a044:	01400074 	movhi	r5,1
    a048:	018000c4 	movi	r6,3
    a04c:	296c9784 	addi	r5,r5,-19874
    a050:	d9000204 	addi	r4,sp,8
    a054:	000b1400 	call	b140 <memcpy>
    int ext_index = -1;
    int cluster = directory_start_cluster;
    int index;
	int length = strlen(file_name);
    a058:	9009883a 	mov	r4,r18
    a05c:	00085800 	call	8580 <strlen>
    a060:	102b883a 	mov	r21,r2

bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    int location = get_dir_divider_location( file_name );
    int last_dir_separator = 0;
    a064:	0023883a 	mov	r17,zero
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
    a068:	0500060e 	bge	zero,r20,a084 <find_file_in_directory+0x98>
    {
        last_dir_separator = last_dir_separator+location+1;
    a06c:	a463883a 	add	r17,r20,r17
    a070:	8c400044 	addi	r17,r17,1
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    a074:	9449883a 	add	r4,r18,r17
    a078:	0008f8c0 	call	8f8c <get_dir_divider_location>
    a07c:	1029883a 	mov	r20,r2
    a080:	003ff906 	br	a068 <_gp+0xffff6a94>
    a084:	8807883a 	mov	r3,r17
    a088:	00bfffc4 	movi	r2,-1
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    {
        if (file_name[index] == '.')
    a08c:	01800b84 	movi	r6,46
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    a090:	1d40120e 	bge	r3,r21,a0dc <find_file_in_directory+0xf0>
    {
        if (file_name[index] == '.')
    a094:	90c9883a 	add	r4,r18,r3
    a098:	21400003 	ldbu	r5,0(r4)
    a09c:	29003fcc 	andi	r4,r5,255
    a0a0:	2100201c 	xori	r4,r4,128
    a0a4:	213fe004 	addi	r4,r4,-128
    a0a8:	21800926 	beq	r4,r6,a0d0 <find_file_in_directory+0xe4>
        {
            ext_index = index;
        }
        else if (ext_index < 0)
    a0ac:	1000030e 	bge	r2,zero,a0bc <find_file_in_directory+0xd0>
        {
            name[index-last_dir_separator] = file_name[index];
    a0b0:	1c49c83a 	sub	r4,r3,r17
    a0b4:	d909883a 	add	r4,sp,r4
    a0b8:	00000306 	br	a0c8 <find_file_in_directory+0xdc>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
    a0bc:	1889c83a 	sub	r4,r3,r2
    a0c0:	d9c001c4 	addi	r7,sp,7
    a0c4:	3909883a 	add	r4,r7,r4
    a0c8:	21400005 	stb	r5,0(r4)
    a0cc:	00000106 	br	a0d4 <find_file_in_directory+0xe8>
    a0d0:	1805883a 	mov	r2,r3
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    a0d4:	18c00044 	addi	r3,r3,1
    a0d8:	003fed06 	br	a090 <_gp+0xffff6abc>
    a0dc:	04400074 	movhi	r17,1
    a0e0:	8c6e7b04 	addi	r17,r17,-17940
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
    a0e4:	80000426 	beq	r16,zero,a0f8 <find_file_in_directory+0x10c>
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a0e8:	05003944 	movi	r20,229
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
    a0ec:	05408004 	movi	r21,512
    a0f0:	05bffe04 	movi	r22,-8
    a0f4:	00003b06 	br	a1e4 <find_file_in_directory+0x1f8>

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a0f8:	8900050b 	ldhu	r4,20(r17)
    a0fc:	8940030b 	ldhu	r5,12(r17)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a100:	0021883a 	mov	r16,zero

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a104:	2008917a 	slli	r4,r4,5
                
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a108:	05403944 	movi	r21,229
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    a10c:	05808004 	movi	r22,512

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a110:	00082b00 	call	82b0 <__divsi3>
    a114:	1029883a 	mov	r20,r2
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a118:	85004026 	beq	r16,r20,a21c <find_file_in_directory+0x230>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
    a11c:	89001317 	ldw	r4,76(r17)
    a120:	d160f817 	ldw	r5,-31776(gp)
    a124:	8109883a 	add	r4,r16,r4
    a128:	00093540 	call	9354 <Read_Sector_Data>
    a12c:	10003b26 	beq	r2,zero,a21c <find_file_in_directory+0x230>
    a130:	0025883a 	mov	r18,zero
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
    a134:	800f883a 	mov	r7,r16
    a138:	000d883a 	mov	r6,zero
    a13c:	980b883a 	mov	r5,r19
    a140:	9009883a 	mov	r4,r18
    a144:	0009bbc0 	call	9bbc <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a148:	98800003 	ldbu	r2,0(r19)
    a14c:	15400826 	beq	r2,r21,a170 <find_file_in_directory+0x184>
    a150:	10000726 	beq	r2,zero,a170 <find_file_in_directory+0x184>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
    a154:	d9800204 	addi	r6,sp,8
    a158:	d80b883a 	mov	r5,sp
    a15c:	9809883a 	mov	r4,r19
    a160:	0008fe40 	call	8fe4 <match_file_record_to_name_ext>

                        if (match)
    a164:	10000226 	beq	r2,zero,a170 <find_file_in_directory+0x184>
				if (get_cluster_flag(cluster, &new_cluster))
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
					{
						return false;
    a168:	00800044 	movi	r2,1
    a16c:	00002c06 	br	a220 <find_file_in_directory+0x234>
    a170:	94800804 	addi	r18,r18,32
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
    a174:	95bfef1e 	bne	r18,r22,a134 <_gp+0xffff6b60>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
    a178:	84000044 	addi	r16,r16,1
    a17c:	003fe606 	br	a118 <_gp+0xffff6b44>
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    a180:	d160f817 	ldw	r5,-31776(gp)
    a184:	e489883a 	add	r4,fp,r18
    a188:	00093540 	call	9354 <Read_Sector_Data>
    a18c:	10000d26 	beq	r2,zero,a1c4 <find_file_in_directory+0x1d8>
    a190:	002f883a 	mov	r23,zero
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
    a194:	900f883a 	mov	r7,r18
    a198:	800d883a 	mov	r6,r16
    a19c:	980b883a 	mov	r5,r19
    a1a0:	b809883a 	mov	r4,r23
    a1a4:	0009bbc0 	call	9bbc <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a1a8:	98800003 	ldbu	r2,0(r19)
    a1ac:	1500141e 	bne	r2,r20,a200 <find_file_in_directory+0x214>
    a1b0:	bdc00804 	addi	r23,r23,32
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
    a1b4:	bd7ff71e 	bne	r23,r21,a194 <_gp+0xffff6bc0>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a1b8:	94800044 	addi	r18,r18,1
    a1bc:	88800383 	ldbu	r2,14(r17)
    a1c0:	90bfef16 	blt	r18,r2,a180 <_gp+0xffff6bac>
            // that holds data for the current directory.
            if (result == false)
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
    a1c4:	d9400304 	addi	r5,sp,12
    a1c8:	8009883a 	mov	r4,r16
    a1cc:	00093f40 	call	93f4 <get_cluster_flag>
    a1d0:	10001226 	beq	r2,zero,a21c <find_file_in_directory+0x230>
    a1d4:	dc00030b 	ldhu	r16,12(sp)
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
    a1d8:	00bffe14 	movui	r2,65528
    a1dc:	b420703a 	and	r16,r22,r16
    a1e0:	80800e26 	beq	r16,r2,a21c <find_file_in_directory+0x230>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a1e4:	89400383 	ldbu	r5,14(r17)
    a1e8:	813fff84 	addi	r4,r16,-2
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a1ec:	0025883a 	mov	r18,zero
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a1f0:	0008c600 	call	8c60 <__mulsi3>
    a1f4:	8f001417 	ldw	fp,80(r17)
    a1f8:	1739883a 	add	fp,r2,fp
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a1fc:	003fef06 	br	a1bc <_gp+0xffff6be8>
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
    a200:	103feb26 	beq	r2,zero,a1b0 <_gp+0xffff6bdc>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
    a204:	d9800204 	addi	r6,sp,8
    a208:	d80b883a 	mov	r5,sp
    a20c:	9809883a 	mov	r4,r19
    a210:	0008fe40 	call	8fe4 <match_file_record_to_name_ext>

                            if (match)
    a214:	103fe626 	beq	r2,zero,a1b0 <_gp+0xffff6bdc>
    a218:	003fd306 	br	a168 <_gp+0xffff6b94>
				if (get_cluster_flag(cluster, &new_cluster))
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
					{
						return false;
    a21c:	0005883a 	mov	r2,zero
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
}
    a220:	dfc00d17 	ldw	ra,52(sp)
    a224:	df000c17 	ldw	fp,48(sp)
    a228:	ddc00b17 	ldw	r23,44(sp)
    a22c:	dd800a17 	ldw	r22,40(sp)
    a230:	dd400917 	ldw	r21,36(sp)
    a234:	dd000817 	ldw	r20,32(sp)
    a238:	dcc00717 	ldw	r19,28(sp)
    a23c:	dc800617 	ldw	r18,24(sp)
    a240:	dc400517 	ldw	r17,20(sp)
    a244:	dc000417 	ldw	r16,16(sp)
    a248:	dec00e04 	addi	sp,sp,56
    a24c:	f800283a 	ret

0000a250 <Write_File_Record_At_Offset>:

bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a250:	208007cc 	andi	r2,r4,31
    a254:	1000551e 	bne	r2,zero,a3ac <Write_File_Record_At_Offset+0x15c>
}


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    a258:	defffd04 	addi	sp,sp,-12
    a25c:	dc400115 	stw	r17,4(sp)
    a260:	dc000015 	stw	r16,0(sp)
    a264:	dfc00215 	stw	ra,8(sp)
    a268:	2821883a 	mov	r16,r5
    a26c:	2023883a 	mov	r17,r4
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a270:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    a274:	1000021e 	bne	r2,zero,a280 <Write_File_Record_At_Offset+0x30>


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    a278:	0005883a 	mov	r2,zero
    a27c:	00004606 	br	a398 <Write_File_Record_At_Offset+0x148>
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a280:	d0a0ff17 	ldw	r2,-31748(gp)
    a284:	103ffc26 	beq	r2,zero,a278 <_gp+0xffff6ca4>
    a288:	81000044 	addi	r4,r16,1
    a28c:	80800204 	addi	r2,r16,8
    a290:	8007883a 	mov	r3,r16
        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
    a294:	8c11c83a 	sub	r8,r17,r16
    a298:	d160f617 	ldw	r5,-31784(gp)
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
    a29c:	21800003 	ldbu	r6,0(r4)
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
    a2a0:	29400a17 	ldw	r5,40(r5)
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
    a2a4:	300e923a 	slli	r7,r6,8
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
    a2a8:	40cd883a 	add	r6,r8,r3
    a2ac:	314b883a 	add	r5,r6,r5
    a2b0:	19800003 	ldbu	r6,0(r3)
    a2b4:	398cb03a 	or	r6,r7,r6
    a2b8:	2980002d 	sthio	r6,0(r5)
    a2bc:	18c00084 	addi	r3,r3,2
    a2c0:	21000084 	addi	r4,r4,2
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
    a2c4:	10fff41e 	bne	r2,r3,a298 <_gp+0xffff6cc4>
    a2c8:	814002c4 	addi	r5,r16,11
    a2cc:	8807883a 	mov	r3,r17
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
    a2d0:	d120f617 	ldw	r4,-31784(gp)
    a2d4:	11800003 	ldbu	r6,0(r2)
    a2d8:	21000a17 	ldw	r4,40(r4)
    a2dc:	1909883a 	add	r4,r3,r4
    a2e0:	21800225 	stbio	r6,8(r4)
    a2e4:	10800044 	addi	r2,r2,1
    a2e8:	18c00044 	addi	r3,r3,1
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
    a2ec:	28bff81e 	bne	r5,r2,a2d0 <_gp+0xffff6cfc>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
    a2f0:	d0a0f617 	ldw	r2,-31784(gp)
    a2f4:	80c002c3 	ldbu	r3,11(r16)
    a2f8:	10800a17 	ldw	r2,40(r2)
    a2fc:	8885883a 	add	r2,r17,r2
    a300:	10c002e5 	stbio	r3,11(r2)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
    a304:	d0a0f617 	ldw	r2,-31784(gp)
    a308:	80c0030b 	ldhu	r3,12(r16)
    a30c:	10800a17 	ldw	r2,40(r2)
    a310:	8885883a 	add	r2,r17,r2
    a314:	10c003ad 	sthio	r3,14(r2)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
    a318:	d0a0f617 	ldw	r2,-31784(gp)
    a31c:	80c0038b 	ldhu	r3,14(r16)
    a320:	10800a17 	ldw	r2,40(r2)
    a324:	8885883a 	add	r2,r17,r2
    a328:	10c0042d 	sthio	r3,16(r2)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
    a32c:	d0a0f617 	ldw	r2,-31784(gp)
    a330:	80c0040b 	ldhu	r3,16(r16)
    a334:	10800a17 	ldw	r2,40(r2)
    a338:	8885883a 	add	r2,r17,r2
    a33c:	10c004ad 	sthio	r3,18(r2)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
    a340:	d0a0f617 	ldw	r2,-31784(gp)
    a344:	80c0048b 	ldhu	r3,18(r16)
    a348:	10800a17 	ldw	r2,40(r2)
    a34c:	8885883a 	add	r2,r17,r2
    a350:	10c005ad 	sthio	r3,22(r2)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
    a354:	d0a0f617 	ldw	r2,-31784(gp)
    a358:	80c0050b 	ldhu	r3,20(r16)
    a35c:	10800a17 	ldw	r2,40(r2)
    a360:	8885883a 	add	r2,r17,r2
    a364:	10c0062d 	sthio	r3,24(r2)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
    a368:	d0a0f617 	ldw	r2,-31784(gp)
    a36c:	80c0058b 	ldhu	r3,22(r16)
    a370:	10800a17 	ldw	r2,40(r2)
    a374:	8885883a 	add	r2,r17,r2
    a378:	10c006ad 	sthio	r3,26(r2)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
    a37c:	d0a0f617 	ldw	r2,-31784(gp)
    a380:	11000a17 	ldw	r4,40(r2)
    a384:	80800617 	ldw	r2,24(r16)
    a388:	8923883a 	add	r17,r17,r4
    a38c:	88800735 	stwio	r2,28(r17)
        current_sector_modified = true;                  
    a390:	00800044 	movi	r2,1
    a394:	d0a0f515 	stw	r2,-31788(gp)
        result = true;
    }
    return result;
}
    a398:	dfc00217 	ldw	ra,8(sp)
    a39c:	dc400117 	ldw	r17,4(sp)
    a3a0:	dc000017 	ldw	r16,0(sp)
    a3a4:	dec00304 	addi	sp,sp,12
    a3a8:	f800283a 	ret


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    a3ac:	0005883a 	mov	r2,zero
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
        current_sector_modified = true;                  
        result = true;
    }
    return result;
}
    a3b0:	f800283a 	ret

0000a3b4 <create_file>:

}

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    a3b4:	defff904 	addi	sp,sp,-28
    a3b8:	dd000515 	stw	r20,20(sp)
    a3bc:	2029883a 	mov	r20,r4
    unsigned int cluster_number;
    bool result = false;
    
    if (find_first_empty_cluster(&cluster_number))
    a3c0:	d809883a 	mov	r4,sp

}

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    a3c4:	dcc00415 	stw	r19,16(sp)
    a3c8:	dc000115 	stw	r16,4(sp)
    a3cc:	dfc00615 	stw	ra,24(sp)
    a3d0:	dc800315 	stw	r18,12(sp)
    a3d4:	dc400215 	stw	r17,8(sp)
    a3d8:	2821883a 	mov	r16,r5
    a3dc:	3027883a 	mov	r19,r6
    unsigned int cluster_number;
    bool result = false;
    
    if (find_first_empty_cluster(&cluster_number))
    a3e0:	00098b40 	call	98b4 <find_first_empty_cluster>
    a3e4:	1000021e 	bne	r2,zero,a3f0 <create_file+0x3c>

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    unsigned int cluster_number;
    bool result = false;
    a3e8:	0005883a 	mov	r2,zero
    a3ec:	00004b06 	br	a51c <create_file+0x168>
    
    if (find_first_empty_cluster(&cluster_number))
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
    a3f0:	98800a17 	ldw	r2,40(r19)
    a3f4:	1000021e 	bne	r2,zero,a400 <create_file+0x4c>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
    a3f8:	0009af40 	call	9af4 <find_first_empty_record_in_root_directory>
    a3fc:	00000206 	br	a408 <create_file+0x54>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
    a400:	9900058b 	ldhu	r4,22(r19)
    a404:	00099580 	call	9958 <find_first_empty_record_in_a_subdirectory>
    a408:	1023883a 	mov	r17,r2
        }
        if (record_index >= 0)
    a40c:	103ff616 	blt	r2,zero,a3e8 <_gp+0xffff6e14>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
    a410:	a009883a 	mov	r4,r20
    a414:	0008f8c0 	call	8f8c <get_dir_divider_location>
            int last_dir_separator = 0;
    a418:	0025883a 	mov	r18,zero

            // Skip through all directory separators.
            while (location > 0)
    a41c:	0080050e 	bge	zero,r2,a434 <create_file+0x80>
            {
                last_dir_separator = last_dir_separator+location+1;
    a420:	14a5883a 	add	r18,r2,r18
    a424:	94800044 	addi	r18,r18,1
                location = get_dir_divider_location( &(name[last_dir_separator]) );
    a428:	a489883a 	add	r4,r20,r18
    a42c:	0008f8c0 	call	8f8c <get_dir_divider_location>
    a430:	003ffa06 	br	a41c <_gp+0xffff6e48>
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
    a434:	a489883a 	add	r4,r20,r18
    a438:	81800204 	addi	r6,r16,8
    a43c:	800b883a 	mov	r5,r16
    a440:	00090d00 	call	90d0 <convert_filename_to_name_extension>
            file_record->create_time = 0;
            file_record->create_date = 0;
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
    a444:	d8800017 	ldw	r2,0(sp)
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
    a448:	893fffcc 	andi	r4,r17,65535
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
    a44c:	8822d43a 	srli	r17,r17,16
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
    a450:	800002c5 	stb	zero,11(r16)
            file_record->create_time = 0;
            file_record->create_date = 0;
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
    a454:	8080058d 	sth	r2,22(r16)
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
    a458:	8825d13a 	srai	r18,r17,4
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
    a45c:	80800715 	stw	r2,28(r16)
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
    a460:	8c4003cc 	andi	r17,r17,15
            file_record->home_directory_cluster = home_dir->start_cluster_index;
    a464:	9880058b 	ldhu	r2,22(r19)
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
    a468:	8822917a 	slli	r17,r17,5
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
            file_record->create_time = 0;
    a46c:	8000030d 	sth	zero,12(r16)
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
    a470:	80800d15 	stw	r2,52(r16)
            file_record->in_use = true;
    a474:	00800044 	movi	r2,1
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
    a478:	84400c0d 	sth	r17,48(r16)
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
            file_record->create_time = 0;
            file_record->create_date = 0;
    a47c:	8000038d 	sth	zero,14(r16)
    a480:	04400074 	movhi	r17,1
            file_record->last_access_date = 0;
    a484:	8000040d 	sth	zero,16(r16)
            file_record->last_modified_time = 0;
    a488:	8000048d 	sth	zero,18(r16)
            file_record->last_modified_date = 0;
    a48c:	8000050d 	sth	zero,20(r16)
            file_record->start_cluster_index = cluster_number;
            file_record->file_size_in_bytes = 0;
    a490:	80000615 	stw	zero,24(r16)
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
    a494:	80000815 	stw	zero,32(r16)
            file_record->current_byte_position = 0;
    a498:	80000915 	stw	zero,36(r16)
            file_record->file_record_cluster = record_index & 0x0000ffff;
    a49c:	81000a15 	stw	r4,40(r16)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
    a4a0:	84800b15 	stw	r18,44(r16)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
    a4a4:	80800f15 	stw	r2,60(r16)
            file_record->modified = true;
    a4a8:	80800e15 	stw	r2,56(r16)
    a4ac:	8c6e7b04 	addi	r17,r17,-17940
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
    a4b0:	2000031e 	bne	r4,zero,a4c0 <create_file+0x10c>
    a4b4:	89001317 	ldw	r4,76(r17)
    a4b8:	9109883a 	add	r4,r18,r4
    a4bc:	00000606 	br	a4d8 <create_file+0x124>
    a4c0:	89400383 	ldbu	r5,14(r17)
    a4c4:	213fff84 	addi	r4,r4,-2
    a4c8:	0008c600 	call	8c60 <__mulsi3>
    a4cc:	89001417 	ldw	r4,80(r17)
    a4d0:	1105883a 	add	r2,r2,r4
    a4d4:	1489883a 	add	r4,r2,r18
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
    a4d8:	d160f817 	ldw	r5,-31776(gp)
    a4dc:	00093540 	call	9354 <Read_Sector_Data>
    a4e0:	103fc126 	beq	r2,zero,a3e8 <_gp+0xffff6e14>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
    a4e4:	81000c0f 	ldh	r4,48(r16)
    a4e8:	800b883a 	mov	r5,r16
    a4ec:	000a2500 	call	a250 <Write_File_Record_At_Offset>
    a4f0:	103fbd26 	beq	r2,zero,a3e8 <_gp+0xffff6e14>
                {
                    Save_Modified_Sector();
    a4f4:	00093380 	call	9338 <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
    a4f8:	d9000017 	ldw	r4,0(sp)
    a4fc:	01800044 	movi	r6,1
    a500:	017fffc4 	movi	r5,-1
    a504:	00094740 	call	9474 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
    a508:	d9000017 	ldw	r4,0(sp)
    a50c:	000d883a 	mov	r6,zero
    a510:	017fffc4 	movi	r5,-1
    a514:	00094740 	call	9474 <mark_cluster>

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    unsigned int cluster_number;
    bool result = false;
    a518:	1004c03a 	cmpne	r2,r2,zero
            }
        }

    }
    return result;           
}
    a51c:	dfc00617 	ldw	ra,24(sp)
    a520:	dd000517 	ldw	r20,20(sp)
    a524:	dcc00417 	ldw	r19,16(sp)
    a528:	dc800317 	ldw	r18,12(sp)
    a52c:	dc400217 	ldw	r17,8(sp)
    a530:	dc000117 	ldw	r16,4(sp)
    a534:	dec00704 	addi	sp,sp,28
    a538:	f800283a 	ret

0000a53c <Look_for_FAT16>:
}


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
    a53c:	deffff04 	addi	sp,sp,-4
    a540:	dfc00015 	stw	ra,0(sp)
	bool result = false;

	if (alt_up_sd_card_is_Present())
    a544:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    a548:	1000021e 	bne	r2,zero,a554 <Look_for_FAT16+0x18>


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
	bool result = false;
    a54c:	0005883a 	mov	r2,zero
    a550:	00001d06 	br	a5c8 <Look_for_FAT16+0x8c>

	if (alt_up_sd_card_is_Present())
	{
		short int csd_file_format = *CSD_register_w0;
    a554:	d0a0fc17 	ldw	r2,-31760(gp)
    a558:	1080000b 	ldhu	r2,0(r2)
        
		fat_partition_offset_in_512_byte_sectors = 0;
    a55c:	d020f815 	stw	zero,-31776(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
    a560:	d020f715 	stw	zero,-31780(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
    a564:	10ffffcc 	andi	r3,r2,65535
    a568:	18e0001c 	xori	r3,r3,32768
    a56c:	18e00004 	addi	r3,r3,-32768
    a570:	183ff616 	blt	r3,zero,a54c <_gp+0xffff6f78>
    a574:	1083000c 	andi	r2,r2,3072
    a578:	00c30004 	movi	r3,3072
    a57c:	10fff326 	beq	r2,r3,a54c <_gp+0xffff6f78>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
    a580:	00c10004 	movi	r3,1024
    a584:	10c0021e 	bne	r2,r3,a590 <Look_for_FAT16+0x54>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
    a588:	0009883a 	mov	r4,zero
    a58c:	00000406 	br	a5a0 <Look_for_FAT16+0x64>
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
    a590:	103fee1e 	bne	r2,zero,a54c <_gp+0xffff6f78>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
    a594:	00095000 	call	9500 <Check_for_Master_Boot_Record>
    a598:	103fec26 	beq	r2,zero,a54c <_gp+0xffff6f78>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
    a59c:	d120f817 	ldw	r4,-31776(gp)
    a5a0:	00096080 	call	9608 <Check_for_DOS_FAT>
				}                        
			}
			if (result == true)
    a5a4:	00c00044 	movi	r3,1
    a5a8:	10c0071e 	bne	r2,r3,a5c8 <Look_for_FAT16+0x8c>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
    a5ac:	00c00074 	movhi	r3,1
    a5b0:	18ee7b04 	addi	r3,r3,-17940
    a5b4:	19401083 	ldbu	r5,66(r3)
    a5b8:	01000404 	movi	r4,16
    a5bc:	293fe31e 	bne	r5,r4,a54c <_gp+0xffff6f78>
				{
					result = false;
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
    a5c0:	18c0058b 	ldhu	r3,22(r3)
    a5c4:	d0e0f715 	stw	r3,-31780(gp)
				}
			}
		}
	}
	return result;
}
    a5c8:	dfc00017 	ldw	ra,0(sp)
    a5cc:	dec00104 	addi	sp,sp,4
    a5d0:	f800283a 	ret

0000a5d4 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
    a5d4:	deffff04 	addi	sp,sp,-4
    a5d8:	dfc00015 	stw	ra,0(sp)
	bool result = false;

	if (alt_up_sd_card_is_Present())
    a5dc:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    a5e0:	10000a26 	beq	r2,zero,a60c <alt_up_sd_card_is_FAT16+0x38>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
    a5e4:	d0a10017 	ldw	r2,-31744(gp)
    a5e8:	1000061e 	bne	r2,zero,a604 <alt_up_sd_card_is_FAT16+0x30>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
    a5ec:	000a53c0 	call	a53c <Look_for_FAT16>
    a5f0:	d0a0ff15 	stw	r2,-31748(gp)
			initialized = is_sd_card_formated_as_FAT16;
    a5f4:	d0a10015 	stw	r2,-31744(gp)
			search_data.valid = false;
    a5f8:	00800074 	movhi	r2,1
    a5fc:	10ae7604 	addi	r2,r2,-17960
    a600:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
    a604:	d0a0ff17 	ldw	r2,-31748(gp)
    a608:	00000306 	br	a618 <alt_up_sd_card_is_FAT16+0x44>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
    a60c:	d0210015 	stw	zero,-31744(gp)
		is_sd_card_formated_as_FAT16 = false;
    a610:	d020ff15 	stw	zero,-31748(gp)
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
	bool result = false;
    a614:	0005883a 	mov	r2,zero
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
	}

	return result;
}
    a618:	dfc00017 	ldw	ra,0(sp)
    a61c:	dec00104 	addi	sp,sp,4
    a620:	f800283a 	ret

0000a624 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
    a624:	deffe404 	addi	sp,sp,-112
    a628:	dd401715 	stw	r21,92(sp)
    a62c:	dfc01b15 	stw	ra,108(sp)
    a630:	df001a15 	stw	fp,104(sp)
    a634:	ddc01915 	stw	r23,100(sp)
    a638:	dd801815 	stw	r22,96(sp)
    a63c:	dd001615 	stw	r20,88(sp)
    a640:	dcc01515 	stw	r19,84(sp)
    a644:	dc801415 	stw	r18,80(sp)
    a648:	dc401315 	stw	r17,76(sp)
    a64c:	dc001215 	stw	r16,72(sp)
    a650:	202b883a 	mov	r21,r4
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a654:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    a658:	10006c26 	beq	r2,zero,a80c <alt_up_sd_card_find_next+0x1e8>
    a65c:	d0a0ff17 	ldw	r2,-31748(gp)
    a660:	10006a26 	beq	r2,zero,a80c <alt_up_sd_card_find_next+0x1e8>
	{
		if (search_data.valid)
    a664:	04400074 	movhi	r17,1
    a668:	8c6e7604 	addi	r17,r17,-17960
    a66c:	88800417 	ldw	r2,16(r17)
    a670:	10006826 	beq	r2,zero,a814 <alt_up_sd_card_find_next+0x1f0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
    a674:	8c800117 	ldw	r18,4(r17)
    a678:	05000074 	movhi	r20,1
    a67c:	a52e7b04 	addi	r20,r20,-17940
    a680:	8c00030f 	ldh	r16,12(r17)

			if (cluster == 0)
    a684:	9000251e 	bne	r18,zero,a71c <alt_up_sd_card_find_next+0xf8>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a688:	a100050b 	ldhu	r4,20(r20)
    a68c:	a140030b 	ldhu	r5,12(r20)
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    a690:	84000044 	addi	r16,r16,1
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a694:	2008917a 	slli	r4,r4,5
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
    a698:	05c003c4 	movi	r23,15
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    a69c:	07003944 	movi	fp,229
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a6a0:	00082b00 	call	82b0 <__divsi3>
				int sector_index = search_data.current_sector_in_cluster;
    a6a4:	8c800217 	ldw	r18,8(r17)
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    a6a8:	102d883a 	mov	r22,r2
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
    a6ac:	9580050e 	bge	r18,r22,a6c4 <alt_up_sd_card_find_next+0xa0>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
    a6b0:	a1001317 	ldw	r4,76(r20)
    a6b4:	d160f817 	ldw	r5,-31776(gp)
    a6b8:	9109883a 	add	r4,r18,r4
    a6bc:	00093540 	call	9354 <Read_Sector_Data>
    a6c0:	1000021e 	bne	r2,zero,a6cc <alt_up_sd_card_find_next+0xa8>
					else
					{
						break;
					}
				}
				result = -1;
    a6c4:	04ffffc4 	movi	r19,-1
    a6c8:	00004e06 	br	a804 <alt_up_sd_card_find_next+0x1e0>
    a6cc:	8026917a 	slli	r19,r16,5
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
    a6d0:	bc000f16 	blt	r23,r16,a710 <alt_up_sd_card_find_next+0xec>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
    a6d4:	900f883a 	mov	r7,r18
    a6d8:	000d883a 	mov	r6,zero
    a6dc:	d80b883a 	mov	r5,sp
    a6e0:	9809883a 	mov	r4,r19
    a6e4:	0009bbc0 	call	9bbc <Read_File_Record_At_Offset>
    a6e8:	10000626 	beq	r2,zero,a704 <alt_up_sd_card_find_next+0xe0>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    a6ec:	d8800003 	ldbu	r2,0(sp)
    a6f0:	10000426 	beq	r2,zero,a704 <alt_up_sd_card_find_next+0xe0>
    a6f4:	17000326 	beq	r2,fp,a704 <alt_up_sd_card_find_next+0xe0>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
    a6f8:	8c00030d 	sth	r16,12(r17)
									search_data.current_sector_in_cluster = sector_index;
    a6fc:	8c800215 	stw	r18,8(r17)
    a700:	00002906 	br	a7a8 <alt_up_sd_card_find_next+0x184>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
    a704:	84000044 	addi	r16,r16,1
    a708:	9cc00804 	addi	r19,r19,32
    a70c:	003ff006 	br	a6d0 <_gp+0xffff70fc>
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
    a710:	94800044 	addi	r18,r18,1
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
    a714:	0021883a 	mov	r16,zero
    a718:	003fe406 	br	a6ac <_gp+0xffff70d8>
				}
				result = -1;
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
    a71c:	84000044 	addi	r16,r16,1
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
	short int result = 2;
    a720:	04c00084 	movi	r19,2
						{        
							for (; file_counter < 16; file_counter++)
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    a724:	05c03944 	movi	r23,229
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a728:	a1400383 	ldbu	r5,14(r20)
    a72c:	913fff84 	addi	r4,r18,-2
    a730:	0008c600 	call	8c60 <__mulsi3>
    a734:	a7001417 	ldw	fp,80(r20)
					int sector_index = search_data.current_sector_in_cluster;
    a738:	8d800217 	ldw	r22,8(r17)
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
    a73c:	1739883a 	add	fp,r2,fp
    a740:	00000206 	br	a74c <alt_up_sd_card_find_next+0x128>
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a744:	b5800044 	addi	r22,r22,1
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
    a748:	0021883a 	mov	r16,zero
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
    a74c:	a0800383 	ldbu	r2,14(r20)
    a750:	b0801a0e 	bge	r22,r2,a7bc <alt_up_sd_card_find_next+0x198>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
    a754:	d160f817 	ldw	r5,-31776(gp)
    a758:	e589883a 	add	r4,fp,r22
    a75c:	00093540 	call	9354 <Read_Sector_Data>
    a760:	10001626 	beq	r2,zero,a7bc <alt_up_sd_card_find_next+0x198>
    a764:	8010917a 	slli	r8,r16,5
						{        
							for (; file_counter < 16; file_counter++)
    a768:	008003c4 	movi	r2,15
    a76c:	143ff516 	blt	r2,r16,a744 <_gp+0xffff7170>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
    a770:	4009883a 	mov	r4,r8
    a774:	b00f883a 	mov	r7,r22
    a778:	900d883a 	mov	r6,r18
    a77c:	d80b883a 	mov	r5,sp
    a780:	da001115 	stw	r8,68(sp)
    a784:	0009bbc0 	call	9bbc <Read_File_Record_At_Offset>
    a788:	da001117 	ldw	r8,68(sp)
    a78c:	10000e26 	beq	r2,zero,a7c8 <alt_up_sd_card_find_next+0x1a4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
    a790:	d8800003 	ldbu	r2,0(sp)
    a794:	10000c26 	beq	r2,zero,a7c8 <alt_up_sd_card_find_next+0x1a4>
    a798:	15c00b26 	beq	r2,r23,a7c8 <alt_up_sd_card_find_next+0x1a4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
    a79c:	8c800115 	stw	r18,4(r17)
										search_data.file_index_in_sector = file_counter;
    a7a0:	8c00030d 	sth	r16,12(r17)
										search_data.current_sector_in_cluster = sector_index;
    a7a4:	8d800215 	stw	r22,8(r17)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
    a7a8:	a80b883a 	mov	r5,r21
    a7ac:	d809883a 	mov	r4,sp
    a7b0:	00091680 	call	9168 <copy_file_record_name_to_string>
									search_data.file_index_in_sector = file_counter;
									search_data.current_sector_in_cluster = sector_index;

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
    a7b4:	0005883a 	mov	r2,zero
    a7b8:	00001706 	br	a818 <alt_up_sd_card_find_next+0x1f4>
							break;
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
    a7bc:	a0800383 	ldbu	r2,14(r20)
    a7c0:	b0800e16 	blt	r22,r2,a7fc <alt_up_sd_card_find_next+0x1d8>
    a7c4:	00000306 	br	a7d4 <alt_up_sd_card_find_next+0x1b0>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
    a7c8:	84000044 	addi	r16,r16,1
    a7cc:	42000804 	addi	r8,r8,32
    a7d0:	003fe506 	br	a768 <_gp+0xffff7194>
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
    a7d4:	d9401004 	addi	r5,sp,64
    a7d8:	9009883a 	mov	r4,r18
    a7dc:	00093f40 	call	93f4 <get_cluster_flag>
    a7e0:	10000526 	beq	r2,zero,a7f8 <alt_up_sd_card_find_next+0x1d4>
    a7e4:	dc80100b 	ldhu	r18,64(sp)
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
    a7e8:	00bffe14 	movui	r2,65528
    a7ec:	94bffe0c 	andi	r18,r18,65528
    a7f0:	9080021e 	bne	r18,r2,a7fc <alt_up_sd_card_find_next+0x1d8>
							{
								result = -1;
								search_data.valid = false;
    a7f4:	88000415 	stw	zero,16(r17)
							cluster = ((new_cluster) & 0x0000fff8);
						}
						else
						{
							// Error encountered.                 
							result = -1;
    a7f8:	04ffffc4 	movi	r19,-1
						}
					}              
				} while (cluster < 0x0000fff8);
    a7fc:	00bffdd4 	movui	r2,65527
    a800:	14bfc90e 	bge	r2,r18,a728 <_gp+0xffff7154>
    a804:	9805883a 	mov	r2,r19
    a808:	00000306 	br	a818 <alt_up_sd_card_find_next+0x1f4>
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
	short int result = 2;
    a80c:	00800084 	movi	r2,2
    a810:	00000106 	br	a818 <alt_up_sd_card_find_next+0x1f4>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
    a814:	008000c4 	movi	r2,3
		}
	}
	return result;
}
    a818:	dfc01b17 	ldw	ra,108(sp)
    a81c:	df001a17 	ldw	fp,104(sp)
    a820:	ddc01917 	ldw	r23,100(sp)
    a824:	dd801817 	ldw	r22,96(sp)
    a828:	dd401717 	ldw	r21,92(sp)
    a82c:	dd001617 	ldw	r20,88(sp)
    a830:	dcc01517 	ldw	r19,84(sp)
    a834:	dc801417 	ldw	r18,80(sp)
    a838:	dc401317 	ldw	r17,76(sp)
    a83c:	dc001217 	ldw	r16,72(sp)
    a840:	dec01c04 	addi	sp,sp,112
    a844:	f800283a 	ret

0000a848 <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
    a848:	deffec04 	addi	sp,sp,-80
    a84c:	dc001215 	stw	r16,72(sp)
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a850:	d9001115 	stw	r4,68(sp)
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
    a854:	dfc01315 	stw	ra,76(sp)
    a858:	2821883a 	mov	r16,r5
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a85c:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    a860:	d9001117 	ldw	r4,68(sp)
    a864:	10001526 	beq	r2,zero,a8bc <alt_up_sd_card_find_first+0x74>
    a868:	d0a0ff17 	ldw	r2,-31748(gp)
    a86c:	10001326 	beq	r2,zero,a8bc <alt_up_sd_card_find_first+0x74>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
    a870:	d80d883a 	mov	r6,sp
    a874:	d9401004 	addi	r5,sp,64
    a878:	0009d340 	call	9d34 <get_home_directory_cluster_for_file>
    a87c:	10000d26 	beq	r2,zero,a8b4 <alt_up_sd_card_find_first+0x6c>
		{
			search_data.directory_root_cluster = home_directory_cluster;
    a880:	d8c01017 	ldw	r3,64(sp)
    a884:	00800074 	movhi	r2,1
    a888:	10ae7604 	addi	r2,r2,-17960
    a88c:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
    a890:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
			search_data.file_index_in_sector = -1;
    a894:	00ffffc4 	movi	r3,-1
    a898:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
			result = alt_up_sd_card_find_next(file_name);
    a89c:	8009883a 	mov	r4,r16
		{
			search_data.directory_root_cluster = home_directory_cluster;
			search_data.current_cluster_index = home_directory_cluster;
			search_data.current_sector_in_cluster = 0;
			search_data.file_index_in_sector = -1;
			search_data.valid = true;
    a8a0:	00c00044 	movi	r3,1
    a8a4:	10c00415 	stw	r3,16(r2)

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
		{
			search_data.directory_root_cluster = home_directory_cluster;
			search_data.current_cluster_index = home_directory_cluster;
			search_data.current_sector_in_cluster = 0;
    a8a8:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
			search_data.valid = true;
			result = alt_up_sd_card_find_next(file_name);
    a8ac:	000a6240 	call	a624 <alt_up_sd_card_find_next>
    a8b0:	00000306 	br	a8c0 <alt_up_sd_card_find_first+0x78>
		}
		else
		{
			result = 1;
    a8b4:	00800044 	movi	r2,1
    a8b8:	00000106 	br	a8c0 <alt_up_sd_card_find_first+0x78>
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
	short int result = 2;
    a8bc:	00800084 	movi	r2,2
		{
			result = 1;
		}
	}
	return result;
}
    a8c0:	dfc01317 	ldw	ra,76(sp)
    a8c4:	dc001217 	ldw	r16,72(sp)
    a8c8:	dec01404 	addi	sp,sp,80
    a8cc:	f800283a 	ret

0000a8d0 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
    a8d0:	deffe804 	addi	sp,sp,-96
    a8d4:	dd401615 	stw	r21,88(sp)
    a8d8:	dd001515 	stw	r20,84(sp)
    a8dc:	dfc01715 	stw	ra,92(sp)
    a8e0:	dcc01415 	stw	r19,80(sp)
    a8e4:	dc801315 	stw	r18,76(sp)
    a8e8:	dc401215 	stw	r17,72(sp)
    a8ec:	dc001115 	stw	r16,68(sp)
    a8f0:	2029883a 	mov	r20,r4
    a8f4:	282b883a 	mov	r21,r5
	short int file_record_index = -1;

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    a8f8:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    a8fc:	10004f26 	beq	r2,zero,aa3c <alt_up_sd_card_fopen+0x16c>
    a900:	d0a0ff17 	ldw	r2,-31748(gp)
    a904:	10004d26 	beq	r2,zero,aa3c <alt_up_sd_card_fopen+0x16c>
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
    a908:	a009883a 	mov	r4,r20
{
	short int file_record_index = -1;

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
        unsigned int home_directory_cluster = 0;
    a90c:	d8001015 	stw	zero,64(sp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
    a910:	0008e5c0 	call	8e5c <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
    a914:	a009883a 	mov	r4,r20
    a918:	0008eb00 	call	8eb0 <check_file_name_for_FAT16_compliance>
    a91c:	1000021e 	bne	r2,zero,a928 <alt_up_sd_card_fopen+0x58>
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
	short int file_record_index = -1;
    a920:	047fffc4 	movi	r17,-1
    a924:	00004306 	br	aa34 <alt_up_sd_card_fopen+0x164>
        if (check_file_name_for_FAT16_compliance(name))
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
    a928:	d80d883a 	mov	r6,sp
    a92c:	d9401004 	addi	r5,sp,64
    a930:	a009883a 	mov	r4,r20
    a934:	0009d340 	call	9d34 <get_home_directory_cluster_for_file>
    a938:	10004026 	beq	r2,zero,aa3c <alt_up_sd_card_fopen+0x16c>
    a93c:	04800074 	movhi	r18,1
    a940:	94ae9f04 	addi	r18,r18,-17796
    a944:	9005883a 	mov	r2,r18
    a948:	0027883a 	mov	r19,zero
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    a94c:	00c00504 	movi	r3,20
    		{
    			if (active_files[index].in_use == false)
    a950:	11000017 	ldw	r4,0(r2)
    a954:	20000b1e 	bne	r4,zero,a984 <alt_up_sd_card_fopen+0xb4>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
    a958:	982091ba 	slli	r16,r19,6
    a95c:	00c00074 	movhi	r3,1
    a960:	18ee9004 	addi	r3,r3,-17856
    a964:	d9001017 	ldw	r4,64(sp)
    a968:	80e1883a 	add	r16,r16,r3
    a96c:	800d883a 	mov	r6,r16
    a970:	a00b883a 	mov	r5,r20
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    		{
    			if (active_files[index].in_use == false)
    			{
    				file_record_index = index;
    a974:	9823883a 	mov	r17,r19
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
    a978:	0009fec0 	call	9fec <find_file_in_directory>
    a97c:	1000051e 	bne	r2,zero,a994 <alt_up_sd_card_fopen+0xc4>
    a980:	00002106 	br	aa08 <alt_up_sd_card_fopen+0x138>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    a984:	9cc00044 	addi	r19,r19,1
    a988:	10801004 	addi	r2,r2,64
    a98c:	98fff01e 	bne	r19,r3,a950 <_gp+0xffff737c>
    a990:	003fe306 	br	a920 <_gp+0xffff734c>
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
                {
                    if (create)
    a994:	a800291e 	bne	r21,zero,aa3c <alt_up_sd_card_fopen+0x16c>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
    a998:	8080058b 	ldhu	r2,22(r16)
                    active_files[file_record_index].current_sector_in_cluster = 0;
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    a99c:	00c00044 	movi	r3,1
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
                    active_files[file_record_index].current_sector_in_cluster = 0;
    a9a0:	80000815 	stw	zero,32(r16)
                    if (create)
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
    a9a4:	80800715 	stw	r2,28(r16)
                    active_files[file_record_index].current_sector_in_cluster = 0;
                    active_files[file_record_index].current_byte_position = 0;
    a9a8:	80000915 	stw	zero,36(r16)
                    active_files[file_record_index].in_use = true;
    a9ac:	80c00f15 	stw	r3,60(r16)
    				active_files[file_record_index].modified = false;
    a9b0:	80000e15 	stw	zero,56(r16)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
    a9b4:	81400a04 	addi	r5,r16,40
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
    a9b8:	81800b04 	addi	r6,r16,44
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
    a9bc:	0005883a 	mov	r2,zero
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
    a9c0:	84000c04 	addi	r16,r16,48
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
    a9c4:	01000504 	movi	r4,20
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
    a9c8:	98800b26 	beq	r19,r2,a9f8 <alt_up_sd_card_fopen+0x128>
    a9cc:	91c00017 	ldw	r7,0(r18)
    a9d0:	38c0091e 	bne	r7,r3,a9f8 <alt_up_sd_card_fopen+0x128>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
    a9d4:	2a000017 	ldw	r8,0(r5)
    a9d8:	91fffb17 	ldw	r7,-20(r18)
    a9dc:	41c0061e 	bne	r8,r7,a9f8 <alt_up_sd_card_fopen+0x128>
    a9e0:	32000017 	ldw	r8,0(r6)
    a9e4:	91fffc17 	ldw	r7,-16(r18)
    a9e8:	41c0031e 	bne	r8,r7,a9f8 <alt_up_sd_card_fopen+0x128>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
    a9ec:	8200000f 	ldh	r8,0(r16)
    a9f0:	91fffd0f 	ldh	r7,-12(r18)
    a9f4:	41c00e26 	beq	r8,r7,aa30 <alt_up_sd_card_fopen+0x160>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
    a9f8:	10800044 	addi	r2,r2,1
    a9fc:	94801004 	addi	r18,r18,64
    aa00:	113ff11e 	bne	r2,r4,a9c8 <_gp+0xffff73f4>
    aa04:	00000b06 	br	aa34 <alt_up_sd_card_fopen+0x164>
							}
						}
					}

                }
                else if (create)
    aa08:	a83fc526 	beq	r21,zero,a920 <_gp+0xffff734c>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
    aa0c:	d80d883a 	mov	r6,sp
    aa10:	800b883a 	mov	r5,r16
    aa14:	a009883a 	mov	r4,r20
    aa18:	000a3b40 	call	a3b4 <create_file>
    aa1c:	103fc026 	beq	r2,zero,a920 <_gp+0xffff734c>
                    {
                        active_files[file_record_index].in_use = true;
    aa20:	00800044 	movi	r2,1
    aa24:	80800f15 	stw	r2,60(r16)
    					active_files[file_record_index].modified = true;
    aa28:	80800e15 	stw	r2,56(r16)
    aa2c:	00000106 	br	aa34 <alt_up_sd_card_fopen+0x164>
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
    aa30:	047fff84 	movi	r17,-2
    aa34:	8805883a 	mov	r2,r17
    aa38:	00000106 	br	aa40 <alt_up_sd_card_fopen+0x170>
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
	short int file_record_index = -1;
    aa3c:	00bfffc4 	movi	r2,-1
    		}
        }
	}

	return file_record_index;
}
    aa40:	dfc01717 	ldw	ra,92(sp)
    aa44:	dd401617 	ldw	r21,88(sp)
    aa48:	dd001517 	ldw	r20,84(sp)
    aa4c:	dcc01417 	ldw	r19,80(sp)
    aa50:	dc801317 	ldw	r18,76(sp)
    aa54:	dc401217 	ldw	r17,72(sp)
    aa58:	dc001117 	ldw	r16,68(sp)
    aa5c:	dec01804 	addi	sp,sp,96
    aa60:	f800283a 	ret

0000aa64 <alt_up_sd_card_set_attributes>:

void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    aa64:	20bfffcc 	andi	r2,r4,65535
    aa68:	00c004c4 	movi	r3,19
    aa6c:	18800a36 	bltu	r3,r2,aa98 <alt_up_sd_card_set_attributes+0x34>
    {
        if (active_files[file_handle].in_use)
    aa70:	213fffcc 	andi	r4,r4,65535
    aa74:	2120001c 	xori	r4,r4,32768
    aa78:	21200004 	addi	r4,r4,-32768
    aa7c:	200891ba 	slli	r4,r4,6
    aa80:	00800074 	movhi	r2,1
    aa84:	10ae9004 	addi	r2,r2,-17856
    aa88:	1109883a 	add	r4,r2,r4
    aa8c:	20800f17 	ldw	r2,60(r4)
    aa90:	10000126 	beq	r2,zero,aa98 <alt_up_sd_card_set_attributes+0x34>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
    aa94:	214002c5 	stb	r5,11(r4)
    aa98:	f800283a 	ret

0000aa9c <alt_up_sd_card_get_attributes>:
short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
	short int result = -1;
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    aa9c:	20bfffcc 	andi	r2,r4,65535
    aaa0:	00c004c4 	movi	r3,19
    aaa4:	18800b36 	bltu	r3,r2,aad4 <alt_up_sd_card_get_attributes+0x38>
    {
        if (active_files[file_handle].in_use)
    aaa8:	213fffcc 	andi	r4,r4,65535
    aaac:	2120001c 	xori	r4,r4,32768
    aab0:	21200004 	addi	r4,r4,-32768
    aab4:	200891ba 	slli	r4,r4,6
    aab8:	00800074 	movhi	r2,1
    aabc:	10ae9004 	addi	r2,r2,-17856
    aac0:	1109883a 	add	r4,r2,r4
    aac4:	20800f17 	ldw	r2,60(r4)
    aac8:	10000226 	beq	r2,zero,aad4 <alt_up_sd_card_get_attributes+0x38>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
    aacc:	208002c3 	ldbu	r2,11(r4)
    aad0:	f800283a 	ret

short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
	short int result = -1;
    aad4:	00bfffc4 	movi	r2,-1
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
		}
	}
	return result;
}
    aad8:	f800283a 	ret

0000aadc <alt_up_sd_card_read>:
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    aadc:	20bfffcc 	andi	r2,r4,65535
    aae0:	00c004c4 	movi	r3,19
    aae4:	18805036 	bltu	r3,r2,ac28 <alt_up_sd_card_read+0x14c>
    {
        if (active_files[file_handle].in_use)
    aae8:	213fffcc 	andi	r4,r4,65535
    aaec:	2120001c 	xori	r4,r4,32768
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    aaf0:	defff504 	addi	sp,sp,-44
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    aaf4:	21200004 	addi	r4,r4,-32768
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    aaf8:	dc800315 	stw	r18,12(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    aafc:	202491ba 	slli	r18,r4,6
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    ab00:	dc000115 	stw	r16,4(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    ab04:	04000074 	movhi	r16,1
    ab08:	842e9004 	addi	r16,r16,-17856
    ab0c:	8485883a 	add	r2,r16,r18
    ab10:	10c00f17 	ldw	r3,60(r2)
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    ab14:	dfc00a15 	stw	ra,40(sp)
    ab18:	df000915 	stw	fp,36(sp)
    ab1c:	ddc00815 	stw	r23,32(sp)
    ab20:	dd800715 	stw	r22,28(sp)
    ab24:	dd400615 	stw	r21,24(sp)
    ab28:	dd000515 	stw	r20,20(sp)
    ab2c:	dcc00415 	stw	r19,16(sp)
    ab30:	dc400215 	stw	r17,8(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    ab34:	18003e26 	beq	r3,zero,ac30 <alt_up_sd_card_read+0x154>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
    ab38:	15400917 	ldw	r21,36(r2)
    ab3c:	10c00617 	ldw	r3,24(r2)
    ab40:	a8c03b2e 	bgeu	r21,r3,ac30 <alt_up_sd_card_read+0x154>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ab44:	05800074 	movhi	r22,1
    ab48:	15000704 	addi	r20,r2,28
    ab4c:	b5ae7b04 	addi	r22,r22,-17940
    ab50:	a7000017 	ldw	fp,0(r20)
    ab54:	b5c00383 	ldbu	r23,14(r22)
                                  active_files[file_handle].current_sector_in_cluster;
    ab58:	14400804 	addi	r17,r2,32
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ab5c:	e13fff84 	addi	r4,fp,-2
    ab60:	b80b883a 	mov	r5,r23
    ab64:	0008c600 	call	8c60 <__mulsi3>
                                  active_files[file_handle].current_sector_in_cluster;
    ab68:	8cc00017 	ldw	r19,0(r17)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ab6c:	b1001417 	ldw	r4,80(r22)
    ab70:	9909883a 	add	r4,r19,r4
    ab74:	1109883a 	add	r4,r2,r4
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
    ab78:	a8001826 	beq	r21,zero,abdc <alt_up_sd_card_read+0x100>
    ab7c:	ad407fcc 	andi	r21,r21,511
    ab80:	a800161e 	bne	r21,zero,abdc <alt_up_sd_card_read+0x100>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
    ab84:	bdffffc4 	addi	r23,r23,-1
    ab88:	9dc0111e 	bne	r19,r23,abd0 <alt_up_sd_card_read+0xf4>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
    ab8c:	d80b883a 	mov	r5,sp
    ab90:	e009883a 	mov	r4,fp
    ab94:	00093f40 	call	93f4 <get_cluster_flag>
    ab98:	10002126 	beq	r2,zero,ac20 <alt_up_sd_card_read+0x144>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
    ab9c:	d900000b 	ldhu	r4,0(sp)
    aba0:	00bffe14 	movui	r2,65528
    aba4:	20fffe0c 	andi	r3,r4,65528
    aba8:	18802126 	beq	r3,r2,ac30 <alt_up_sd_card_read+0x154>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    abac:	b1400383 	ldbu	r5,14(r22)
                                /* End of file */
                                return -1;
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
    abb0:	213fffcc 	andi	r4,r4,65535
    abb4:	a1000015 	stw	r4,0(r20)
								active_files[file_handle].current_sector_in_cluster = 0;
    abb8:	88000015 	stw	zero,0(r17)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    abbc:	213fff84 	addi	r4,r4,-2
    abc0:	0008c600 	call	8c60 <__mulsi3>
    abc4:	b1001417 	ldw	r4,80(r22)
    abc8:	1109883a 	add	r4,r2,r4
    abcc:	00000306 	br	abdc <alt_up_sd_card_read+0x100>
                            return -2;
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
    abd0:	9cc00044 	addi	r19,r19,1
    abd4:	8cc00015 	stw	r19,0(r17)
                        data_sector = data_sector + 1;
    abd8:	21000044 	addi	r4,r4,1
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
    abdc:	d160f817 	ldw	r5,-31776(gp)
    abe0:	d0a0f417 	ldw	r2,-31792(gp)
    abe4:	2147883a 	add	r3,r4,r5
    abe8:	18800b1e 	bne	r3,r2,ac18 <alt_up_sd_card_read+0x13c>
                    {
						return -2;
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
    abec:	84a1883a 	add	r16,r16,r18
    abf0:	84000904 	addi	r16,r16,36
    abf4:	80c00017 	ldw	r3,0(r16)
    abf8:	d120f917 	ldw	r4,-31772(gp)
    abfc:	18807fcc 	andi	r2,r3,511
    ac00:	2085883a 	add	r2,r4,r2
    ac04:	10800023 	ldbuio	r2,0(r2)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
    ac08:	18c00044 	addi	r3,r3,1
    ac0c:	80c00015 	stw	r3,0(r16)
                    {
						return -2;
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
    ac10:	10803fcc 	andi	r2,r2,255
    ac14:	00000706 	br	ac34 <alt_up_sd_card_read+0x158>
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
    ac18:	00093540 	call	9354 <Read_Sector_Data>
    ac1c:	103ff31e 	bne	r2,zero,abec <_gp+0xffff7618>
                    {
						return -2;
    ac20:	00bfff84 	movi	r2,-2
    ac24:	00000306 	br	ac34 <alt_up_sd_card_read+0x158>

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    ac28:	00bfffc4 	movi	r2,-1
            }
        }
    }
    
    return ch;
}
    ac2c:	f800283a 	ret

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    ac30:	00bfffc4 	movi	r2,-1
            }
        }
    }
    
    return ch;
}
    ac34:	dfc00a17 	ldw	ra,40(sp)
    ac38:	df000917 	ldw	fp,36(sp)
    ac3c:	ddc00817 	ldw	r23,32(sp)
    ac40:	dd800717 	ldw	r22,28(sp)
    ac44:	dd400617 	ldw	r21,24(sp)
    ac48:	dd000517 	ldw	r20,20(sp)
    ac4c:	dcc00417 	ldw	r19,16(sp)
    ac50:	dc800317 	ldw	r18,12(sp)
    ac54:	dc400217 	ldw	r17,8(sp)
    ac58:	dc000117 	ldw	r16,4(sp)
    ac5c:	dec00b04 	addi	sp,sp,44
    ac60:	f800283a 	ret

0000ac64 <alt_up_sd_card_write>:
bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    ac64:	20bfffcc 	andi	r2,r4,65535
    ac68:	00c004c4 	movi	r3,19
    ac6c:	1880a536 	bltu	r3,r2,af04 <alt_up_sd_card_write+0x2a0>
    {
        if (active_files[file_handle].in_use)
    ac70:	213fffcc 	andi	r4,r4,65535
    ac74:	2120001c 	xori	r4,r4,32768
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    ac78:	defff104 	addi	sp,sp,-60
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    ac7c:	21200004 	addi	r4,r4,-32768
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    ac80:	dc400615 	stw	r17,24(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    ac84:	202291ba 	slli	r17,r4,6
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    ac88:	dd000915 	stw	r20,36(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    ac8c:	05000074 	movhi	r20,1
    ac90:	a52e9004 	addi	r20,r20,-17856
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    ac94:	df000d15 	stw	fp,52(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    ac98:	a479883a 	add	fp,r20,r17
    ac9c:	e0800f17 	ldw	r2,60(fp)
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    aca0:	dfc00e15 	stw	ra,56(sp)
    aca4:	ddc00c15 	stw	r23,48(sp)
    aca8:	dd800b15 	stw	r22,44(sp)
    acac:	dd400a15 	stw	r21,40(sp)
    acb0:	dcc00815 	stw	r19,32(sp)
    acb4:	dc800715 	stw	r18,28(sp)
    acb8:	dc000515 	stw	r16,20(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
    acbc:	1000021e 	bne	r2,zero,acc8 <alt_up_sd_card_write+0x64>


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    acc0:	0005883a 	mov	r2,zero
    acc4:	00008306 	br	aed4 <alt_up_sd_card_write+0x270>
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    acc8:	05000074 	movhi	r20,1
    accc:	a52e7b04 	addi	r20,r20,-17940
    acd0:	e5800704 	addi	r22,fp,28
    acd4:	b2000017 	ldw	r8,0(r22)
    acd8:	a4c00383 	ldbu	r19,14(r20)
    acdc:	d9400115 	stw	r5,4(sp)
    ace0:	413fff84 	addi	r4,r8,-2
                              active_files[file_handle].current_sector_in_cluster;
    ace4:	e5400804 	addi	r21,fp,32
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ace8:	980b883a 	mov	r5,r19
                              active_files[file_handle].current_sector_in_cluster;
    acec:	adc00017 	ldw	r23,0(r21)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    acf0:	da000415 	stw	r8,16(sp)
    acf4:	0008c600 	call	8c60 <__mulsi3>
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    acf8:	e1800917 	ldw	r6,36(fp)
    acfc:	a1c0030b 	ldhu	r7,12(r20)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ad00:	a4001417 	ldw	r16,80(r20)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    ad04:	3009883a 	mov	r4,r6
    ad08:	380b883a 	mov	r5,r7
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ad0c:	bc21883a 	add	r16,r23,r16
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    ad10:	d9800215 	stw	r6,8(sp)
    ad14:	d9c00315 	stw	r7,12(sp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ad18:	1421883a 	add	r16,r2,r16
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
    ad1c:	000840c0 	call	840c <__umodsi3>
    ad20:	1025883a 	mov	r18,r2

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
    ad24:	d9800217 	ldw	r6,8(sp)
    ad28:	e0800617 	ldw	r2,24(fp)
    ad2c:	d9c00317 	ldw	r7,12(sp)
    ad30:	a039883a 	mov	fp,r20
    ad34:	da000417 	ldw	r8,16(sp)
    ad38:	3080192e 	bgeu	r6,r2,ada0 <alt_up_sd_card_write+0x13c>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
    ad3c:	30004526 	beq	r6,zero,ae54 <alt_up_sd_card_write+0x1f0>
    ad40:	90bfffcc 	andi	r2,r18,65535
    ad44:	10a0001c 	xori	r2,r2,32768
    ad48:	10a00004 	addi	r2,r2,-32768
    ad4c:	1000411e 	bne	r2,zero,ae54 <alt_up_sd_card_write+0x1f0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
    ad50:	9cffffc4 	addi	r19,r19,-1
    ad54:	bcc00e1e 	bne	r23,r19,ad90 <alt_up_sd_card_write+0x12c>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
    ad58:	d80b883a 	mov	r5,sp
    ad5c:	4009883a 	mov	r4,r8
    ad60:	00093f40 	call	93f4 <get_cluster_flag>
    ad64:	10005b26 	beq	r2,zero,aed4 <alt_up_sd_card_write+0x270>
                        {
                            if (next_cluster < 0x0000fff8)
    ad68:	d900000b 	ldhu	r4,0(sp)
    ad6c:	00bffdd4 	movui	r2,65527
    ad70:	11003836 	bltu	r2,r4,ae54 <alt_up_sd_card_write+0x1f0>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ad74:	a1400383 	ldbu	r5,14(r20)
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
    ad78:	b1000015 	stw	r4,0(r22)
								active_files[file_handle].current_sector_in_cluster = 0;
    ad7c:	a8000015 	stw	zero,0(r21)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ad80:	213fff84 	addi	r4,r4,-2
    ad84:	0008c600 	call	8c60 <__mulsi3>
    ad88:	a4001417 	ldw	r16,80(r20)
    ad8c:	00003006 	br	ae50 <alt_up_sd_card_write+0x1ec>
                            return false;
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
    ad90:	b8c00044 	addi	r3,r23,1
    ad94:	a8c00015 	stw	r3,0(r21)
                        data_sector = data_sector + 1;
    ad98:	84000044 	addi	r16,r16,1
    ad9c:	00002d06 	br	ae54 <alt_up_sd_card_write+0x1f0>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
    ada0:	30002c26 	beq	r6,zero,ae54 <alt_up_sd_card_write+0x1f0>
    ada4:	90bfffcc 	andi	r2,r18,65535
    ada8:	10a0001c 	xori	r2,r2,32768
    adac:	10a00004 	addi	r2,r2,-32768
    adb0:	1000281e 	bne	r2,zero,ae54 <alt_up_sd_card_write+0x1f0>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
    adb4:	9cffffc4 	addi	r19,r19,-1
    adb8:	bcc0171e 	bne	r23,r19,ae18 <alt_up_sd_card_write+0x1b4>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
    adbc:	d809883a 	mov	r4,sp
    adc0:	00098b40 	call	98b4 <find_first_empty_cluster>
    adc4:	10004326 	beq	r2,zero,aed4 <alt_up_sd_card_write+0x270>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
    adc8:	d940000f 	ldh	r5,0(sp)
    adcc:	b1000017 	ldw	r4,0(r22)
    add0:	01800044 	movi	r6,1
    add4:	00094740 	call	9474 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
    add8:	d9000017 	ldw	r4,0(sp)
    addc:	01800044 	movi	r6,1
    ade0:	017fffc4 	movi	r5,-1
    ade4:	00094740 	call	9474 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
    ade8:	d940000f 	ldh	r5,0(sp)
    adec:	b1000017 	ldw	r4,0(r22)
    adf0:	000d883a 	mov	r6,zero
    adf4:	00094740 	call	9474 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
    adf8:	d9000017 	ldw	r4,0(sp)
    adfc:	000d883a 	mov	r6,zero
    ae00:	017fffc4 	movi	r5,-1
    ae04:	00094740 	call	9474 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
    ae08:	d8800017 	ldw	r2,0(sp)
							active_files[file_handle].current_sector_in_cluster = 0;
    ae0c:	a8000015 	stw	zero,0(r21)
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
							mark_cluster(cluster_number, 0xffff, true);
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
							mark_cluster(cluster_number, 0xffff, false);
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
    ae10:	b0800015 	stw	r2,0(r22)
    ae14:	00000406 	br	ae28 <alt_up_sd_card_write+0x1c4>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
    ae18:	380b883a 	mov	r5,r7
    ae1c:	3009883a 	mov	r4,r6
    ae20:	00083a80 	call	83a8 <__udivsi3>
    ae24:	a8800015 	stw	r2,0(r21)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
    ae28:	00800074 	movhi	r2,1
    ae2c:	10ae9004 	addi	r2,r2,-17856
    ae30:	1467883a 	add	r19,r2,r17
    ae34:	99000717 	ldw	r4,28(r19)
    ae38:	e1400383 	ldbu	r5,14(fp)
    ae3c:	213fff84 	addi	r4,r4,-2
    ae40:	0008c600 	call	8c60 <__mulsi3>
    ae44:	98c00817 	ldw	r3,32(r19)
    ae48:	e4001417 	ldw	r16,80(fp)
    ae4c:	80e1883a 	add	r16,r16,r3
    ae50:	1421883a 	add	r16,r2,r16
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
    ae54:	d160f817 	ldw	r5,-31776(gp)
    ae58:	d0a0f417 	ldw	r2,-31792(gp)
    ae5c:	8147883a 	add	r3,r16,r5
    ae60:	1880161e 	bne	r3,r2,aebc <alt_up_sd_card_write+0x258>
                {
					return false;
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
    ae64:	d0a0f917 	ldw	r2,-31772(gp)
    ae68:	94bfffcc 	andi	r18,r18,65535
    ae6c:	94a0001c 	xori	r18,r18,32768
    ae70:	94a00004 	addi	r18,r18,-32768
    ae74:	14a5883a 	add	r18,r2,r18
    ae78:	d8800117 	ldw	r2,4(sp)
    ae7c:	90800025 	stbio	r2,0(r18)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
    ae80:	00800074 	movhi	r2,1
    ae84:	10ae9004 	addi	r2,r2,-17856
    ae88:	1463883a 	add	r17,r2,r17
    ae8c:	88800904 	addi	r2,r17,36
    ae90:	10c00017 	ldw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
    ae94:	89400604 	addi	r5,r17,24
    ae98:	01000044 	movi	r4,1
					return false;
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
    ae9c:	18c00044 	addi	r3,r3,1
    aea0:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
    aea4:	28800017 	ldw	r2,0(r5)
    aea8:	18800836 	bltu	r3,r2,aecc <alt_up_sd_card_write+0x268>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
    aeac:	10800044 	addi	r2,r2,1
    aeb0:	28800015 	stw	r2,0(r5)
				active_files[file_handle].modified = true;
    aeb4:	89000e15 	stw	r4,56(r17)
    aeb8:	00000406 	br	aecc <alt_up_sd_card_write+0x268>
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
    aebc:	8009883a 	mov	r4,r16
    aec0:	00093540 	call	9354 <Read_Sector_Data>
    aec4:	103fe71e 	bne	r2,zero,ae64 <_gp+0xffff7890>
    aec8:	003f7d06 	br	acc0 <_gp+0xffff76ec>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
				active_files[file_handle].modified = true;
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
    aecc:	d120f515 	stw	r4,-31788(gp)
			result = true;
    aed0:	00800044 	movi	r2,1
		}
    }
    
    return result;
}
    aed4:	dfc00e17 	ldw	ra,56(sp)
    aed8:	df000d17 	ldw	fp,52(sp)
    aedc:	ddc00c17 	ldw	r23,48(sp)
    aee0:	dd800b17 	ldw	r22,44(sp)
    aee4:	dd400a17 	ldw	r21,40(sp)
    aee8:	dd000917 	ldw	r20,36(sp)
    aeec:	dcc00817 	ldw	r19,32(sp)
    aef0:	dc800717 	ldw	r18,28(sp)
    aef4:	dc400617 	ldw	r17,24(sp)
    aef8:	dc000517 	ldw	r16,20(sp)
    aefc:	dec00f04 	addi	sp,sp,60
    af00:	f800283a 	ret


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    af04:	0005883a 	mov	r2,zero
			result = true;
		}
    }
    
    return result;
}
    af08:	f800283a 	ret

0000af0c <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
    af0c:	defffc04 	addi	sp,sp,-16
    af10:	dc000015 	stw	r16,0(sp)
    af14:	dfc00315 	stw	ra,12(sp)
    af18:	dc800215 	stw	r18,8(sp)
    af1c:	dc400115 	stw	r17,4(sp)
    af20:	2021883a 	mov	r16,r4
    bool result = false;
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    af24:	00092500 	call	9250 <alt_up_sd_card_is_Present>
    af28:	10002726 	beq	r2,zero,afc8 <alt_up_sd_card_fclose+0xbc>
    af2c:	d0a0ff17 	ldw	r2,-31748(gp)
    af30:	10002526 	beq	r2,zero,afc8 <alt_up_sd_card_fclose+0xbc>
    {
        if (active_files[file_handle].in_use) 
    af34:	813fffcc 	andi	r4,r16,65535
    af38:	2120001c 	xori	r4,r4,32768
    af3c:	21200004 	addi	r4,r4,-32768
    af40:	202091ba 	slli	r16,r4,6
    af44:	04800074 	movhi	r18,1
    af48:	94ae9004 	addi	r18,r18,-17856
    af4c:	9407883a 	add	r3,r18,r16
    af50:	18800f17 	ldw	r2,60(r3)
    af54:	10001c26 	beq	r2,zero,afc8 <alt_up_sd_card_fclose+0xbc>
        {
			if (active_files[file_handle].modified)
    af58:	18800e17 	ldw	r2,56(r3)
    af5c:	10001626 	beq	r2,zero,afb8 <alt_up_sd_card_fclose+0xac>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
				if (active_files[file_handle].file_record_cluster == 0)
    af60:	19800a17 	ldw	r6,40(r3)
    af64:	01400074 	movhi	r5,1
    {
        if (active_files[file_handle].in_use) 
        {
			if (active_files[file_handle].modified)
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
    af68:	19000b17 	ldw	r4,44(r3)
    af6c:	296e7b04 	addi	r5,r5,-17940
				if (active_files[file_handle].file_record_cluster == 0)
    af70:	3000031e 	bne	r6,zero,af80 <alt_up_sd_card_fclose+0x74>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
    af74:	28c01317 	ldw	r3,76(r5)
    af78:	20c9883a 	add	r4,r4,r3
    af7c:	00000606 	br	af98 <alt_up_sd_card_fclose+0x8c>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
    af80:	28c01417 	ldw	r3,80(r5)
    af84:	29400383 	ldbu	r5,14(r5)
    af88:	20e3883a 	add	r17,r4,r3
    af8c:	313fff84 	addi	r4,r6,-2
    af90:	0008c600 	call	8c60 <__mulsi3>
    af94:	1449883a 	add	r4,r2,r17
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
    af98:	d160f817 	ldw	r5,-31776(gp)
    af9c:	00093540 	call	9354 <Read_Sector_Data>
    afa0:	10000526 	beq	r2,zero,afb8 <alt_up_sd_card_fclose+0xac>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
    afa4:	940b883a 	add	r5,r18,r16
    afa8:	29000c0f 	ldh	r4,48(r5)
    afac:	000a2500 	call	a250 <Write_File_Record_At_Offset>
    afb0:	10000126 	beq	r2,zero,afb8 <alt_up_sd_card_fclose+0xac>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
    afb4:	00093380 	call	9338 <Save_Modified_Sector>
					}
				}
			}
			active_files[file_handle].in_use = false;
    afb8:	9421883a 	add	r16,r18,r16
    afbc:	80000f15 	stw	zero,60(r16)
			result = true;
    afc0:	00800044 	movi	r2,1
    afc4:	00000106 	br	afcc <alt_up_sd_card_fclose+0xc0>


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
    bool result = false;
    afc8:	0005883a 	mov	r2,zero
			result = true;
        }
    }
    
    return result;
}
    afcc:	dfc00317 	ldw	ra,12(sp)
    afd0:	dc800217 	ldw	r18,8(sp)
    afd4:	dc400117 	ldw	r17,4(sp)
    afd8:	dc000017 	ldw	r16,0(sp)
    afdc:	dec00404 	addi	sp,sp,16
    afe0:	f800283a 	ret

0000afe4 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
    afe4:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
    afe8:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
    afec:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
    aff0:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
    aff4:	2980072e 	bgeu	r5,r6,b014 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
    aff8:	38c00037 	ldwio	r3,0(r7)
    affc:	18ffffec 	andhi	r3,r3,65535
    b000:	183ffc26 	beq	r3,zero,aff4 <_gp+0xffff7a20>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
    b004:	28c00007 	ldb	r3,0(r5)
    b008:	20c00035 	stwio	r3,0(r4)
    b00c:	29400044 	addi	r5,r5,1
    b010:	003ff806 	br	aff4 <_gp+0xffff7a20>

  return count;
}
    b014:	f800283a 	ret

0000b018 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
    b018:	f800283a 	ret

0000b01c <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
    b01c:	3005883a 	mov	r2,r6
    b020:	f800283a 	ret

0000b024 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
    b024:	20000226 	beq	r4,zero,b030 <alt_dev_llist_insert+0xc>
    b028:	20800217 	ldw	r2,8(r4)
    b02c:	1000101e 	bne	r2,zero,b070 <alt_dev_llist_insert+0x4c>
    b030:	d0a00817 	ldw	r2,-32736(gp)
    b034:	10000926 	beq	r2,zero,b05c <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
    b038:	deffff04 	addi	sp,sp,-4
    b03c:	dfc00015 	stw	ra,0(sp)
    b040:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
    b044:	00c00584 	movi	r3,22
    b048:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
    b04c:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
    b050:	dfc00017 	ldw	ra,0(sp)
    b054:	dec00104 	addi	sp,sp,4
    b058:	f800283a 	ret
    b05c:	d0a0f004 	addi	r2,gp,-31808
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
    b060:	00c00584 	movi	r3,22
    b064:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
    b068:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
    b06c:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
    b070:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
    b074:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
    b078:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
    b07c:	28800017 	ldw	r2,0(r5)
    b080:	11000115 	stw	r4,4(r2)
  list->next           = entry;
    b084:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
    b088:	0005883a 	mov	r2,zero
    b08c:	f800283a 	ret

0000b090 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
    b090:	defffb04 	addi	sp,sp,-20
    b094:	dcc00315 	stw	r19,12(sp)
    b098:	dc800215 	stw	r18,8(sp)
    b09c:	dc400115 	stw	r17,4(sp)
    b0a0:	dc000015 	stw	r16,0(sp)
    b0a4:	dfc00415 	stw	ra,16(sp)
    b0a8:	2027883a 	mov	r19,r4
    b0ac:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
    b0b0:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
    b0b4:	00085800 	call	8580 <strlen>
    b0b8:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
    b0bc:	84400726 	beq	r16,r17,b0dc <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
    b0c0:	81000217 	ldw	r4,8(r16)
    b0c4:	900d883a 	mov	r6,r18
    b0c8:	980b883a 	mov	r5,r19
    b0cc:	000b1100 	call	b110 <memcmp>
    b0d0:	10000426 	beq	r2,zero,b0e4 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
    b0d4:	84000017 	ldw	r16,0(r16)
    b0d8:	003ff806 	br	b0bc <_gp+0xffff7ae8>
  }
  
  /* No match found */
  
  return NULL;
    b0dc:	0005883a 	mov	r2,zero
    b0e0:	00000106 	br	b0e8 <alt_find_dev+0x58>
    b0e4:	8005883a 	mov	r2,r16
}
    b0e8:	dfc00417 	ldw	ra,16(sp)
    b0ec:	dcc00317 	ldw	r19,12(sp)
    b0f0:	dc800217 	ldw	r18,8(sp)
    b0f4:	dc400117 	ldw	r17,4(sp)
    b0f8:	dc000017 	ldw	r16,0(sp)
    b0fc:	dec00504 	addi	sp,sp,20
    b100:	f800283a 	ret

0000b104 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
    b104:	f800283a 	ret

0000b108 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
    b108:	000170fa 	wrctl	ienable,zero
    b10c:	f800283a 	ret

0000b110 <memcmp>:
    b110:	218d883a 	add	r6,r4,r6
    b114:	21800826 	beq	r4,r6,b138 <memcmp+0x28>
    b118:	20800003 	ldbu	r2,0(r4)
    b11c:	28c00003 	ldbu	r3,0(r5)
    b120:	10c00226 	beq	r2,r3,b12c <memcmp+0x1c>
    b124:	10c5c83a 	sub	r2,r2,r3
    b128:	f800283a 	ret
    b12c:	21000044 	addi	r4,r4,1
    b130:	29400044 	addi	r5,r5,1
    b134:	003ff706 	br	b114 <_gp+0xffff7b40>
    b138:	0005883a 	mov	r2,zero
    b13c:	f800283a 	ret

0000b140 <memcpy>:
    b140:	2005883a 	mov	r2,r4
    b144:	2007883a 	mov	r3,r4
    b148:	218d883a 	add	r6,r4,r6
    b14c:	19800526 	beq	r3,r6,b164 <memcpy+0x24>
    b150:	29000003 	ldbu	r4,0(r5)
    b154:	18c00044 	addi	r3,r3,1
    b158:	29400044 	addi	r5,r5,1
    b15c:	193fffc5 	stb	r4,-1(r3)
    b160:	003ffa06 	br	b14c <_gp+0xffff7b78>
    b164:	f800283a 	ret
