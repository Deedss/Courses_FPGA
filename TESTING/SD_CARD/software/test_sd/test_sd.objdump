
test_sd.elf:     file format elf32-littlenios2
test_sd.elf
architecture: nios2:r1, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x00010020

Program Header:
    LOAD off    0x00001000 vaddr 0x00010000 paddr 0x00010000 align 2**12
         filesz 0x00000020 memsz 0x00000020 flags r-x
    LOAD off    0x00001020 vaddr 0x00010020 paddr 0x00010020 align 2**12
         filesz 0x0000310c memsz 0x0000310c flags r-x
    LOAD off    0x0000412c vaddr 0x0001312c paddr 0x000134b0 align 2**12
         filesz 0x00000384 memsz 0x00000384 flags rw-
    LOAD off    0x00004834 vaddr 0x00013834 paddr 0x00013834 align 2**12
         filesz 0x00000000 memsz 0x000005b4 flags rw-

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000020  00010000  00010000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   00000000  00010020  00010020  000044b0  2**0
                  CONTENTS
  2 .text         00003024  00010020  00010020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       000000e8  00013044  00013044  00004044  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       00000384  0001312c  000134b0  0000412c  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          000005b4  00013834  00013834  00004834  2**2
                  ALLOC, SMALL_DATA
  6 .onchip_memory2_0 00000000  00013de8  00013de8  000044b0  2**0
                  CONTENTS
  7 .comment      00000023  00000000  00000000  000044b0  2**0
                  CONTENTS, READONLY
  8 .debug_aranges 000003b0  00000000  00000000  000044d8  2**3
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_info   00007052  00000000  00000000  00004888  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_abbrev 00001e0f  00000000  00000000  0000b8da  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   00002760  00000000  00000000  0000d6e9  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_frame  00000a10  00000000  00000000  0000fe4c  2**2
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00001de1  00000000  00000000  0001085c  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_loc    000032ee  00000000  00000000  0001263d  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_alt_sim_info 00000040  00000000  00000000  0001592c  2**2
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_ranges 00000520  00000000  00000000  00015970  2**3
                  CONTENTS, READONLY, DEBUGGING
 17 .thread_model 00000003  00000000  00000000  0001794e  2**0
                  CONTENTS, READONLY
 18 .cpu          0000000c  00000000  00000000  00017951  2**0
                  CONTENTS, READONLY
 19 .qsys         00000001  00000000  00000000  0001795d  2**0
                  CONTENTS, READONLY
 20 .simulation_enabled 00000001  00000000  00000000  0001795e  2**0
                  CONTENTS, READONLY
 21 .stderr_dev   0000000b  00000000  00000000  0001795f  2**0
                  CONTENTS, READONLY
 22 .stdin_dev    0000000b  00000000  00000000  0001796a  2**0
                  CONTENTS, READONLY
 23 .stdout_dev   0000000b  00000000  00000000  00017975  2**0
                  CONTENTS, READONLY
 24 .sopc_system_name 00000004  00000000  00000000  00017980  2**0
                  CONTENTS, READONLY
 25 .quartus_project_dir 00000044  00000000  00000000  00017984  2**0
                  CONTENTS, READONLY
 26 .jdi          00004b2d  00000000  00000000  000179c8  2**0
                  CONTENTS, READONLY
 27 .sopcinfo     000315d3  00000000  00000000  0001c4f5  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00010000 l    d  .entry	00000000 .entry
00010020 l    d  .exceptions	00000000 .exceptions
00010020 l    d  .text	00000000 .text
00013044 l    d  .rodata	00000000 .rodata
0001312c l    d  .rwdata	00000000 .rwdata
00013834 l    d  .bss	00000000 .bss
00013de8 l    d  .onchip_memory2_0	00000000 .onchip_memory2_0
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 ../test_sd_bsp//obj/HAL/src/crt0.o
00010058 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 hello_world_small.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 vfprintf.c
00010270 l     F .text	0000006c print_repeat
00000000 l    df *ABS*	00000000 fvwrite_small_dev.c
00000000 l    df *ABS*	00000000 impure.c
0001332c l     O .rwdata	000000e0 impure_data
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
00000000 l    df *ABS*	00000000 lib2-mul.c
00000000 l    df *ABS*	00000000 alt_load.c
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 alt_write.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0001340c l     O .rwdata	0000002c Altera_UP_SD_Card_Avalon_Interface_0
00000000 l    df *ABS*	00000000 Altera_UP_SD_Card_Avalon_Interface.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 alt_dcache_flush_all.c
00000000 l    df *ABS*	00000000 alt_dev.c
00012ef8 l     F .text	00000008 alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_icache_flush_all.c
00000000 l    df *ABS*	00000000 altera_nios2_gen2_irq.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 memcpy.c
00013874 g     O .bss	00000004 aux_status_register
00010bf0 g     F .text	0000002c alt_main
000101c0 g     F .text	00000080 _puts_r
000134b0 g       *ABS*	00000000 __flash_rwdata_start
00011354 g     F .text	00000108 Check_for_Master_Boot_Record
00012d60 g     F .text	000000d8 alt_up_sd_card_fclose
00010174 g     F .text	0000004c printf
00013850 g     O .bss	00000004 current_sector_modified
000110a4 g     F .text	00000068 alt_up_sd_card_is_Present
0001118c g     F .text	0000001c Save_Modified_Sector
00012fe4 g     F .text	00000008 altera_nios2_gen2_irq_init
00010000 g     F .entry	0000000c __reset
00013858 g     O .bss	00000004 fat_partition_size_in_512_byte_sectors
00010020 g       *ABS*	00000000 __flash_exceptions_start
00013838 g     O .bss	00000004 errno
00013840 g     O .bss	00000004 alt_argv
0001b490 g       *ABS*	00000000 _gp
00010c1c g     F .text	00000004 usleep
00012724 g     F .text	00000194 alt_up_sd_card_fopen
0001269c g     F .text	00000088 alt_up_sd_card_find_first
00013864 g     O .bss	00000004 command_argument_register
00013438 g     O .rwdata	00000030 alt_fd_list
00011948 g     F .text	000000c8 find_first_empty_record_in_root_directory
00012f6c g     F .text	00000074 alt_find_dev
0001301c g     F .text	00000028 memcpy
00010240 g     F .text	00000014 puts
00011708 g     F .text	000000a4 find_first_empty_cluster
0001103c g     F .text	00000068 alt_up_sd_card_open_dev
00010138 g     F .text	0000003c _printf_r
00010000 g       *ABS*	00000000 __alt_mem_onchip_memory2_0
00010a2c g     F .text	00000064 .hidden __udivsi3
00010de0 g     F .text	00000058 get_dir_divider_location
00010cb0 g     F .text	00000054 filename_to_upper_case
000128b8 g     F .text	00000038 alt_up_sd_card_set_attributes
00011a10 g     F .text	00000178 Read_File_Record_At_Offset
00013498 g     O .rwdata	00000004 alt_max_fd
00011e40 g     F .text	00000264 find_file_in_directory
00012428 g     F .text	00000050 alt_up_sd_card_is_FAT16
00013490 g     O .rwdata	00000004 _global_impure_ptr
00011b88 g     F .text	000002b8 get_home_directory_cluster_for_file
00013de8 g       *ABS*	00000000 __bss_end
0001384c g     O .bss	00000004 current_sector_index
000112c8 g     F .text	0000008c mark_cluster
00013468 g     O .rwdata	00000028 alt_dev_null
00010f24 g     F .text	00000098 convert_filename_to_name_extension
00012ef4 g     F .text	00000004 alt_dcache_flush_all
00013878 g     O .bss	00000004 is_sd_card_formated_as_FAT16
000117ac g     F .text	0000019c find_first_empty_record_in_a_subdirectory
000134b0 g       *ABS*	00000000 __ram_rwdata_end
0001349c g     O .rwdata	00000008 alt_dev_list
00010c20 g     F .text	00000060 write
00013854 g     O .bss	00000004 device_pointer
0001312c g       *ABS*	00000000 __ram_rodata_end
00013848 g     O .bss	00000004 jtag_uart_0
00010a90 g     F .text	00000058 .hidden __umodsi3
00013de8 g       *ABS*	00000000 end
00018000 g       *ABS*	00000000 __alt_stack_pointer
00012e38 g     F .text	00000034 altera_avalon_jtag_uart_write
000102dc g     F .text	0000052c ___vfprintf_internal_r
00010020 g     F .text	0000003c _start
00010ca0 g     F .text	00000010 alt_sys_init
0001312c g     O .rwdata	00000200 buffer
00010ae8 g     F .text	00000028 .hidden __mulsi3
0001312c g       *ABS*	00000000 __ram_rwdata_start
00013044 g       *ABS*	00000000 __ram_rodata_start
0001387c g     O .bss	00000004 initialized
00013880 g     O .bss	00000014 search_data
00012e6c g     F .text	00000088 alt_busy_sleep
00012fec g     F .text	00000030 memcmp
00013de8 g       *ABS*	00000000 __alt_stack_base
00013894 g     O .bss	00000054 boot_sector_data
00012f00 g     F .text	0000006c alt_dev_llist_insert
00013834 g     O .bss	00000002 sd_fileh
00010824 g     F .text	000000b8 __sfvwrite_small_dev
00013834 g       *ABS*	00000000 __bss_start
0001005c g     F .text	000000dc main
0001383c g     O .bss	00000004 alt_envp
000128f0 g     F .text	00000040 alt_up_sd_card_get_attributes
0001110c g     F .text	00000080 Write_Sector_Data
00012ab8 g     F .text	000002a8 alt_up_sd_card_write
000134ac g     O .rwdata	00000004 alt_errno
00010934 g     F .text	00000084 .hidden __divsi3
00013870 g     O .bss	00000004 status_register
00013868 g     O .bss	00000004 command_register
00013044 g       *ABS*	00000000 __flash_rodata_start
00010c80 g     F .text	00000020 alt_irq_init
00011248 g     F .text	00000080 get_cluster_flag
000120a4 g     F .text	00000164 Write_File_Record_At_Offset
000108dc g     F .text	00000058 _write_r
0001145c g     F .text	000002ac Check_for_DOS_FAT
00012208 g     F .text	00000188 create_file
00013494 g     O .rwdata	00000004 _impure_ptr
0001386c g     O .bss	00000004 CSD_register_w0
00013844 g     O .bss	00000004 alt_argc
000134a4 g     O .rwdata	00000008 alt_fs_list
00010d04 g     F .text	000000dc check_file_name_for_FAT16_compliance
00013860 g     O .bss	00000004 buffer_memory
00010020 g       *ABS*	00000000 __ram_exceptions_start
0001385c g     O .bss	00000004 fat_partition_offset_in_512_byte_sectors
000134b0 g       *ABS*	00000000 _edata
00013de8 g       *ABS*	00000000 _end
000138e8 g     O .bss	00000500 active_files
00010020 g       *ABS*	00000000 __ram_exceptions_end
00010fbc g     F .text	00000080 copy_file_record_name_to_string
00012390 g     F .text	00000098 Look_for_FAT16
00012478 g     F .text	00000224 alt_up_sd_card_find_next
000109b8 g     F .text	00000074 .hidden __modsi3
000111a8 g     F .text	000000a0 Read_Sector_Data
00018000 g       *ABS*	00000000 __alt_data_end
0001000c g       .entry	00000000 _exit
00012930 g     F .text	00000188 alt_up_sd_card_read
00010254 g     F .text	0000001c strlen
00012fe0 g     F .text	00000004 alt_icache_flush_all
00010808 g     F .text	0000001c __vfprintf_internal
00010b10 g     F .text	000000e0 alt_load
00010e38 g     F .text	000000ec match_file_record_to_name_ext



Disassembly of section .entry:

00010000 <__reset>:
 * Jump to the _start entry point in the .text section if reset code
 * is allowed or if optimizing for RTL simulation.
 */
#if defined(ALT_ALLOW_CODE_AT_RESET) || defined(ALT_SIM_OPTIMIZE)
    /* Jump to the _start entry point in the .text section. */
    movhi r1, %hi(_start)
   10000:	00400074 	movhi	at,1
    ori r1, r1, %lo(_start)
   10004:	08400814 	ori	at,at,32
    jmp r1
   10008:	0800683a 	jmp	at

0001000c <_exit>:
	...

Disassembly of section .text:

00010020 <_start>:

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
   10020:	06c00074 	movhi	sp,1
    ori sp, sp, %lo(__alt_stack_pointer)
   10024:	dee00014 	ori	sp,sp,32768
    movhi gp, %hi(_gp)
   10028:	06800074 	movhi	gp,1
    ori gp, gp, %lo(_gp)
   1002c:	d6ad2414 	ori	gp,gp,46224
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
   10030:	00800074 	movhi	r2,1
    ori r2, r2, %lo(__bss_start)
   10034:	108e0d14 	ori	r2,r2,14388

    movhi r3, %hi(__bss_end)
   10038:	00c00074 	movhi	r3,1
    ori r3, r3, %lo(__bss_end)
   1003c:	18cf7a14 	ori	r3,r3,15848

    beq r2, r3, 1f
   10040:	10c00326 	beq	r2,r3,10050 <_start+0x30>

0:
    stw zero, (r2)
   10044:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
   10048:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
   1004c:	10fffd36 	bltu	r2,r3,10044 <_gp+0xffff4bb4>
     * section aren't defined until alt_load() has been called).
     */
    mov   et, zero
#endif

    call alt_load
   10050:	0010b100 	call	10b10 <alt_load>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
   10054:	0010bf00 	call	10bf0 <alt_main>

00010058 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
   10058:	003fff06 	br	10058 <_gp+0xffff4bc8>

0001005c <main>:

char buffer[512] = "WELCOME TO THE INTERFACE!!\r\n\0";

int main()
{
  printf("SD Card Access Test\n");
   1005c:	01000074 	movhi	r4,1
short int sd_fileh;

char buffer[512] = "WELCOME TO THE INTERFACE!!\r\n\0";

int main()
{
   10060:	defffd04 	addi	sp,sp,-12
  printf("SD Card Access Test\n");
   10064:	210c1104 	addi	r4,r4,12356
short int sd_fileh;

char buffer[512] = "WELCOME TO THE INTERFACE!!\r\n\0";

int main()
{
   10068:	dfc00215 	stw	ra,8(sp)
   1006c:	dc400115 	stw	r17,4(sp)
   10070:	dc000015 	stw	r16,0(sp)
  printf("SD Card Access Test\n");
   10074:	00102400 	call	10240 <puts>

  alt_up_sd_card_dev *device_reference = NULL;
  int connected = 0;
  int count = 0;
  device_reference = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);
   10078:	01000074 	movhi	r4,1
   1007c:	210c1604 	addi	r4,r4,12376
   10080:	001103c0 	call	1103c <alt_up_sd_card_open_dev>

  if (device_reference != NULL) {
   10084:	10002726 	beq	r2,zero,10124 <main+0xc8>
	  printf("device reference is %d", device_reference);
   10088:	01000074 	movhi	r4,1
   1008c:	100b883a 	mov	r5,r2
   10090:	210c2104 	addi	r4,r4,12420
   10094:	00101740 	call	10174 <printf>
{
  printf("SD Card Access Test\n");

  alt_up_sd_card_dev *device_reference = NULL;
  int connected = 0;
  int count = 0;
   10098:	0023883a 	mov	r17,zero
int main()
{
  printf("SD Card Access Test\n");

  alt_up_sd_card_dev *device_reference = NULL;
  int connected = 0;
   1009c:	0021883a 	mov	r16,zero
  device_reference = alt_up_sd_card_open_dev(ALTERA_UP_SD_CARD_AVALON_INTERFACE_0_NAME);

  if (device_reference != NULL) {
	  printf("device reference is %d", device_reference);
	  while(1) {
		  usleep(1000000);
   100a0:	010003f4 	movhi	r4,15
   100a4:	21109004 	addi	r4,r4,16960
   100a8:	0010c1c0 	call	10c1c <usleep>
		  count++;
		  printf("SD is present %d attempt %d \n", alt_up_sd_card_is_Present(), count);
   100ac:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>

  if (device_reference != NULL) {
	  printf("device reference is %d", device_reference);
	  while(1) {
		  usleep(1000000);
		  count++;
   100b0:	8c400044 	addi	r17,r17,1
		  printf("SD is present %d attempt %d \n", alt_up_sd_card_is_Present(), count);
   100b4:	01000074 	movhi	r4,1
   100b8:	880d883a 	mov	r6,r17
   100bc:	100b883a 	mov	r5,r2
   100c0:	210c2704 	addi	r4,r4,12444
   100c4:	00101740 	call	10174 <printf>
		  if ((connected == 0) && (alt_up_sd_card_is_Present())) {
   100c8:	80000e1e 	bne	r16,zero,10104 <main+0xa8>
   100cc:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   100d0:	103ff326 	beq	r2,zero,100a0 <_gp+0xffff4c10>
			  printf("Card connected.\n");
   100d4:	01000074 	movhi	r4,1
   100d8:	210c2f04 	addi	r4,r4,12476
   100dc:	00102400 	call	10240 <puts>
			  if (alt_up_sd_card_is_FAT16()) {
   100e0:	00124280 	call	12428 <alt_up_sd_card_is_FAT16>
   100e4:	10000326 	beq	r2,zero,100f4 <main+0x98>
				  printf("FAT16 file system detected.\n");
   100e8:	01000074 	movhi	r4,1
   100ec:	210c3304 	addi	r4,r4,12492
   100f0:	00000206 	br	100fc <main+0xa0>
			  } else {
				  printf("Unknown file system.\n");
   100f4:	01000074 	movhi	r4,1
   100f8:	210c3a04 	addi	r4,r4,12520
   100fc:	00102400 	call	10240 <puts>
   10100:	00000606 	br	1011c <main+0xc0>
			  }
			  connected = 1;
		  } else if ((connected == 1) && (alt_up_sd_card_is_Present() == false)) {
   10104:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   10108:	1000041e 	bne	r2,zero,1011c <main+0xc0>
			  printf("Card disconnected.\n");
   1010c:	01000074 	movhi	r4,1
   10110:	210c4004 	addi	r4,r4,12544
   10114:	00102400 	call	10240 <puts>
   10118:	003fe006 	br	1009c <_gp+0xffff4c0c>
   1011c:	04000044 	movi	r16,1
   10120:	003fdf06 	br	100a0 <_gp+0xffff4c10>
			  connected = 0;
		  }
	  }
  }
  return 0;
}
   10124:	dfc00217 	ldw	ra,8(sp)
   10128:	dc400117 	ldw	r17,4(sp)
   1012c:	dc000017 	ldw	r16,0(sp)
   10130:	dec00304 	addi	sp,sp,12
   10134:	f800283a 	ret

00010138 <_printf_r>:
   10138:	defffd04 	addi	sp,sp,-12
   1013c:	dfc00015 	stw	ra,0(sp)
   10140:	d9800115 	stw	r6,4(sp)
   10144:	d9c00215 	stw	r7,8(sp)
   10148:	20c00217 	ldw	r3,8(r4)
   1014c:	01800074 	movhi	r6,1
   10150:	31820904 	addi	r6,r6,2084
   10154:	19800115 	stw	r6,4(r3)
   10158:	280d883a 	mov	r6,r5
   1015c:	21400217 	ldw	r5,8(r4)
   10160:	d9c00104 	addi	r7,sp,4
   10164:	00102dc0 	call	102dc <___vfprintf_internal_r>
   10168:	dfc00017 	ldw	ra,0(sp)
   1016c:	dec00304 	addi	sp,sp,12
   10170:	f800283a 	ret

00010174 <printf>:
   10174:	defffc04 	addi	sp,sp,-16
   10178:	dfc00015 	stw	ra,0(sp)
   1017c:	d9400115 	stw	r5,4(sp)
   10180:	d9800215 	stw	r6,8(sp)
   10184:	d9c00315 	stw	r7,12(sp)
   10188:	00800074 	movhi	r2,1
   1018c:	108d2504 	addi	r2,r2,13460
   10190:	10800017 	ldw	r2,0(r2)
   10194:	01400074 	movhi	r5,1
   10198:	29420904 	addi	r5,r5,2084
   1019c:	10c00217 	ldw	r3,8(r2)
   101a0:	d9800104 	addi	r6,sp,4
   101a4:	19400115 	stw	r5,4(r3)
   101a8:	200b883a 	mov	r5,r4
   101ac:	11000217 	ldw	r4,8(r2)
   101b0:	00108080 	call	10808 <__vfprintf_internal>
   101b4:	dfc00017 	ldw	ra,0(sp)
   101b8:	dec00404 	addi	sp,sp,16
   101bc:	f800283a 	ret

000101c0 <_puts_r>:
   101c0:	defffd04 	addi	sp,sp,-12
   101c4:	dc000015 	stw	r16,0(sp)
   101c8:	2021883a 	mov	r16,r4
   101cc:	2809883a 	mov	r4,r5
   101d0:	dfc00215 	stw	ra,8(sp)
   101d4:	dc400115 	stw	r17,4(sp)
   101d8:	2823883a 	mov	r17,r5
   101dc:	00102540 	call	10254 <strlen>
   101e0:	81400217 	ldw	r5,8(r16)
   101e4:	01000074 	movhi	r4,1
   101e8:	21020904 	addi	r4,r4,2084
   101ec:	29000115 	stw	r4,4(r5)
   101f0:	100f883a 	mov	r7,r2
   101f4:	880d883a 	mov	r6,r17
   101f8:	8009883a 	mov	r4,r16
   101fc:	00108240 	call	10824 <__sfvwrite_small_dev>
   10200:	00ffffc4 	movi	r3,-1
   10204:	10c00926 	beq	r2,r3,1022c <_puts_r+0x6c>
   10208:	81400217 	ldw	r5,8(r16)
   1020c:	01800074 	movhi	r6,1
   10210:	01c00044 	movi	r7,1
   10214:	28800117 	ldw	r2,4(r5)
   10218:	318c2e04 	addi	r6,r6,12472
   1021c:	8009883a 	mov	r4,r16
   10220:	103ee83a 	callr	r2
   10224:	10bfffe0 	cmpeqi	r2,r2,-1
   10228:	0085c83a 	sub	r2,zero,r2
   1022c:	dfc00217 	ldw	ra,8(sp)
   10230:	dc400117 	ldw	r17,4(sp)
   10234:	dc000017 	ldw	r16,0(sp)
   10238:	dec00304 	addi	sp,sp,12
   1023c:	f800283a 	ret

00010240 <puts>:
   10240:	00800074 	movhi	r2,1
   10244:	108d2504 	addi	r2,r2,13460
   10248:	200b883a 	mov	r5,r4
   1024c:	11000017 	ldw	r4,0(r2)
   10250:	00101c01 	jmpi	101c0 <_puts_r>

00010254 <strlen>:
   10254:	2005883a 	mov	r2,r4
   10258:	10c00007 	ldb	r3,0(r2)
   1025c:	18000226 	beq	r3,zero,10268 <strlen+0x14>
   10260:	10800044 	addi	r2,r2,1
   10264:	003ffc06 	br	10258 <_gp+0xffff4dc8>
   10268:	1105c83a 	sub	r2,r2,r4
   1026c:	f800283a 	ret

00010270 <print_repeat>:
   10270:	defffb04 	addi	sp,sp,-20
   10274:	dc800315 	stw	r18,12(sp)
   10278:	dc400215 	stw	r17,8(sp)
   1027c:	dc000115 	stw	r16,4(sp)
   10280:	dfc00415 	stw	ra,16(sp)
   10284:	2025883a 	mov	r18,r4
   10288:	2823883a 	mov	r17,r5
   1028c:	d9800005 	stb	r6,0(sp)
   10290:	3821883a 	mov	r16,r7
   10294:	04000a0e 	bge	zero,r16,102c0 <print_repeat+0x50>
   10298:	88800117 	ldw	r2,4(r17)
   1029c:	01c00044 	movi	r7,1
   102a0:	d80d883a 	mov	r6,sp
   102a4:	880b883a 	mov	r5,r17
   102a8:	9009883a 	mov	r4,r18
   102ac:	103ee83a 	callr	r2
   102b0:	843fffc4 	addi	r16,r16,-1
   102b4:	103ff726 	beq	r2,zero,10294 <_gp+0xffff4e04>
   102b8:	00bfffc4 	movi	r2,-1
   102bc:	00000106 	br	102c4 <print_repeat+0x54>
   102c0:	0005883a 	mov	r2,zero
   102c4:	dfc00417 	ldw	ra,16(sp)
   102c8:	dc800317 	ldw	r18,12(sp)
   102cc:	dc400217 	ldw	r17,8(sp)
   102d0:	dc000117 	ldw	r16,4(sp)
   102d4:	dec00504 	addi	sp,sp,20
   102d8:	f800283a 	ret

000102dc <___vfprintf_internal_r>:
   102dc:	deffe504 	addi	sp,sp,-108
   102e0:	d8c00804 	addi	r3,sp,32
   102e4:	ddc01815 	stw	r23,96(sp)
   102e8:	dd801715 	stw	r22,92(sp)
   102ec:	dd401615 	stw	r21,88(sp)
   102f0:	dd001515 	stw	r20,84(sp)
   102f4:	dcc01415 	stw	r19,80(sp)
   102f8:	dc801315 	stw	r18,76(sp)
   102fc:	dc401215 	stw	r17,72(sp)
   10300:	dc001115 	stw	r16,68(sp)
   10304:	dfc01a15 	stw	ra,104(sp)
   10308:	df001915 	stw	fp,100(sp)
   1030c:	2029883a 	mov	r20,r4
   10310:	2823883a 	mov	r17,r5
   10314:	382d883a 	mov	r22,r7
   10318:	d9800f15 	stw	r6,60(sp)
   1031c:	0021883a 	mov	r16,zero
   10320:	d8000e15 	stw	zero,56(sp)
   10324:	d8000a15 	stw	zero,40(sp)
   10328:	002b883a 	mov	r21,zero
   1032c:	0027883a 	mov	r19,zero
   10330:	0025883a 	mov	r18,zero
   10334:	d8000c15 	stw	zero,48(sp)
   10338:	d8000b15 	stw	zero,44(sp)
   1033c:	002f883a 	mov	r23,zero
   10340:	d8c00915 	stw	r3,36(sp)
   10344:	d8c00f17 	ldw	r3,60(sp)
   10348:	19000003 	ldbu	r4,0(r3)
   1034c:	20803fcc 	andi	r2,r4,255
   10350:	1080201c 	xori	r2,r2,128
   10354:	10bfe004 	addi	r2,r2,-128
   10358:	10011e26 	beq	r2,zero,107d4 <___vfprintf_internal_r+0x4f8>
   1035c:	00c00044 	movi	r3,1
   10360:	b8c01426 	beq	r23,r3,103b4 <___vfprintf_internal_r+0xd8>
   10364:	1dc00216 	blt	r3,r23,10370 <___vfprintf_internal_r+0x94>
   10368:	b8000626 	beq	r23,zero,10384 <___vfprintf_internal_r+0xa8>
   1036c:	00011506 	br	107c4 <___vfprintf_internal_r+0x4e8>
   10370:	01400084 	movi	r5,2
   10374:	b9401d26 	beq	r23,r5,103ec <___vfprintf_internal_r+0x110>
   10378:	014000c4 	movi	r5,3
   1037c:	b9402b26 	beq	r23,r5,1042c <___vfprintf_internal_r+0x150>
   10380:	00011006 	br	107c4 <___vfprintf_internal_r+0x4e8>
   10384:	01400944 	movi	r5,37
   10388:	1140fc26 	beq	r2,r5,1077c <___vfprintf_internal_r+0x4a0>
   1038c:	88800117 	ldw	r2,4(r17)
   10390:	d9000005 	stb	r4,0(sp)
   10394:	01c00044 	movi	r7,1
   10398:	d80d883a 	mov	r6,sp
   1039c:	880b883a 	mov	r5,r17
   103a0:	a009883a 	mov	r4,r20
   103a4:	103ee83a 	callr	r2
   103a8:	1000d81e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   103ac:	84000044 	addi	r16,r16,1
   103b0:	00010406 	br	107c4 <___vfprintf_internal_r+0x4e8>
   103b4:	01400c04 	movi	r5,48
   103b8:	1140fa26 	beq	r2,r5,107a4 <___vfprintf_internal_r+0x4c8>
   103bc:	01400944 	movi	r5,37
   103c0:	11400a1e 	bne	r2,r5,103ec <___vfprintf_internal_r+0x110>
   103c4:	d8800005 	stb	r2,0(sp)
   103c8:	88800117 	ldw	r2,4(r17)
   103cc:	b80f883a 	mov	r7,r23
   103d0:	d80d883a 	mov	r6,sp
   103d4:	880b883a 	mov	r5,r17
   103d8:	a009883a 	mov	r4,r20
   103dc:	103ee83a 	callr	r2
   103e0:	1000ca1e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   103e4:	84000044 	addi	r16,r16,1
   103e8:	0000f506 	br	107c0 <___vfprintf_internal_r+0x4e4>
   103ec:	25fff404 	addi	r23,r4,-48
   103f0:	bdc03fcc 	andi	r23,r23,255
   103f4:	00c00244 	movi	r3,9
   103f8:	1dc00936 	bltu	r3,r23,10420 <___vfprintf_internal_r+0x144>
   103fc:	00bfffc4 	movi	r2,-1
   10400:	90800426 	beq	r18,r2,10414 <___vfprintf_internal_r+0x138>
   10404:	01400284 	movi	r5,10
   10408:	9009883a 	mov	r4,r18
   1040c:	0010ae80 	call	10ae8 <__mulsi3>
   10410:	00000106 	br	10418 <___vfprintf_internal_r+0x13c>
   10414:	0005883a 	mov	r2,zero
   10418:	b8a5883a 	add	r18,r23,r2
   1041c:	0000e206 	br	107a8 <___vfprintf_internal_r+0x4cc>
   10420:	01400b84 	movi	r5,46
   10424:	1140e426 	beq	r2,r5,107b8 <___vfprintf_internal_r+0x4dc>
   10428:	05c00084 	movi	r23,2
   1042c:	213ff404 	addi	r4,r4,-48
   10430:	27003fcc 	andi	fp,r4,255
   10434:	00c00244 	movi	r3,9
   10438:	1f000936 	bltu	r3,fp,10460 <___vfprintf_internal_r+0x184>
   1043c:	00bfffc4 	movi	r2,-1
   10440:	98800426 	beq	r19,r2,10454 <___vfprintf_internal_r+0x178>
   10444:	01400284 	movi	r5,10
   10448:	9809883a 	mov	r4,r19
   1044c:	0010ae80 	call	10ae8 <__mulsi3>
   10450:	00000106 	br	10458 <___vfprintf_internal_r+0x17c>
   10454:	0005883a 	mov	r2,zero
   10458:	e0a7883a 	add	r19,fp,r2
   1045c:	0000d906 	br	107c4 <___vfprintf_internal_r+0x4e8>
   10460:	00c01b04 	movi	r3,108
   10464:	10c0d226 	beq	r2,r3,107b0 <___vfprintf_internal_r+0x4d4>
   10468:	013fffc4 	movi	r4,-1
   1046c:	99000226 	beq	r19,r4,10478 <___vfprintf_internal_r+0x19c>
   10470:	d8000b15 	stw	zero,44(sp)
   10474:	00000106 	br	1047c <___vfprintf_internal_r+0x1a0>
   10478:	04c00044 	movi	r19,1
   1047c:	01001a44 	movi	r4,105
   10480:	11001626 	beq	r2,r4,104dc <___vfprintf_internal_r+0x200>
   10484:	20800916 	blt	r4,r2,104ac <___vfprintf_internal_r+0x1d0>
   10488:	010018c4 	movi	r4,99
   1048c:	11008826 	beq	r2,r4,106b0 <___vfprintf_internal_r+0x3d4>
   10490:	01001904 	movi	r4,100
   10494:	11001126 	beq	r2,r4,104dc <___vfprintf_internal_r+0x200>
   10498:	01001604 	movi	r4,88
   1049c:	1100c81e 	bne	r2,r4,107c0 <___vfprintf_internal_r+0x4e4>
   104a0:	00c00044 	movi	r3,1
   104a4:	d8c00e15 	stw	r3,56(sp)
   104a8:	00001506 	br	10500 <___vfprintf_internal_r+0x224>
   104ac:	01001cc4 	movi	r4,115
   104b0:	11009826 	beq	r2,r4,10714 <___vfprintf_internal_r+0x438>
   104b4:	20800416 	blt	r4,r2,104c8 <___vfprintf_internal_r+0x1ec>
   104b8:	01001bc4 	movi	r4,111
   104bc:	1100c01e 	bne	r2,r4,107c0 <___vfprintf_internal_r+0x4e4>
   104c0:	05400204 	movi	r21,8
   104c4:	00000f06 	br	10504 <___vfprintf_internal_r+0x228>
   104c8:	01001d44 	movi	r4,117
   104cc:	11000d26 	beq	r2,r4,10504 <___vfprintf_internal_r+0x228>
   104d0:	01001e04 	movi	r4,120
   104d4:	11000a26 	beq	r2,r4,10500 <___vfprintf_internal_r+0x224>
   104d8:	0000b906 	br	107c0 <___vfprintf_internal_r+0x4e4>
   104dc:	d8c00a17 	ldw	r3,40(sp)
   104e0:	b7000104 	addi	fp,r22,4
   104e4:	18000726 	beq	r3,zero,10504 <___vfprintf_internal_r+0x228>
   104e8:	df000d15 	stw	fp,52(sp)
   104ec:	b5c00017 	ldw	r23,0(r22)
   104f0:	b800080e 	bge	r23,zero,10514 <___vfprintf_internal_r+0x238>
   104f4:	05efc83a 	sub	r23,zero,r23
   104f8:	02400044 	movi	r9,1
   104fc:	00000606 	br	10518 <___vfprintf_internal_r+0x23c>
   10500:	05400404 	movi	r21,16
   10504:	b0c00104 	addi	r3,r22,4
   10508:	d8c00d15 	stw	r3,52(sp)
   1050c:	b5c00017 	ldw	r23,0(r22)
   10510:	d8000a15 	stw	zero,40(sp)
   10514:	0013883a 	mov	r9,zero
   10518:	d839883a 	mov	fp,sp
   1051c:	b8001726 	beq	r23,zero,1057c <___vfprintf_internal_r+0x2a0>
   10520:	a80b883a 	mov	r5,r21
   10524:	b809883a 	mov	r4,r23
   10528:	da401015 	stw	r9,64(sp)
   1052c:	0010a2c0 	call	10a2c <__udivsi3>
   10530:	a80b883a 	mov	r5,r21
   10534:	1009883a 	mov	r4,r2
   10538:	102d883a 	mov	r22,r2
   1053c:	0010ae80 	call	10ae8 <__mulsi3>
   10540:	b885c83a 	sub	r2,r23,r2
   10544:	00c00244 	movi	r3,9
   10548:	da401017 	ldw	r9,64(sp)
   1054c:	18800216 	blt	r3,r2,10558 <___vfprintf_internal_r+0x27c>
   10550:	10800c04 	addi	r2,r2,48
   10554:	00000506 	br	1056c <___vfprintf_internal_r+0x290>
   10558:	d8c00e17 	ldw	r3,56(sp)
   1055c:	18000226 	beq	r3,zero,10568 <___vfprintf_internal_r+0x28c>
   10560:	10800dc4 	addi	r2,r2,55
   10564:	00000106 	br	1056c <___vfprintf_internal_r+0x290>
   10568:	108015c4 	addi	r2,r2,87
   1056c:	e0800005 	stb	r2,0(fp)
   10570:	b02f883a 	mov	r23,r22
   10574:	e7000044 	addi	fp,fp,1
   10578:	003fe806 	br	1051c <_gp+0xffff508c>
   1057c:	e6efc83a 	sub	r23,fp,sp
   10580:	9dc5c83a 	sub	r2,r19,r23
   10584:	0080090e 	bge	zero,r2,105ac <___vfprintf_internal_r+0x2d0>
   10588:	e085883a 	add	r2,fp,r2
   1058c:	01400c04 	movi	r5,48
   10590:	d8c00917 	ldw	r3,36(sp)
   10594:	e009883a 	mov	r4,fp
   10598:	e0c0032e 	bgeu	fp,r3,105a8 <___vfprintf_internal_r+0x2cc>
   1059c:	e7000044 	addi	fp,fp,1
   105a0:	21400005 	stb	r5,0(r4)
   105a4:	e0bffa1e 	bne	fp,r2,10590 <_gp+0xffff5100>
   105a8:	e6efc83a 	sub	r23,fp,sp
   105ac:	d8c00b17 	ldw	r3,44(sp)
   105b0:	4dd1883a 	add	r8,r9,r23
   105b4:	922dc83a 	sub	r22,r18,r8
   105b8:	18001626 	beq	r3,zero,10614 <___vfprintf_internal_r+0x338>
   105bc:	48000a26 	beq	r9,zero,105e8 <___vfprintf_internal_r+0x30c>
   105c0:	00800b44 	movi	r2,45
   105c4:	d8800805 	stb	r2,32(sp)
   105c8:	88800117 	ldw	r2,4(r17)
   105cc:	01c00044 	movi	r7,1
   105d0:	d9800804 	addi	r6,sp,32
   105d4:	880b883a 	mov	r5,r17
   105d8:	a009883a 	mov	r4,r20
   105dc:	103ee83a 	callr	r2
   105e0:	10004a1e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   105e4:	84000044 	addi	r16,r16,1
   105e8:	0580070e 	bge	zero,r22,10608 <___vfprintf_internal_r+0x32c>
   105ec:	b00f883a 	mov	r7,r22
   105f0:	01800c04 	movi	r6,48
   105f4:	880b883a 	mov	r5,r17
   105f8:	a009883a 	mov	r4,r20
   105fc:	00102700 	call	10270 <print_repeat>
   10600:	1000421e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   10604:	85a1883a 	add	r16,r16,r22
   10608:	e02d883a 	mov	r22,fp
   1060c:	bf2fc83a 	sub	r23,r23,fp
   10610:	00002006 	br	10694 <___vfprintf_internal_r+0x3b8>
   10614:	0580090e 	bge	zero,r22,1063c <___vfprintf_internal_r+0x360>
   10618:	b00f883a 	mov	r7,r22
   1061c:	01800804 	movi	r6,32
   10620:	880b883a 	mov	r5,r17
   10624:	a009883a 	mov	r4,r20
   10628:	da401015 	stw	r9,64(sp)
   1062c:	00102700 	call	10270 <print_repeat>
   10630:	da401017 	ldw	r9,64(sp)
   10634:	1000351e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   10638:	85a1883a 	add	r16,r16,r22
   1063c:	483ff226 	beq	r9,zero,10608 <_gp+0xffff5178>
   10640:	00800b44 	movi	r2,45
   10644:	d8800805 	stb	r2,32(sp)
   10648:	88800117 	ldw	r2,4(r17)
   1064c:	01c00044 	movi	r7,1
   10650:	d9800804 	addi	r6,sp,32
   10654:	880b883a 	mov	r5,r17
   10658:	a009883a 	mov	r4,r20
   1065c:	103ee83a 	callr	r2
   10660:	10002a1e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   10664:	84000044 	addi	r16,r16,1
   10668:	003fe706 	br	10608 <_gp+0xffff5178>
   1066c:	b5bfffc4 	addi	r22,r22,-1
   10670:	b0800003 	ldbu	r2,0(r22)
   10674:	01c00044 	movi	r7,1
   10678:	d9800804 	addi	r6,sp,32
   1067c:	d8800805 	stb	r2,32(sp)
   10680:	88800117 	ldw	r2,4(r17)
   10684:	880b883a 	mov	r5,r17
   10688:	a009883a 	mov	r4,r20
   1068c:	103ee83a 	callr	r2
   10690:	10001e1e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   10694:	8585c83a 	sub	r2,r16,r22
   10698:	b5c9883a 	add	r4,r22,r23
   1069c:	e085883a 	add	r2,fp,r2
   106a0:	013ff216 	blt	zero,r4,1066c <_gp+0xffff51dc>
   106a4:	1021883a 	mov	r16,r2
   106a8:	dd800d17 	ldw	r22,52(sp)
   106ac:	00004406 	br	107c0 <___vfprintf_internal_r+0x4e4>
   106b0:	00800044 	movi	r2,1
   106b4:	1480080e 	bge	r2,r18,106d8 <___vfprintf_internal_r+0x3fc>
   106b8:	95ffffc4 	addi	r23,r18,-1
   106bc:	b80f883a 	mov	r7,r23
   106c0:	01800804 	movi	r6,32
   106c4:	880b883a 	mov	r5,r17
   106c8:	a009883a 	mov	r4,r20
   106cc:	00102700 	call	10270 <print_repeat>
   106d0:	10000e1e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   106d4:	85e1883a 	add	r16,r16,r23
   106d8:	b0800017 	ldw	r2,0(r22)
   106dc:	01c00044 	movi	r7,1
   106e0:	d80d883a 	mov	r6,sp
   106e4:	d8800005 	stb	r2,0(sp)
   106e8:	88800117 	ldw	r2,4(r17)
   106ec:	880b883a 	mov	r5,r17
   106f0:	a009883a 	mov	r4,r20
   106f4:	b5c00104 	addi	r23,r22,4
   106f8:	103ee83a 	callr	r2
   106fc:	1000031e 	bne	r2,zero,1070c <___vfprintf_internal_r+0x430>
   10700:	84000044 	addi	r16,r16,1
   10704:	b82d883a 	mov	r22,r23
   10708:	00002d06 	br	107c0 <___vfprintf_internal_r+0x4e4>
   1070c:	00bfffc4 	movi	r2,-1
   10710:	00003106 	br	107d8 <___vfprintf_internal_r+0x4fc>
   10714:	b5c00017 	ldw	r23,0(r22)
   10718:	b7000104 	addi	fp,r22,4
   1071c:	b809883a 	mov	r4,r23
   10720:	00102540 	call	10254 <strlen>
   10724:	9091c83a 	sub	r8,r18,r2
   10728:	102d883a 	mov	r22,r2
   1072c:	0200090e 	bge	zero,r8,10754 <___vfprintf_internal_r+0x478>
   10730:	400f883a 	mov	r7,r8
   10734:	01800804 	movi	r6,32
   10738:	880b883a 	mov	r5,r17
   1073c:	a009883a 	mov	r4,r20
   10740:	da001015 	stw	r8,64(sp)
   10744:	00102700 	call	10270 <print_repeat>
   10748:	da001017 	ldw	r8,64(sp)
   1074c:	103fef1e 	bne	r2,zero,1070c <_gp+0xffff527c>
   10750:	8221883a 	add	r16,r16,r8
   10754:	88800117 	ldw	r2,4(r17)
   10758:	b00f883a 	mov	r7,r22
   1075c:	b80d883a 	mov	r6,r23
   10760:	880b883a 	mov	r5,r17
   10764:	a009883a 	mov	r4,r20
   10768:	103ee83a 	callr	r2
   1076c:	103fe71e 	bne	r2,zero,1070c <_gp+0xffff527c>
   10770:	85a1883a 	add	r16,r16,r22
   10774:	e02d883a 	mov	r22,fp
   10778:	00001106 	br	107c0 <___vfprintf_internal_r+0x4e4>
   1077c:	00c00044 	movi	r3,1
   10780:	04ffffc4 	movi	r19,-1
   10784:	d8000e15 	stw	zero,56(sp)
   10788:	d8c00a15 	stw	r3,40(sp)
   1078c:	05400284 	movi	r21,10
   10790:	9825883a 	mov	r18,r19
   10794:	d8000c15 	stw	zero,48(sp)
   10798:	d8000b15 	stw	zero,44(sp)
   1079c:	182f883a 	mov	r23,r3
   107a0:	00000806 	br	107c4 <___vfprintf_internal_r+0x4e8>
   107a4:	ddc00b15 	stw	r23,44(sp)
   107a8:	05c00084 	movi	r23,2
   107ac:	00000506 	br	107c4 <___vfprintf_internal_r+0x4e8>
   107b0:	00c00044 	movi	r3,1
   107b4:	d8c00c15 	stw	r3,48(sp)
   107b8:	05c000c4 	movi	r23,3
   107bc:	00000106 	br	107c4 <___vfprintf_internal_r+0x4e8>
   107c0:	002f883a 	mov	r23,zero
   107c4:	d8c00f17 	ldw	r3,60(sp)
   107c8:	18c00044 	addi	r3,r3,1
   107cc:	d8c00f15 	stw	r3,60(sp)
   107d0:	003edc06 	br	10344 <_gp+0xffff4eb4>
   107d4:	8005883a 	mov	r2,r16
   107d8:	dfc01a17 	ldw	ra,104(sp)
   107dc:	df001917 	ldw	fp,100(sp)
   107e0:	ddc01817 	ldw	r23,96(sp)
   107e4:	dd801717 	ldw	r22,92(sp)
   107e8:	dd401617 	ldw	r21,88(sp)
   107ec:	dd001517 	ldw	r20,84(sp)
   107f0:	dcc01417 	ldw	r19,80(sp)
   107f4:	dc801317 	ldw	r18,76(sp)
   107f8:	dc401217 	ldw	r17,72(sp)
   107fc:	dc001117 	ldw	r16,68(sp)
   10800:	dec01b04 	addi	sp,sp,108
   10804:	f800283a 	ret

00010808 <__vfprintf_internal>:
   10808:	00800074 	movhi	r2,1
   1080c:	108d2504 	addi	r2,r2,13460
   10810:	300f883a 	mov	r7,r6
   10814:	280d883a 	mov	r6,r5
   10818:	200b883a 	mov	r5,r4
   1081c:	11000017 	ldw	r4,0(r2)
   10820:	00102dc1 	jmpi	102dc <___vfprintf_internal_r>

00010824 <__sfvwrite_small_dev>:
   10824:	2880000b 	ldhu	r2,0(r5)
   10828:	1080020c 	andi	r2,r2,8
   1082c:	10002126 	beq	r2,zero,108b4 <__sfvwrite_small_dev+0x90>
   10830:	2880008f 	ldh	r2,2(r5)
   10834:	defffa04 	addi	sp,sp,-24
   10838:	dc000015 	stw	r16,0(sp)
   1083c:	dfc00515 	stw	ra,20(sp)
   10840:	dd000415 	stw	r20,16(sp)
   10844:	dcc00315 	stw	r19,12(sp)
   10848:	dc800215 	stw	r18,8(sp)
   1084c:	dc400115 	stw	r17,4(sp)
   10850:	2821883a 	mov	r16,r5
   10854:	10001216 	blt	r2,zero,108a0 <__sfvwrite_small_dev+0x7c>
   10858:	2027883a 	mov	r19,r4
   1085c:	3025883a 	mov	r18,r6
   10860:	3823883a 	mov	r17,r7
   10864:	05010004 	movi	r20,1024
   10868:	04400b0e 	bge	zero,r17,10898 <__sfvwrite_small_dev+0x74>
   1086c:	880f883a 	mov	r7,r17
   10870:	a440010e 	bge	r20,r17,10878 <__sfvwrite_small_dev+0x54>
   10874:	01c10004 	movi	r7,1024
   10878:	8140008f 	ldh	r5,2(r16)
   1087c:	900d883a 	mov	r6,r18
   10880:	9809883a 	mov	r4,r19
   10884:	00108dc0 	call	108dc <_write_r>
   10888:	0080050e 	bge	zero,r2,108a0 <__sfvwrite_small_dev+0x7c>
   1088c:	88a3c83a 	sub	r17,r17,r2
   10890:	90a5883a 	add	r18,r18,r2
   10894:	003ff406 	br	10868 <_gp+0xffff53d8>
   10898:	0005883a 	mov	r2,zero
   1089c:	00000706 	br	108bc <__sfvwrite_small_dev+0x98>
   108a0:	8080000b 	ldhu	r2,0(r16)
   108a4:	10801014 	ori	r2,r2,64
   108a8:	8080000d 	sth	r2,0(r16)
   108ac:	00bfffc4 	movi	r2,-1
   108b0:	00000206 	br	108bc <__sfvwrite_small_dev+0x98>
   108b4:	00bfffc4 	movi	r2,-1
   108b8:	f800283a 	ret
   108bc:	dfc00517 	ldw	ra,20(sp)
   108c0:	dd000417 	ldw	r20,16(sp)
   108c4:	dcc00317 	ldw	r19,12(sp)
   108c8:	dc800217 	ldw	r18,8(sp)
   108cc:	dc400117 	ldw	r17,4(sp)
   108d0:	dc000017 	ldw	r16,0(sp)
   108d4:	dec00604 	addi	sp,sp,24
   108d8:	f800283a 	ret

000108dc <_write_r>:
   108dc:	defffd04 	addi	sp,sp,-12
   108e0:	dc000015 	stw	r16,0(sp)
   108e4:	04000074 	movhi	r16,1
   108e8:	dc400115 	stw	r17,4(sp)
   108ec:	840e0e04 	addi	r16,r16,14392
   108f0:	2023883a 	mov	r17,r4
   108f4:	2809883a 	mov	r4,r5
   108f8:	300b883a 	mov	r5,r6
   108fc:	380d883a 	mov	r6,r7
   10900:	dfc00215 	stw	ra,8(sp)
   10904:	80000015 	stw	zero,0(r16)
   10908:	0010c200 	call	10c20 <write>
   1090c:	00ffffc4 	movi	r3,-1
   10910:	10c0031e 	bne	r2,r3,10920 <_write_r+0x44>
   10914:	80c00017 	ldw	r3,0(r16)
   10918:	18000126 	beq	r3,zero,10920 <_write_r+0x44>
   1091c:	88c00015 	stw	r3,0(r17)
   10920:	dfc00217 	ldw	ra,8(sp)
   10924:	dc400117 	ldw	r17,4(sp)
   10928:	dc000017 	ldw	r16,0(sp)
   1092c:	dec00304 	addi	sp,sp,12
   10930:	f800283a 	ret

00010934 <__divsi3>:
   10934:	20001b16 	blt	r4,zero,109a4 <__divsi3+0x70>
   10938:	000f883a 	mov	r7,zero
   1093c:	28001616 	blt	r5,zero,10998 <__divsi3+0x64>
   10940:	200d883a 	mov	r6,r4
   10944:	29001a2e 	bgeu	r5,r4,109b0 <__divsi3+0x7c>
   10948:	00800804 	movi	r2,32
   1094c:	00c00044 	movi	r3,1
   10950:	00000106 	br	10958 <__divsi3+0x24>
   10954:	10000d26 	beq	r2,zero,1098c <__divsi3+0x58>
   10958:	294b883a 	add	r5,r5,r5
   1095c:	10bfffc4 	addi	r2,r2,-1
   10960:	18c7883a 	add	r3,r3,r3
   10964:	293ffb36 	bltu	r5,r4,10954 <_gp+0xffff54c4>
   10968:	0005883a 	mov	r2,zero
   1096c:	18000726 	beq	r3,zero,1098c <__divsi3+0x58>
   10970:	0005883a 	mov	r2,zero
   10974:	31400236 	bltu	r6,r5,10980 <__divsi3+0x4c>
   10978:	314dc83a 	sub	r6,r6,r5
   1097c:	10c4b03a 	or	r2,r2,r3
   10980:	1806d07a 	srli	r3,r3,1
   10984:	280ad07a 	srli	r5,r5,1
   10988:	183ffa1e 	bne	r3,zero,10974 <_gp+0xffff54e4>
   1098c:	38000126 	beq	r7,zero,10994 <__divsi3+0x60>
   10990:	0085c83a 	sub	r2,zero,r2
   10994:	f800283a 	ret
   10998:	014bc83a 	sub	r5,zero,r5
   1099c:	39c0005c 	xori	r7,r7,1
   109a0:	003fe706 	br	10940 <_gp+0xffff54b0>
   109a4:	0109c83a 	sub	r4,zero,r4
   109a8:	01c00044 	movi	r7,1
   109ac:	003fe306 	br	1093c <_gp+0xffff54ac>
   109b0:	00c00044 	movi	r3,1
   109b4:	003fee06 	br	10970 <_gp+0xffff54e0>

000109b8 <__modsi3>:
   109b8:	20001716 	blt	r4,zero,10a18 <__modsi3+0x60>
   109bc:	000f883a 	mov	r7,zero
   109c0:	2005883a 	mov	r2,r4
   109c4:	28001216 	blt	r5,zero,10a10 <__modsi3+0x58>
   109c8:	2900162e 	bgeu	r5,r4,10a24 <__modsi3+0x6c>
   109cc:	01800804 	movi	r6,32
   109d0:	00c00044 	movi	r3,1
   109d4:	00000106 	br	109dc <__modsi3+0x24>
   109d8:	30000a26 	beq	r6,zero,10a04 <__modsi3+0x4c>
   109dc:	294b883a 	add	r5,r5,r5
   109e0:	31bfffc4 	addi	r6,r6,-1
   109e4:	18c7883a 	add	r3,r3,r3
   109e8:	293ffb36 	bltu	r5,r4,109d8 <_gp+0xffff5548>
   109ec:	18000526 	beq	r3,zero,10a04 <__modsi3+0x4c>
   109f0:	1806d07a 	srli	r3,r3,1
   109f4:	11400136 	bltu	r2,r5,109fc <__modsi3+0x44>
   109f8:	1145c83a 	sub	r2,r2,r5
   109fc:	280ad07a 	srli	r5,r5,1
   10a00:	183ffb1e 	bne	r3,zero,109f0 <_gp+0xffff5560>
   10a04:	38000126 	beq	r7,zero,10a0c <__modsi3+0x54>
   10a08:	0085c83a 	sub	r2,zero,r2
   10a0c:	f800283a 	ret
   10a10:	014bc83a 	sub	r5,zero,r5
   10a14:	003fec06 	br	109c8 <_gp+0xffff5538>
   10a18:	0109c83a 	sub	r4,zero,r4
   10a1c:	01c00044 	movi	r7,1
   10a20:	003fe706 	br	109c0 <_gp+0xffff5530>
   10a24:	00c00044 	movi	r3,1
   10a28:	003ff106 	br	109f0 <_gp+0xffff5560>

00010a2c <__udivsi3>:
   10a2c:	200d883a 	mov	r6,r4
   10a30:	2900152e 	bgeu	r5,r4,10a88 <__udivsi3+0x5c>
   10a34:	28001416 	blt	r5,zero,10a88 <__udivsi3+0x5c>
   10a38:	00800804 	movi	r2,32
   10a3c:	00c00044 	movi	r3,1
   10a40:	00000206 	br	10a4c <__udivsi3+0x20>
   10a44:	10000e26 	beq	r2,zero,10a80 <__udivsi3+0x54>
   10a48:	28000516 	blt	r5,zero,10a60 <__udivsi3+0x34>
   10a4c:	294b883a 	add	r5,r5,r5
   10a50:	10bfffc4 	addi	r2,r2,-1
   10a54:	18c7883a 	add	r3,r3,r3
   10a58:	293ffa36 	bltu	r5,r4,10a44 <_gp+0xffff55b4>
   10a5c:	18000826 	beq	r3,zero,10a80 <__udivsi3+0x54>
   10a60:	0005883a 	mov	r2,zero
   10a64:	31400236 	bltu	r6,r5,10a70 <__udivsi3+0x44>
   10a68:	314dc83a 	sub	r6,r6,r5
   10a6c:	10c4b03a 	or	r2,r2,r3
   10a70:	1806d07a 	srli	r3,r3,1
   10a74:	280ad07a 	srli	r5,r5,1
   10a78:	183ffa1e 	bne	r3,zero,10a64 <_gp+0xffff55d4>
   10a7c:	f800283a 	ret
   10a80:	0005883a 	mov	r2,zero
   10a84:	f800283a 	ret
   10a88:	00c00044 	movi	r3,1
   10a8c:	003ff406 	br	10a60 <_gp+0xffff55d0>

00010a90 <__umodsi3>:
   10a90:	2005883a 	mov	r2,r4
   10a94:	2900122e 	bgeu	r5,r4,10ae0 <__umodsi3+0x50>
   10a98:	28001116 	blt	r5,zero,10ae0 <__umodsi3+0x50>
   10a9c:	01800804 	movi	r6,32
   10aa0:	00c00044 	movi	r3,1
   10aa4:	00000206 	br	10ab0 <__umodsi3+0x20>
   10aa8:	30000c26 	beq	r6,zero,10adc <__umodsi3+0x4c>
   10aac:	28000516 	blt	r5,zero,10ac4 <__umodsi3+0x34>
   10ab0:	294b883a 	add	r5,r5,r5
   10ab4:	31bfffc4 	addi	r6,r6,-1
   10ab8:	18c7883a 	add	r3,r3,r3
   10abc:	293ffa36 	bltu	r5,r4,10aa8 <_gp+0xffff5618>
   10ac0:	18000626 	beq	r3,zero,10adc <__umodsi3+0x4c>
   10ac4:	1806d07a 	srli	r3,r3,1
   10ac8:	11400136 	bltu	r2,r5,10ad0 <__umodsi3+0x40>
   10acc:	1145c83a 	sub	r2,r2,r5
   10ad0:	280ad07a 	srli	r5,r5,1
   10ad4:	183ffb1e 	bne	r3,zero,10ac4 <_gp+0xffff5634>
   10ad8:	f800283a 	ret
   10adc:	f800283a 	ret
   10ae0:	00c00044 	movi	r3,1
   10ae4:	003ff706 	br	10ac4 <_gp+0xffff5634>

00010ae8 <__mulsi3>:
   10ae8:	0005883a 	mov	r2,zero
   10aec:	20000726 	beq	r4,zero,10b0c <__mulsi3+0x24>
   10af0:	20c0004c 	andi	r3,r4,1
   10af4:	2008d07a 	srli	r4,r4,1
   10af8:	18000126 	beq	r3,zero,10b00 <__mulsi3+0x18>
   10afc:	1145883a 	add	r2,r2,r5
   10b00:	294b883a 	add	r5,r5,r5
   10b04:	203ffa1e 	bne	r4,zero,10af0 <_gp+0xffff5660>
   10b08:	f800283a 	ret
   10b0c:	f800283a 	ret

00010b10 <alt_load>:
 * there is no bootloader, so this application is responsible for loading to
 * RAM any sections that are required.
 */  

void alt_load (void)
{
   10b10:	deffff04 	addi	sp,sp,-4
   10b14:	01000074 	movhi	r4,1
   10b18:	01400074 	movhi	r5,1
   10b1c:	dfc00015 	stw	ra,0(sp)
   10b20:	210c4b04 	addi	r4,r4,12588
   10b24:	294d2c04 	addi	r5,r5,13488

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   10b28:	2140061e 	bne	r4,r5,10b44 <alt_load+0x34>
   10b2c:	01000074 	movhi	r4,1
   10b30:	01400074 	movhi	r5,1
   10b34:	21000804 	addi	r4,r4,32
   10b38:	29400804 	addi	r5,r5,32
   10b3c:	2140121e 	bne	r4,r5,10b88 <alt_load+0x78>
   10b40:	00000b06 	br	10b70 <alt_load+0x60>
   10b44:	00c00074 	movhi	r3,1
   10b48:	18cd2c04 	addi	r3,r3,13488
   10b4c:	1907c83a 	sub	r3,r3,r4
   10b50:	0005883a 	mov	r2,zero
  {
    while( to != end )
   10b54:	10fff526 	beq	r2,r3,10b2c <_gp+0xffff569c>
    {
      *to++ = *from++;
   10b58:	114f883a 	add	r7,r2,r5
   10b5c:	39c00017 	ldw	r7,0(r7)
   10b60:	110d883a 	add	r6,r2,r4
   10b64:	10800104 	addi	r2,r2,4
   10b68:	31c00015 	stw	r7,0(r6)
   10b6c:	003ff906 	br	10b54 <_gp+0xffff56c4>
   10b70:	01000074 	movhi	r4,1
   10b74:	01400074 	movhi	r5,1
   10b78:	210c1104 	addi	r4,r4,12356
   10b7c:	294c1104 	addi	r5,r5,12356

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   10b80:	2140101e 	bne	r4,r5,10bc4 <alt_load+0xb4>
   10b84:	00000b06 	br	10bb4 <alt_load+0xa4>
   10b88:	00c00074 	movhi	r3,1
   10b8c:	18c00804 	addi	r3,r3,32
   10b90:	1907c83a 	sub	r3,r3,r4
   10b94:	0005883a 	mov	r2,zero
  {
    while( to != end )
   10b98:	10fff526 	beq	r2,r3,10b70 <_gp+0xffff56e0>
    {
      *to++ = *from++;
   10b9c:	114f883a 	add	r7,r2,r5
   10ba0:	39c00017 	ldw	r7,0(r7)
   10ba4:	110d883a 	add	r6,r2,r4
   10ba8:	10800104 	addi	r2,r2,4
   10bac:	31c00015 	stw	r7,0(r6)
   10bb0:	003ff906 	br	10b98 <_gp+0xffff5708>
  
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
   10bb4:	0012ef40 	call	12ef4 <alt_dcache_flush_all>
  alt_icache_flush_all();
}
   10bb8:	dfc00017 	ldw	ra,0(sp)
   10bbc:	dec00104 	addi	sp,sp,4
  /*
   * Now ensure that the caches are in synch.
   */
  
  alt_dcache_flush_all();
  alt_icache_flush_all();
   10bc0:	0012fe01 	jmpi	12fe0 <alt_icache_flush_all>
   10bc4:	00c00074 	movhi	r3,1
   10bc8:	18cc4b04 	addi	r3,r3,12588
   10bcc:	1907c83a 	sub	r3,r3,r4

static void ALT_INLINE alt_load_section (alt_u32* from, 
                                         alt_u32* to, 
                                         alt_u32* end)
{
  if (to != from)
   10bd0:	0005883a 	mov	r2,zero
  {
    while( to != end )
   10bd4:	18bff726 	beq	r3,r2,10bb4 <_gp+0xffff5724>
    {
      *to++ = *from++;
   10bd8:	114f883a 	add	r7,r2,r5
   10bdc:	39c00017 	ldw	r7,0(r7)
   10be0:	110d883a 	add	r6,r2,r4
   10be4:	10800104 	addi	r2,r2,4
   10be8:	31c00015 	stw	r7,0(r6)
   10bec:	003ff906 	br	10bd4 <_gp+0xffff5744>

00010bf0 <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   10bf0:	deffff04 	addi	sp,sp,-4
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   10bf4:	0009883a 	mov	r4,zero
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
   10bf8:	dfc00015 	stw	ra,0(sp)
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
   10bfc:	0010c800 	call	10c80 <alt_irq_init>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
   10c00:	0010ca00 	call	10ca0 <alt_sys_init>
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   10c04:	d1a0eb17 	ldw	r6,-31828(gp)
   10c08:	d160ec17 	ldw	r5,-31824(gp)
   10c0c:	d120ed17 	ldw	r4,-31820(gp)
  close(STDOUT_FILENO);
  exit (result);
#endif

  ALT_LOG_PRINT_BOOT("[alt_main.c] After main - we should not be here?.\r\n");
}
   10c10:	dfc00017 	ldw	ra,0(sp)
   10c14:	dec00104 	addi	sp,sp,4
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
   10c18:	001005c1 	jmpi	1005c <main>

00010c1c <usleep>:
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
  return alt_busy_sleep(us);
   10c1c:	0012e6c1 	jmpi	12e6c <alt_busy_sleep>

00010c20 <write>:
#if !defined(ALT_STDOUT_PRESENT) && !defined(ALT_STDERR_PRESENT)
    /* Generate a link time warning, should this function ever be called. */
    ALT_STUB_WARNING(write);
#endif

    switch (file) {
   10c20:	00800044 	movi	r2,1
   10c24:	20800226 	beq	r4,r2,10c30 <write+0x10>
   10c28:	00800084 	movi	r2,2
   10c2c:	2080041e 	bne	r4,r2,10c40 <write+0x20>
    case 1: /* stdout file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDOUT_DEV, ptr, len, 0);
#endif /* ALT_STDOUT_PRESENT */
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
   10c30:	01000074 	movhi	r4,1
   10c34:	000f883a 	mov	r7,zero
   10c38:	210e1204 	addi	r4,r4,14408
   10c3c:	0012e381 	jmpi	12e38 <altera_avalon_jtag_uart_write>

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
  return ((alt_errno) ? alt_errno() : &errno);
   10c40:	d0a00717 	ldw	r2,-32740(gp)
   10c44:	10000926 	beq	r2,zero,10c6c <write+0x4c>
 * Provide minimal version that just writes to the stdout/stderr devices
 * when provided.
 */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
   10c48:	deffff04 	addi	sp,sp,-4
   10c4c:	dfc00015 	stw	ra,0(sp)
   10c50:	103ee83a 	callr	r2
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   10c54:	00c01444 	movi	r3,81
   10c58:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   10c5c:	00bfffc4 	movi	r2,-1
   10c60:	dfc00017 	ldw	ra,0(sp)
   10c64:	dec00104 	addi	sp,sp,4
   10c68:	f800283a 	ret
   10c6c:	d0a0ea04 	addi	r2,gp,-31832
#ifdef ALT_STDERR_PRESENT
    case 2: /* stderr file descriptor */
        return ALT_DRIVER_WRITE(ALT_STDERR_DEV, ptr, len, 0);
#endif /* ALT_STDERR_PRESENT */
    default:
        ALT_ERRNO = EBADFD;
   10c70:	00c01444 	movi	r3,81
   10c74:	10c00015 	stw	r3,0(r2)
        return -1;
    }
}
   10c78:	00bfffc4 	movi	r2,-1
   10c7c:	f800283a 	ret

00010c80 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
   10c80:	deffff04 	addi	sp,sp,-4
   10c84:	dfc00015 	stw	ra,0(sp)
    ALTERA_NIOS2_GEN2_IRQ_INIT ( NIOS2_GEN2_0, nios2_gen2_0);
   10c88:	0012fe40 	call	12fe4 <altera_nios2_gen2_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts (void)
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
   10c8c:	00800044 	movi	r2,1
   10c90:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
   10c94:	dfc00017 	ldw	ra,0(sp)
   10c98:	dec00104 	addi	sp,sp,4
   10c9c:	f800283a 	ret

00010ca0 <alt_sys_init>:

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
   10ca0:	01000074 	movhi	r4,1
   10ca4:	d1600304 	addi	r5,gp,-32756
   10ca8:	210d0304 	addi	r4,r4,13324
   10cac:	0012f001 	jmpi	12f00 <alt_dev_llist_insert>

00010cb0 <filename_to_upper_case>:
}
 

void filename_to_upper_case(char *file_name)
// Change file name to upper case.
{
   10cb0:	defffe04 	addi	sp,sp,-8
   10cb4:	dc000015 	stw	r16,0(sp)
   10cb8:	dfc00115 	stw	ra,4(sp)
   10cbc:	2021883a 	mov	r16,r4
    int index;
    int length = strlen(file_name);
   10cc0:	00102540 	call	10254 <strlen>
    
    for (index = 0; index < length; index++)
   10cc4:	8007883a 	mov	r3,r16
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
   10cc8:	01800644 	movi	r6,25
// Change file name to upper case.
{
    int index;
    int length = strlen(file_name);
    
    for (index = 0; index < length; index++)
   10ccc:	1c09c83a 	sub	r4,r3,r16
   10cd0:	2080080e 	bge	r4,r2,10cf4 <filename_to_upper_case+0x44>
    {
        if ((file_name[index] >= 'a') && (file_name[index] <= 'z'))
   10cd4:	19000003 	ldbu	r4,0(r3)
   10cd8:	217fe7c4 	addi	r5,r4,-97
   10cdc:	29403fcc 	andi	r5,r5,255
   10ce0:	31400236 	bltu	r6,r5,10cec <filename_to_upper_case+0x3c>
        {
            file_name[index] = (file_name[index] - 'a') + 'A';
   10ce4:	213ff804 	addi	r4,r4,-32
   10ce8:	19000005 	stb	r4,0(r3)
   10cec:	18c00044 	addi	r3,r3,1
   10cf0:	003ff606 	br	10ccc <_gp+0xffff583c>
        }
    }
}
   10cf4:	dfc00117 	ldw	ra,4(sp)
   10cf8:	dc000017 	ldw	r16,0(sp)
   10cfc:	dec00204 	addi	sp,sp,8
   10d00:	f800283a 	ret

00010d04 <check_file_name_for_FAT16_compliance>:


bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
   10d04:	defffe04 	addi	sp,sp,-8
   10d08:	dc000015 	stw	r16,0(sp)
   10d0c:	dfc00115 	stw	ra,4(sp)
   10d10:	2021883a 	mov	r16,r4
    int length = strlen(file_name);
   10d14:	00102540 	call	10254 <strlen>
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
   10d18:	013fffc4 	movi	r4,-1
bool check_file_name_for_FAT16_compliance(char *file_name)
// Check if the file complies with FAT16 naming convention.
{
    int length = strlen(file_name);
    int index;
    int last_dir_break_position = -1;
   10d1c:	200d883a 	mov	r6,r4
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
   10d20:	0007883a 	mov	r3,zero
    {
        if ((file_name[index] == ' ') ||
   10d24:	02c00804 	movi	r11,32
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
   10d28:	01c01704 	movi	r7,92
   10d2c:	02000bc4 	movi	r8,47
   10d30:	03000244 	movi	r12,9
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
        {
            last_period = index;
            last_dir_break_position = index;
        }
        if (file_name[index] == '.')
   10d34:	02400b84 	movi	r9,46
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
   10d38:	034000c4 	movi	r13,3
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
   10d3c:	1880180e 	bge	r3,r2,10da0 <check_file_name_for_FAT16_compliance+0x9c>
    {
        if ((file_name[index] == ' ') ||
   10d40:	80cb883a 	add	r5,r16,r3
   10d44:	29400007 	ldb	r5,0(r5)
   10d48:	2ac01826 	beq	r5,r11,10dac <check_file_name_for_FAT16_compliance+0xa8>
   10d4c:	1abfffc4 	addi	r10,r3,-1
   10d50:	3280021e 	bne	r6,r10,10d5c <check_file_name_for_FAT16_compliance+0x58>
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
   10d54:	29c01526 	beq	r5,r7,10dac <check_file_name_for_FAT16_compliance+0xa8>
   10d58:	2a001426 	beq	r5,r8,10dac <check_file_name_for_FAT16_compliance+0xa8>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
   10d5c:	1915c83a 	sub	r10,r3,r4
    bool result = true;
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
   10d60:	5300021e 	bne	r10,r12,10d6c <check_file_name_for_FAT16_compliance+0x68>
            ((index - last_period == 9) && (file_name[index] != '.')) ||
   10d64:	2a401026 	beq	r5,r9,10da8 <check_file_name_for_FAT16_compliance+0xa4>
   10d68:	00001006 	br	10dac <check_file_name_for_FAT16_compliance+0xa8>
   10d6c:	31000426 	beq	r6,r4,10d80 <check_file_name_for_FAT16_compliance+0x7c>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
   10d70:	6a80030e 	bge	r13,r10,10d80 <check_file_name_for_FAT16_compliance+0x7c>
   10d74:	29c00626 	beq	r5,r7,10d90 <check_file_name_for_FAT16_compliance+0x8c>
             (file_name[index] != '\\') && (file_name[index] != '/'))
   10d78:	2a000526 	beq	r5,r8,10d90 <check_file_name_for_FAT16_compliance+0x8c>
   10d7c:	00000b06 	br	10dac <check_file_name_for_FAT16_compliance+0xa8>
           )
        {
            result = false;
            break;
        }
        if ((file_name[index] == '\\') || (file_name[index] == '/'))
   10d80:	29c00326 	beq	r5,r7,10d90 <check_file_name_for_FAT16_compliance+0x8c>
   10d84:	2a000226 	beq	r5,r8,10d90 <check_file_name_for_FAT16_compliance+0x8c>
        {
            last_period = index;
            last_dir_break_position = index;
        }
        if (file_name[index] == '.')
   10d88:	2a40031e 	bne	r5,r9,10d98 <check_file_name_for_FAT16_compliance+0x94>
   10d8c:	00000106 	br	10d94 <check_file_name_for_FAT16_compliance+0x90>
   10d90:	180d883a 	mov	r6,r3
   10d94:	1809883a 	mov	r4,r3
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
    
    for(index = 0; index < length; index++)
   10d98:	18c00044 	addi	r3,r3,1
   10d9c:	003fe706 	br	10d3c <_gp+0xffff58ac>
{
    int length = strlen(file_name);
    int index;
    int last_dir_break_position = -1;
    int last_period = -1;
    bool result = true;
   10da0:	00c00044 	movi	r3,1
   10da4:	00000206 	br	10db0 <check_file_name_for_FAT16_compliance+0xac>
    
    for(index = 0; index < length; index++)
    {
        if ((file_name[index] == ' ') ||
            ((last_dir_break_position == (index - 1)) && ((file_name[index] == '\\') || (file_name[index] == '/'))) ||
            ((index - last_period == 9) && (file_name[index] != '.')) ||
   10da8:	313ffa26 	beq	r6,r4,10d94 <_gp+0xffff5904>
            ((last_dir_break_position != last_period) && (index - last_period > 3) &&
             (file_name[index] != '\\') && (file_name[index] != '/'))
           )
        {
            result = false;
   10dac:	0007883a 	mov	r3,zero
        if (file_name[index] == '.')
        {
            last_period = index;
        }
    }
    if ((file_name[length-1] == '\\') || (file_name[length-1] == '/'))
   10db0:	8085883a 	add	r2,r16,r2
   10db4:	10bfffc7 	ldb	r2,-1(r2)
   10db8:	01001704 	movi	r4,92
   10dbc:	11000226 	beq	r2,r4,10dc8 <check_file_name_for_FAT16_compliance+0xc4>
   10dc0:	01000bc4 	movi	r4,47
   10dc4:	1100011e 	bne	r2,r4,10dcc <check_file_name_for_FAT16_compliance+0xc8>
    {
        result = false;
   10dc8:	0007883a 	mov	r3,zero
    }
    return result;
}
   10dcc:	1805883a 	mov	r2,r3
   10dd0:	dfc00117 	ldw	ra,4(sp)
   10dd4:	dc000017 	ldw	r16,0(sp)
   10dd8:	dec00204 	addi	sp,sp,8
   10ddc:	f800283a 	ret

00010de0 <get_dir_divider_location>:


int get_dir_divider_location(char *name)
// Find a directory divider location.
{
   10de0:	defffe04 	addi	sp,sp,-8
   10de4:	dc000015 	stw	r16,0(sp)
   10de8:	dfc00115 	stw	ra,4(sp)
   10dec:	2021883a 	mov	r16,r4
    int index = 0;
    int length = strlen(name);
   10df0:	00102540 	call	10254 <strlen>
   10df4:	1009883a 	mov	r4,r2
    
    for(index = 0; index < length; index++)
   10df8:	8007883a 	mov	r3,r16
    {
        if ((name[index] == '\\') || (name[index] == '/'))
   10dfc:	01801704 	movi	r6,92
   10e00:	01c00bc4 	movi	r7,47
   10e04:	1c05c83a 	sub	r2,r3,r16
// Find a directory divider location.
{
    int index = 0;
    int length = strlen(name);
    
    for(index = 0; index < length; index++)
   10e08:	1100050e 	bge	r2,r4,10e20 <get_dir_divider_location+0x40>
    {
        if ((name[index] == '\\') || (name[index] == '/'))
   10e0c:	19400007 	ldb	r5,0(r3)
   10e10:	29800526 	beq	r5,r6,10e28 <get_dir_divider_location+0x48>
   10e14:	18c00044 	addi	r3,r3,1
   10e18:	29fffa1e 	bne	r5,r7,10e04 <_gp+0xffff5974>
   10e1c:	00000206 	br	10e28 <get_dir_divider_location+0x48>
        {
            break;
        }
    }
    
    if (index == length)
   10e20:	2080011e 	bne	r4,r2,10e28 <get_dir_divider_location+0x48>
    {
        index = -1;
   10e24:	00bfffc4 	movi	r2,-1
    }
    
    return index;
}
   10e28:	dfc00117 	ldw	ra,4(sp)
   10e2c:	dc000017 	ldw	r16,0(sp)
   10e30:	dec00204 	addi	sp,sp,8
   10e34:	f800283a 	ret

00010e38 <match_file_record_to_name_ext>:


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
   10e38:	2011883a 	mov	r8,r4
   10e3c:	21c00204 	addi	r7,r4,8
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
   10e40:	02800644 	movi	r10,25
   10e44:	40800003 	ldbu	r2,0(r8)
   10e48:	10ffe7c4 	addi	r3,r2,-97
   10e4c:	18c03fcc 	andi	r3,r3,255
   10e50:	50c00336 	bltu	r10,r3,10e60 <match_file_record_to_name_ext+0x28>
   10e54:	10bff804 	addi	r2,r2,-32
   10e58:	10c03fcc 	andi	r3,r2,255
   10e5c:	00000306 	br	10e6c <match_file_record_to_name_ext+0x34>
   10e60:	10c03fcc 	andi	r3,r2,255
   10e64:	18c0201c 	xori	r3,r3,128
   10e68:	18ffe004 	addi	r3,r3,-128
   10e6c:	28800003 	ldbu	r2,0(r5)
   10e70:	127fe7c4 	addi	r9,r2,-97
   10e74:	4a403fcc 	andi	r9,r9,255
   10e78:	52400336 	bltu	r10,r9,10e88 <match_file_record_to_name_ext+0x50>
   10e7c:	10bff804 	addi	r2,r2,-32
   10e80:	10803fcc 	andi	r2,r2,255
   10e84:	00000306 	br	10e94 <match_file_record_to_name_ext+0x5c>
   10e88:	10803fcc 	andi	r2,r2,255
   10e8c:	1080201c 	xori	r2,r2,128
   10e90:	10bfe004 	addi	r2,r2,-128
   10e94:	1880051e 	bne	r3,r2,10eac <match_file_record_to_name_ext+0x74>
   10e98:	42000044 	addi	r8,r8,1
   10e9c:	29400044 	addi	r5,r5,1
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
	int index;

    for (index = 0; index < 8; index++)
   10ea0:	3a3fe81e 	bne	r7,r8,10e44 <_gp+0xffff59b4>


bool match_file_record_to_name_ext(t_file_record *file_record, char *name, char *extension)
/* See if the given name and extension match the file record. Return true if this is so, false otherwise. */
{
    bool match = true;
   10ea4:	00800044 	movi	r2,1
   10ea8:	00000106 	br	10eb0 <match_file_record_to_name_ext+0x78>

    for (index = 0; index < 8; index++)
    {
        if (CHAR_TO_UPPER(file_record->name[index]) != CHAR_TO_UPPER(name[index]))
        {
            match = false;
   10eac:	0005883a 	mov	r2,zero
   10eb0:	210002c4 	addi	r4,r4,11
			break;
        }
    }
    for (index = 0; index < 3; index++)
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
   10eb4:	02400644 	movi	r9,25
   10eb8:	38c00003 	ldbu	r3,0(r7)
   10ebc:	197fe7c4 	addi	r5,r3,-97
   10ec0:	29403fcc 	andi	r5,r5,255
   10ec4:	49400336 	bltu	r9,r5,10ed4 <match_file_record_to_name_ext+0x9c>
   10ec8:	18fff804 	addi	r3,r3,-32
   10ecc:	19403fcc 	andi	r5,r3,255
   10ed0:	00000306 	br	10ee0 <match_file_record_to_name_ext+0xa8>
   10ed4:	19403fcc 	andi	r5,r3,255
   10ed8:	2940201c 	xori	r5,r5,128
   10edc:	297fe004 	addi	r5,r5,-128
   10ee0:	30c00003 	ldbu	r3,0(r6)
   10ee4:	1a3fe7c4 	addi	r8,r3,-97
   10ee8:	42003fcc 	andi	r8,r8,255
   10eec:	4a000336 	bltu	r9,r8,10efc <match_file_record_to_name_ext+0xc4>
   10ef0:	18fff804 	addi	r3,r3,-32
   10ef4:	18c03fcc 	andi	r3,r3,255
   10ef8:	00000306 	br	10f08 <match_file_record_to_name_ext+0xd0>
   10efc:	18c03fcc 	andi	r3,r3,255
   10f00:	18c0201c 	xori	r3,r3,128
   10f04:	18ffe004 	addi	r3,r3,-128
   10f08:	28c0041e 	bne	r5,r3,10f1c <match_file_record_to_name_ext+0xe4>
   10f0c:	39c00044 	addi	r7,r7,1
   10f10:	31800044 	addi	r6,r6,1
        {
            match = false;
			break;
        }
    }
    for (index = 0; index < 3; index++)
   10f14:	21ffe81e 	bne	r4,r7,10eb8 <_gp+0xffff5a28>
   10f18:	f800283a 	ret
    {
        if (CHAR_TO_UPPER(file_record->extension[index]) != CHAR_TO_UPPER(extension[index]))
        {
            match = false;
   10f1c:	0005883a 	mov	r2,zero
			break;
        }
    }
	return match;
}
   10f20:	f800283a 	ret

00010f24 <convert_filename_to_name_extension>:
    return result;
}

void convert_filename_to_name_extension(char *filename, char *name, char *extension)
// This function converts the file name into a name . extension format.
{
   10f24:	2a000204 	addi	r8,r5,8
    int counter;
    int local = 0;
   10f28:	0005883a 	mov	r2,zero
    
    for(counter = 0; counter < 8; counter++)
    {
        if (filename[local] != '.')
   10f2c:	02400b84 	movi	r9,46
            name[counter] = filename[local];
            if (filename[local] != 0) local++;
        }
        else
        {
            name[counter] = ' ';
   10f30:	02800804 	movi	r10,32
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
    {
        if (filename[local] != '.')
   10f34:	2087883a 	add	r3,r4,r2
   10f38:	19c00003 	ldbu	r7,0(r3)
   10f3c:	3ac03fcc 	andi	r11,r7,255
   10f40:	5ac0201c 	xori	r11,r11,128
   10f44:	5affe004 	addi	r11,r11,-128
   10f48:	5a400526 	beq	r11,r9,10f60 <convert_filename_to_name_extension+0x3c>
        {
            name[counter] = filename[local];
   10f4c:	29c00005 	stb	r7,0(r5)
            if (filename[local] != 0) local++;
   10f50:	18c00007 	ldb	r3,0(r3)
   10f54:	18000326 	beq	r3,zero,10f64 <convert_filename_to_name_extension+0x40>
   10f58:	10800044 	addi	r2,r2,1
   10f5c:	00000106 	br	10f64 <convert_filename_to_name_extension+0x40>
        }
        else
        {
            name[counter] = ' ';
   10f60:	2a800005 	stb	r10,0(r5)
   10f64:	29400044 	addi	r5,r5,1
// This function converts the file name into a name . extension format.
{
    int counter;
    int local = 0;
    
    for(counter = 0; counter < 8; counter++)
   10f68:	2a3ff21e 	bne	r5,r8,10f34 <_gp+0xffff5aa4>
        else
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
   10f6c:	2087883a 	add	r3,r4,r2
   10f70:	19400007 	ldb	r5,0(r3)
   10f74:	00c00b84 	movi	r3,46
   10f78:	28c0011e 	bne	r5,r3,10f80 <convert_filename_to_name_extension+0x5c>
   10f7c:	10800044 	addi	r2,r2,1
   10f80:	314000c4 	addi	r5,r6,3
            extension[counter] = filename[local];
            local++;
        }
        else
        {
            extension[counter] = ' ';
   10f84:	01c00804 	movi	r7,32
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
    {
        if (filename[local] != 0)
   10f88:	2087883a 	add	r3,r4,r2
   10f8c:	18c00003 	ldbu	r3,0(r3)
   10f90:	1a003fcc 	andi	r8,r3,255
   10f94:	4200201c 	xori	r8,r8,128
   10f98:	423fe004 	addi	r8,r8,-128
   10f9c:	40000326 	beq	r8,zero,10fac <convert_filename_to_name_extension+0x88>
        {
            extension[counter] = filename[local];
   10fa0:	30c00005 	stb	r3,0(r6)
            local++;
   10fa4:	10800044 	addi	r2,r2,1
   10fa8:	00000106 	br	10fb0 <convert_filename_to_name_extension+0x8c>
        }
        else
        {
            extension[counter] = ' ';
   10fac:	31c00005 	stb	r7,0(r6)
   10fb0:	31800044 	addi	r6,r6,1
        {
            name[counter] = ' ';
        }
    }
    if (filename[local] == '.') local++;
    for(counter = 0; counter < 3; counter++)
   10fb4:	29bff41e 	bne	r5,r6,10f88 <_gp+0xffff5af8>
        {
            extension[counter] = ' ';
        }
    }

}
   10fb8:	f800283a 	ret

00010fbc <copy_file_record_name_to_string>:
}


void copy_file_record_name_to_string(t_file_record *file_record, char *file_name)
/* Copy a file name from the file record to a given string */
{
   10fbc:	200d883a 	mov	r6,r4
   10fc0:	20c00204 	addi	r3,r4,8
	int index;
	int flength = 0;
   10fc4:	0005883a 	mov	r2,zero

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
	{
		if (file_record->name[index] != ' ')
   10fc8:	02000804 	movi	r8,32
   10fcc:	31c00003 	ldbu	r7,0(r6)
   10fd0:	3a403fcc 	andi	r9,r7,255
   10fd4:	4a000326 	beq	r9,r8,10fe4 <copy_file_record_name_to_string+0x28>
		{
			file_name[flength] = file_record->name[index];
   10fd8:	2893883a 	add	r9,r5,r2
   10fdc:	49c00005 	stb	r7,0(r9)
			flength = flength + 1;
   10fe0:	10800044 	addi	r2,r2,1
   10fe4:	31800044 	addi	r6,r6,1
{
	int index;
	int flength = 0;

	/* Copy file name.*/
	for (index = 0; index < 8; index++)
   10fe8:	30fff81e 	bne	r6,r3,10fcc <_gp+0xffff5b3c>
		{
			file_name[flength] = file_record->name[index];
			flength = flength + 1;
		}
	}
	if (file_record->extension[0] != ' ')
   10fec:	21c00203 	ldbu	r7,8(r4)
   10ff0:	01800804 	movi	r6,32
   10ff4:	39800e26 	beq	r7,r6,11030 <copy_file_record_name_to_string+0x74>
	{
		file_name[flength] = '.';
   10ff8:	288d883a 	add	r6,r5,r2
   10ffc:	01c00b84 	movi	r7,46
   11000:	31c00005 	stb	r7,0(r6)
		flength = flength + 1;
   11004:	10800044 	addi	r2,r2,1
   11008:	210002c4 	addi	r4,r4,11
		for (index = 0; index < 3; index++)
		{
			if (file_record->extension[index] != ' ')
   1100c:	01c00804 	movi	r7,32
   11010:	19800003 	ldbu	r6,0(r3)
   11014:	32003fcc 	andi	r8,r6,255
   11018:	41c00326 	beq	r8,r7,11028 <copy_file_record_name_to_string+0x6c>
			{
				file_name[flength] = file_record->extension[index];
   1101c:	2891883a 	add	r8,r5,r2
   11020:	41800005 	stb	r6,0(r8)
				flength = flength + 1;
   11024:	10800044 	addi	r2,r2,1
   11028:	18c00044 	addi	r3,r3,1
	}
	if (file_record->extension[0] != ' ')
	{
		file_name[flength] = '.';
		flength = flength + 1;
		for (index = 0; index < 3; index++)
   1102c:	20fff81e 	bne	r4,r3,11010 <_gp+0xffff5b80>
				file_name[flength] = file_record->extension[index];
				flength = flength + 1;
			}
		}
	}
	file_name[flength] = 0;
   11030:	2885883a 	add	r2,r5,r2
   11034:	10000005 	stb	zero,0(r2)
   11038:	f800283a 	ret

0001103c <alt_up_sd_card_open_dev>:
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
   1103c:	deffff04 	addi	sp,sp,-4
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
   11040:	d1600304 	addi	r5,gp,-32756
// Direct functions
///////////////////////////////////////////////////////////////////////////


alt_up_sd_card_dev* alt_up_sd_card_open_dev(const char* name)
{
   11044:	dfc00015 	stw	ra,0(sp)
	// find the device from the device list 
	// (see altera_hal/HAL/inc/priv/alt_file.h 
	// and altera_hal/HAL/src/alt_find_dev.c 
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);
   11048:	0012f6c0 	call	12f6c <alt_find_dev>

	if (dev != NULL)
   1104c:	10001226 	beq	r2,zero,11098 <alt_up_sd_card_open_dev+0x5c>
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
   11050:	10c00a17 	ldw	r3,40(r2)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
   11054:	d0a0f115 	stw	r2,-31804(gp)
		initialized = false;
   11058:	d020fb15 	stw	zero,-31764(gp)
	// for details)
	alt_up_sd_card_dev *dev = (alt_up_sd_card_dev *) alt_find_dev(name, &alt_dev_list);

	if (dev != NULL)
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
   1105c:	19008d04 	addi	r4,r3,564
   11060:	d120f915 	stw	r4,-31772(gp)
		status_register = ((int *) SD_CARD_STATUS(dev->base));
   11064:	19008904 	addi	r4,r3,548
   11068:	d120f815 	stw	r4,-31776(gp)
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
   1106c:	19008404 	addi	r4,r3,528
   11070:	d120f715 	stw	r4,-31780(gp)
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
   11074:	19008c04 	addi	r4,r3,560
   11078:	d120f615 	stw	r4,-31784(gp)
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
   1107c:	d0e0f415 	stw	r3,-31792(gp)
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
   11080:	19008b04 	addi	r4,r3,556
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
		search_data.valid = false;
   11084:	00c00074 	movhi	r3,1
   11088:	18ce2004 	addi	r3,r3,14464
	{
		aux_status_register = ((short int *) SD_CARD_AUX_STATUS(dev->base));
		status_register = ((int *) SD_CARD_STATUS(dev->base));
		CSD_register_w0 = ((short int *) SD_CARD_CSD(dev->base, 0));
		command_register = ((short int *) SD_CARD_COMMAND(dev->base));
		command_argument_register = ((int *) SD_CARD_ARGUMENT(dev->base));
   1108c:	d120f515 	stw	r4,-31788(gp)
		buffer_memory = (char *) SD_CARD_BUFFER(dev->base, 0);
		device_pointer = dev;
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
   11090:	d020fa15 	stw	zero,-31768(gp)
		search_data.valid = false;
   11094:	18000415 	stw	zero,16(r3)
	}
	return dev;
}
   11098:	dfc00017 	ldw	ra,0(sp)
   1109c:	dec00104 	addi	sp,sp,4
   110a0:	f800283a 	ret

000110a4 <alt_up_sd_card_is_Present>:
bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
   110a4:	d0e0f117 	ldw	r3,-31804(gp)
   110a8:	00800044 	movi	r2,1
   110ac:	1800031e 	bne	r3,zero,110bc <alt_up_sd_card_is_Present+0x18>
    {
        result = true;
    }
	else if (initialized == true)
   110b0:	d0e0fb17 	ldw	r3,-31764(gp)
   110b4:	1880131e 	bne	r3,r2,11104 <alt_up_sd_card_is_Present+0x60>
   110b8:	00000506 	br	110d0 <alt_up_sd_card_is_Present+0x2c>
bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;

    if ((device_pointer != NULL) && ((IORD_16DIRECT(aux_status_register,0) & 0x02) != 0))
   110bc:	d0e0f917 	ldw	r3,-31772(gp)
   110c0:	18c0002b 	ldhuio	r3,0(r3)
   110c4:	18c0008c 	andi	r3,r3,2
   110c8:	183ff926 	beq	r3,zero,110b0 <_gp+0xffff5c20>
   110cc:	f800283a 	ret
	else if (initialized == true)
	{
		int index;

		initialized = false;
		search_data.valid = false;
   110d0:	00800074 	movhi	r2,1
   110d4:	108e2004 	addi	r2,r2,14464
   110d8:	10000415 	stw	zero,16(r2)
   110dc:	00800074 	movhi	r2,1
    }
	else if (initialized == true)
	{
		int index;

		initialized = false;
   110e0:	d020fb15 	stw	zero,-31764(gp)
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;
   110e4:	d020fa15 	stw	zero,-31768(gp)
   110e8:	108e4904 	addi	r2,r2,14628
   110ec:	00c00504 	movi	r3,20

		for(index = 0; index < MAX_FILES_OPENED; index++)
		{
			active_files[index].in_use = false;
   110f0:	10000015 	stw	zero,0(r2)
			active_files[index].modified = false;
   110f4:	103fff15 	stw	zero,-4(r2)
   110f8:	18ffffc4 	addi	r3,r3,-1
   110fc:	10801004 	addi	r2,r2,64

		initialized = false;
		search_data.valid = false;
		is_sd_card_formated_as_FAT16 = false;

		for(index = 0; index < MAX_FILES_OPENED; index++)
   11100:	183ffb1e 	bne	r3,zero,110f0 <_gp+0xffff5c60>


bool alt_up_sd_card_is_Present(void)
// Check if there is an SD Card insterted into the SD Card socket.
{
    bool result = false;
   11104:	0005883a 	mov	r2,zero
   11108:	f800283a 	ret

0001110c <Write_Sector_Data>:
///////////////////////////////////////////////////////////////////////////

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
   1110c:	defffd04 	addi	sp,sp,-12
   11110:	dc400115 	stw	r17,4(sp)
   11114:	dc000015 	stw	r16,0(sp)
   11118:	dfc00215 	stw	ra,8(sp)
   1111c:	2023883a 	mov	r17,r4
   11120:	2821883a 	mov	r16,r5
    bool result = false;
    
    if (alt_up_sd_card_is_Present())
   11124:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   11128:	1000021e 	bne	r2,zero,11134 <Write_Sector_Data+0x28>

        
bool Write_Sector_Data(int sector_index, int partition_offset)
// This function writes a sector at the specified address on the SD Card.
{
    bool result = false;
   1112c:	0005883a 	mov	r2,zero
   11130:	00001106 	br	11178 <Write_Sector_Data+0x6c>
    {
        short int reg_state = 0xff;

		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
         * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
   11134:	8c09883a 	add	r4,r17,r16
   11138:	2006927a 	slli	r3,r4,9
   1113c:	d0a0f517 	ldw	r2,-31788(gp)
   11140:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_WRITE_BLOCK);
   11144:	d0a0f617 	ldw	r2,-31784(gp)
   11148:	00c00604 	movi	r3,24
   1114c:	10c0002d 	sthio	r3,0(r2)
        do {
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
   11150:	d0a0f917 	ldw	r2,-31772(gp)
   11154:	1080002b 	ldhuio	r2,0(r2)
   11158:	10bfffcc 	andi	r2,r2,65535
        } while ((reg_state & 0x04)!=0);
   1115c:	10c0010c 	andi	r3,r2,4
   11160:	183ffb1e 	bne	r3,zero,11150 <_gp+0xffff5cc0>
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
   11164:	1080040c 	andi	r2,r2,16
   11168:	103ff01e 	bne	r2,zero,1112c <_gp+0xffff5c9c>
        {
            result = true;
            current_sector_modified = false;
   1116c:	d020f015 	stw	zero,-31808(gp)
            current_sector_index = sector_index+partition_offset;
   11170:	d120ef15 	stw	r4,-31812(gp)
            reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
        } while ((reg_state & 0x04)!=0);
        // Make sure the request did not time out.
        if ((reg_state & 0x10) == 0)
        {
            result = true;
   11174:	00800044 	movi	r2,1
            current_sector_modified = false;
            current_sector_index = sector_index+partition_offset;
        }
    }
    return result;
}
   11178:	dfc00217 	ldw	ra,8(sp)
   1117c:	dc400117 	ldw	r17,4(sp)
   11180:	dc000017 	ldw	r16,0(sp)
   11184:	dec00304 	addi	sp,sp,12
   11188:	f800283a 	ret

0001118c <Save_Modified_Sector>:

bool Save_Modified_Sector()
// If the sector has been modified, then save it to the SD Card.
{
    bool result = true;
    if (current_sector_modified)
   1118c:	d0a0f017 	ldw	r2,-31808(gp)
   11190:	10000326 	beq	r2,zero,111a0 <Save_Modified_Sector+0x14>
    {
        result = Write_Sector_Data(current_sector_index, 0);
   11194:	d120ef17 	ldw	r4,-31812(gp)
   11198:	000b883a 	mov	r5,zero
   1119c:	001110c1 	jmpi	1110c <Write_Sector_Data>
    }
    return result;
}
   111a0:	00800044 	movi	r2,1
   111a4:	f800283a 	ret

000111a8 <Read_Sector_Data>:


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
   111a8:	defffd04 	addi	sp,sp,-12
   111ac:	dc400115 	stw	r17,4(sp)
   111b0:	dc000015 	stw	r16,0(sp)
   111b4:	dfc00215 	stw	ra,8(sp)
   111b8:	2023883a 	mov	r17,r4
   111bc:	2821883a 	mov	r16,r5
	bool result = false;
    
	if (alt_up_sd_card_is_Present())
   111c0:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   111c4:	1000021e 	bne	r2,zero,111d0 <Read_Sector_Data+0x28>


bool Read_Sector_Data(int sector_index, int partition_offset)
// This function reads a sector at the specified address on the SD Card.
{
	bool result = false;
   111c8:	0005883a 	mov	r2,zero
   111cc:	00001906 	br	11234 <Read_Sector_Data+0x8c>
	if (alt_up_sd_card_is_Present())
	{
		short int reg_state = 0xff;
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
   111d0:	d0a0f017 	ldw	r2,-31808(gp)
   111d4:	1000081e 	bne	r2,zero,111f8 <Read_Sector_Data+0x50>
                return false;
            }
        }
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
   111d8:	8c09883a 	add	r4,r17,r16
   111dc:	2006927a 	slli	r3,r4,9
   111e0:	d0a0f517 	ldw	r2,-31788(gp)
   111e4:	10c00035 	stwio	r3,0(r2)
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
   111e8:	d0a0f617 	ldw	r2,-31784(gp)
   111ec:	00c00444 	movi	r3,17
   111f0:	10c0002d 	sthio	r3,0(r2)
   111f4:	00000506 	br	1120c <Read_Sector_Data+0x64>
		short int reg_state = 0xff;
        
        /* Write data to the SD card if the current buffer is out of date. */
        if (current_sector_modified)
        {
            if (Write_Sector_Data(current_sector_index, 0) == false)
   111f8:	d120ef17 	ldw	r4,-31812(gp)
   111fc:	000b883a 	mov	r5,zero
   11200:	001110c0 	call	1110c <Write_Sector_Data>
   11204:	103ff41e 	bne	r2,zero,111d8 <_gp+0xffff5d48>
   11208:	003fef06 	br	111c8 <_gp+0xffff5d38>
		/* Multiply sector offset by sector size to get the address. Sector size is 512. Also,
		 * the SD card reads data in 512 byte chunks, so the address must be a multiple of 512. */
        IOWR_32DIRECT(command_argument_register, 0, (sector_index + partition_offset)*512);
        IOWR_16DIRECT(command_register, 0, CMD_READ_BLOCK);
		do {
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
   1120c:	d0a0f917 	ldw	r2,-31772(gp)
   11210:	1080002b 	ldhuio	r2,0(r2)
   11214:	10bfffcc 	andi	r2,r2,65535
		} while ((reg_state & 0x04)!=0);
   11218:	10c0010c 	andi	r3,r2,4
   1121c:	183ffb1e 	bne	r3,zero,1120c <_gp+0xffff5d7c>
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
   11220:	1080040c 	andi	r2,r2,16
   11224:	103fe81e 	bne	r2,zero,111c8 <_gp+0xffff5d38>
		{
			result = true;
            current_sector_modified = false;
   11228:	d020f015 	stw	zero,-31808(gp)
            current_sector_index = sector_index+partition_offset;
   1122c:	d120ef15 	stw	r4,-31812(gp)
			reg_state = (short int) IORD_16DIRECT(aux_status_register,0);
		} while ((reg_state & 0x04)!=0);
		// Make sure the request did not time out.
		if ((reg_state & 0x10) == 0)
		{
			result = true;
   11230:	00800044 	movi	r2,1
            current_sector_modified = false;
            current_sector_index = sector_index+partition_offset;
		}
	}
	return result;
}
   11234:	dfc00217 	ldw	ra,8(sp)
   11238:	dc400117 	ldw	r17,4(sp)
   1123c:	dc000017 	ldw	r16,0(sp)
   11240:	dec00304 	addi	sp,sp,12
   11244:	f800283a 	ret

00011248 <get_cluster_flag>:
bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
   11248:	00800074 	movhi	r2,1
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
   1124c:	defffd04 	addi	sp,sp,-12
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
   11250:	108e2504 	addi	r2,r2,14484
   11254:	10801117 	ldw	r2,68(r2)
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
   11258:	dc000015 	stw	r16,0(sp)
   1125c:	2021883a 	mov	r16,r4
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
   11260:	d120f317 	ldw	r4,-31796(gp)
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
   11264:	dc400115 	stw	r17,4(sp)
   11268:	dfc00215 	stw	ra,8(sp)
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
   1126c:	2089883a 	add	r4,r4,r2
   11270:	8004d23a 	srli	r2,r16,8
}


bool get_cluster_flag(unsigned int cluster_index, unsigned short int *flag)
// Read a cluster flag.
{
   11274:	2823883a 	mov	r17,r5
    unsigned int sector_index = (cluster_index / 256) + fat_partition_offset_in_512_byte_sectors;
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
   11278:	2089883a 	add	r4,r4,r2
     
    if (sector_index != current_sector_index)
   1127c:	d0a0ef17 	ldw	r2,-31812(gp)
   11280:	2080091e 	bne	r4,r2,112a8 <get_cluster_flag+0x60>
        if (Read_Sector_Data(sector_index, 0) == false)
        {
            return false;
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
   11284:	d0a0f117 	ldw	r2,-31804(gp)
   11288:	84003fcc 	andi	r16,r16,255
   1128c:	8421883a 	add	r16,r16,r16
   11290:	10800a17 	ldw	r2,40(r2)
   11294:	80a1883a 	add	r16,r16,r2
   11298:	8080002b 	ldhuio	r2,0(r16)
   1129c:	8880000d 	sth	r2,0(r17)
    return true;
   112a0:	00800044 	movi	r2,1
   112a4:	00000306 	br	112b4 <get_cluster_flag+0x6c>
    
    sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
     
    if (sector_index != current_sector_index)
    {
        if (Read_Sector_Data(sector_index, 0) == false)
   112a8:	000b883a 	mov	r5,zero
   112ac:	00111a80 	call	111a8 <Read_Sector_Data>
   112b0:	103ff41e 	bne	r2,zero,11284 <_gp+0xffff5df4>
            return false;
        }
    }
    *flag = (unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256));
    return true;
}
   112b4:	dfc00217 	ldw	ra,8(sp)
   112b8:	dc400117 	ldw	r17,4(sp)
   112bc:	dc000017 	ldw	r16,0(sp)
   112c0:	dec00304 	addi	sp,sp,12
   112c4:	f800283a 	ret

000112c8 <mark_cluster>:


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
   112c8:	defffd04 	addi	sp,sp,-12
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
   112cc:	d0a0f317 	ldw	r2,-31796(gp)
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
   112d0:	dc000015 	stw	r16,0(sp)
   112d4:	2021883a 	mov	r16,r4
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
   112d8:	2008d23a 	srli	r4,r4,8
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
   112dc:	dc400115 	stw	r17,4(sp)
   112e0:	dfc00215 	stw	ra,8(sp)
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
   112e4:	2089883a 	add	r4,r4,r2
   112e8:	00800074 	movhi	r2,1
}


bool mark_cluster(unsigned int cluster_index, short int flag, bool first_fat)
// Place a marker on the specified cluster in a given FAT.
{
   112ec:	2823883a 	mov	r17,r5
   112f0:	108e2504 	addi	r2,r2,14484
    unsigned int sector_index = (cluster_index / 256) +  fat_partition_offset_in_512_byte_sectors;
    
    if (first_fat)
   112f4:	30000226 	beq	r6,zero,11300 <mark_cluster+0x38>
    {
        sector_index  = sector_index + boot_sector_data.first_fat_sector_offset;
   112f8:	10801117 	ldw	r2,68(r2)
   112fc:	00000106 	br	11304 <mark_cluster+0x3c>
    }
    else
    {
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
   11300:	10801217 	ldw	r2,72(r2)
   11304:	2089883a 	add	r4,r4,r2
    }
     
    if (sector_index != current_sector_index)
   11308:	d0a0ef17 	ldw	r2,-31812(gp)
   1130c:	2080091e 	bne	r4,r2,11334 <mark_cluster+0x6c>
        if (Read_Sector_Data(sector_index, 0) == false)
        {
            return false;
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
   11310:	d0a0f117 	ldw	r2,-31804(gp)
   11314:	84003fcc 	andi	r16,r16,255
   11318:	8421883a 	add	r16,r16,r16
   1131c:	10800a17 	ldw	r2,40(r2)
   11320:	80a1883a 	add	r16,r16,r2
   11324:	8440002d 	sthio	r17,0(r16)
    current_sector_modified = true;
   11328:	00800044 	movi	r2,1
   1132c:	d0a0f015 	stw	r2,-31808(gp)
    return true;
   11330:	00000306 	br	11340 <mark_cluster+0x78>
        sector_index  = sector_index + boot_sector_data.second_fat_sector_offset;
    }
     
    if (sector_index != current_sector_index)
    {
        if (Read_Sector_Data(sector_index, 0) == false)
   11334:	000b883a 	mov	r5,zero
   11338:	00111a80 	call	111a8 <Read_Sector_Data>
   1133c:	103ff41e 	bne	r2,zero,11310 <_gp+0xffff5e80>
        }
    }
    IOWR_16DIRECT(device_pointer->base, 2*(cluster_index % 256), flag);
    current_sector_modified = true;
    return true;
}
   11340:	dfc00217 	ldw	ra,8(sp)
   11344:	dc400117 	ldw	r17,4(sp)
   11348:	dc000017 	ldw	r16,0(sp)
   1134c:	dec00304 	addi	sp,sp,12
   11350:	f800283a 	ret

00011354 <Check_for_Master_Boot_Record>:

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
   11354:	deffff04 	addi	sp,sp,-4
	bool result = false;
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
   11358:	000b883a 	mov	r5,zero
   1135c:	0009883a 	mov	r4,zero

bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
   11360:	dfc00015 	stw	ra,0(sp)
	bool result = false;
	int index;
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
   11364:	00111a80 	call	111a8 <Read_Sector_Data>
   11368:	1000021e 	bne	r2,zero,11374 <Check_for_Master_Boot_Record+0x20>
bool Check_for_Master_Boot_Record(void)
// This function reads the first 512 bytes on the SD Card. This data should
// contain the Master Boot Record. If it does, then print
// relevant information and return true. Otherwise, return false. 
{
	bool result = false;
   1136c:	0005883a 	mov	r2,zero
   11370:	00003706 	br	11450 <Check_for_Master_Boot_Record+0xfc>
	int end, offset, partition_size;

	/* Load the first 512 bytes of data from SD card. */
	if (Read_Sector_Data(0, 0))
	{
		end =  (short int) IORD_16DIRECT(device_pointer->base,0x1fe);
   11374:	d1e0f117 	ldw	r7,-31804(gp)
   11378:	38800a17 	ldw	r2,40(r7)

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
   1137c:	10807faf 	ldhio	r2,510(r2)
   11380:	00ea9554 	movui	r3,43605
   11384:	10bfffcc 	andi	r2,r2,65535
   11388:	10fff81e 	bne	r2,r3,1136c <_gp+0xffff5edc>
   1138c:	00806f84 	movi	r2,446
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
   11390:	02400044 	movi	r9,1
   11394:	02bfff44 	movi	r10,-3
   11398:	02c00104 	movi	r11,4
   1139c:	03000384 	movi	r12,14

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
   113a0:	02007f84 	movi	r8,510
			{
				int partition_data_offset = (index * 16) + 0x01be;
				char type;
		        
				// Read Partition type
				type = (unsigned char) IORD_8DIRECT(device_pointer->base,partition_data_offset + 0x04);
   113a4:	38c00a17 	ldw	r3,40(r7)
   113a8:	18c00104 	addi	r3,r3,4
   113ac:	1887883a 	add	r3,r3,r2
   113b0:	18c00023 	ldbuio	r3,0(r3)

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
   113b4:	19003fcc 	andi	r4,r3,255
   113b8:	2100201c 	xori	r4,r4,128
   113bc:	213fe004 	addi	r4,r4,-128
   113c0:	22400626 	beq	r4,r9,113dc <Check_for_Master_Boot_Record+0x88>
   113c4:	50c6703a 	and	r3,r10,r3
   113c8:	18c03fcc 	andi	r3,r3,255
   113cc:	18c0201c 	xori	r3,r3,128
   113d0:	18ffe004 	addi	r3,r3,-128
   113d4:	1ac00126 	beq	r3,r11,113dc <Check_for_Master_Boot_Record+0x88>
   113d8:	23001a1e 	bne	r4,r12,11444 <Check_for_Master_Boot_Record+0xf0>
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
   113dc:	38c00a17 	ldw	r3,40(r7)
   113e0:	19000284 	addi	r4,r3,10
   113e4:	2089883a 	add	r4,r4,r2
   113e8:	2140002b 	ldhuio	r5,0(r4)
   113ec:	19000204 	addi	r4,r3,8
   113f0:	297fffcc 	andi	r5,r5,65535
   113f4:	2089883a 	add	r4,r4,r2
   113f8:	2100002b 	ldhuio	r4,0(r4)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
   113fc:	19800384 	addi	r6,r3,14

				// Check if this is an FAT parition
				if ((type == 1) || (type == 4) || (type == 6) || (type == 14))
				{
					// Get partition offset and size.
					offset = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0A)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x08));
   11400:	213fffcc 	andi	r4,r4,65535
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
   11404:	308d883a 	add	r6,r6,r2
   11408:	3180002b 	ldhuio	r6,0(r6)
   1140c:	18c00304 	addi	r3,r3,12
   11410:	31bfffcc 	andi	r6,r6,65535
   11414:	1887883a 	add	r3,r3,r2
   11418:	18c0002b 	ldhuio	r3,0(r3)
   1141c:	300c943a 	slli	r6,r6,16
   11420:	18ffffcc 	andi	r3,r3,65535
   11424:	30c6b03a 	or	r3,r6,r3
		            
					// Check if the partition is valid
					if (partition_size > 0)
   11428:	00c0060e 	bge	zero,r3,11444 <Check_for_Master_Boot_Record+0xf0>
					{
						result = true;
						fat_partition_size_in_512_byte_sectors = partition_size;
						fat_partition_offset_in_512_byte_sectors = offset;
   1142c:	2804943a 	slli	r2,r5,16
		            
					// Check if the partition is valid
					if (partition_size > 0)
					{
						result = true;
						fat_partition_size_in_512_byte_sectors = partition_size;
   11430:	d0e0f215 	stw	r3,-31800(gp)
						fat_partition_offset_in_512_byte_sectors = offset;
   11434:	1104b03a 	or	r2,r2,r4
   11438:	d0a0f315 	stw	r2,-31796(gp)
					partition_size = (((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0E)) << 16) | ((unsigned short int) IORD_16DIRECT(device_pointer->base,partition_data_offset + 0x0C));
		            
					// Check if the partition is valid
					if (partition_size > 0)
					{
						result = true;
   1143c:	00800044 	movi	r2,1
   11440:	00000306 	br	11450 <Check_for_Master_Boot_Record+0xfc>
   11444:	10800404 	addi	r2,r2,16

		// Check if the end of the sector contains an end string 0xaa55.
		if ((end & 0x0000ffff) == 0x0000aa55)
		{
			// Check four partition entries and see if any are valid
			for (index = 0; index < 4; index++)
   11448:	123fd61e 	bne	r2,r8,113a4 <_gp+0xffff5f14>
   1144c:	003fc706 	br	1136c <_gp+0xffff5edc>
			}
		}
	}

	return result;
}
   11450:	dfc00017 	ldw	ra,0(sp)
   11454:	dec00104 	addi	sp,sp,4
   11458:	f800283a 	ret

0001145c <Check_for_DOS_FAT>:
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
   1145c:	defffa04 	addi	sp,sp,-24
	bool result = false;
	int counter = 0;
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
   11460:	200b883a 	mov	r5,r4
   11464:	0009883a 	mov	r4,zero
// This function reads the boot sector for the FAT file system on the SD Card.
// The offset_address should point to the sector on the card where the boot sector is located.
// The sector number is specified either in the master Boot Record, or is 0 by default for a purely FAT
// based file system. If the specified sector contains a FAT boot sector, then this function prints the
// relevant information and returns 1. Otherwise, it returns 0. 
{
   11468:	dcc00315 	stw	r19,12(sp)
   1146c:	dfc00515 	stw	ra,20(sp)
   11470:	dd000415 	stw	r20,16(sp)
   11474:	dc800215 	stw	r18,8(sp)
   11478:	dc400115 	stw	r17,4(sp)
   1147c:	dc000015 	stw	r16,0(sp)
	bool result = false;
	int counter = 0;
	short int end;

	result = Read_Sector_Data(0, FAT_partition_start_sector);
   11480:	00111a80 	call	111a8 <Read_Sector_Data>
	end =  (short int) IORD_16DIRECT(device_pointer->base, 0x1fe);
   11484:	d4e0f117 	ldw	r19,-31804(gp)
   11488:	98c00a17 	ldw	r3,40(r19)
	if (((end & 0x0000ffff) == 0x0000aa55) && (result))
   1148c:	19007faf 	ldhio	r4,510(r3)
   11490:	016a9554 	movui	r5,43605
   11494:	213fffcc 	andi	r4,r4,65535
   11498:	2140921e 	bne	r4,r5,116e4 <Check_for_DOS_FAT+0x288>
   1149c:	10009226 	beq	r2,zero,116e8 <Check_for_DOS_FAT+0x28c>
	{
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
   114a0:	18800023 	ldbuio	r2,0(r3)
   114a4:	04000074 	movhi	r16,1
   114a8:	840e2504 	addi	r16,r16,14484
   114ac:	80800005 	stb	r2,0(r16)
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
   114b0:	18800063 	ldbuio	r2,1(r3)
   114b4:	80800045 	stb	r2,1(r16)
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
   114b8:	188000a3 	ldbuio	r2,2(r3)
		for (counter = 0; counter < 8; counter++)
   114bc:	0007883a 	mov	r3,zero
	{
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
   114c0:	80800085 	stb	r2,2(r16)
   114c4:	810000c4 	addi	r4,r16,3
		for (counter = 0; counter < 8; counter++)
   114c8:	01400204 	movi	r5,8
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
   114cc:	98800a17 	ldw	r2,40(r19)
   114d0:	108000c4 	addi	r2,r2,3
   114d4:	10c5883a 	add	r2,r2,r3
   114d8:	10800023 	ldbuio	r2,0(r2)
   114dc:	20800005 	stb	r2,0(r4)
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
   114e0:	18c00044 	addi	r3,r3,1
   114e4:	21000044 	addi	r4,r4,1
   114e8:	197ff81e 	bne	r3,r5,114cc <_gp+0xffff603c>
		{
			boot_sector_data.OEM_name[counter] = (char) IORD_8DIRECT(device_pointer->base, 3+counter);
		}
		boot_sector_data.sector_size_in_bytes = (((unsigned char) IORD_8DIRECT(device_pointer->base, 12)) << 8 ) | ((char) IORD_8DIRECT(device_pointer->base, 11));
   114ec:	98800a17 	ldw	r2,40(r19)
   114f0:	11000323 	ldbuio	r4,12(r2)
   114f4:	21003fcc 	andi	r4,r4,255
   114f8:	10c002e3 	ldbuio	r3,11(r2)
   114fc:	2008923a 	slli	r4,r4,8
   11500:	18c03fcc 	andi	r3,r3,255
   11504:	18c0201c 	xori	r3,r3,128
   11508:	18ffe004 	addi	r3,r3,-128
   1150c:	20c6b03a 	or	r3,r4,r3
   11510:	80c0030d 	sth	r3,12(r16)
		boot_sector_data.sectors_per_cluster = ((unsigned char) IORD_8DIRECT(device_pointer->base, 13));
   11514:	10c00363 	ldbuio	r3,13(r2)
   11518:	80c00385 	stb	r3,14(r16)
		boot_sector_data.reserved_sectors = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 14));
   1151c:	10c003ab 	ldhuio	r3,14(r2)
   11520:	80c0040d 	sth	r3,16(r16)
		boot_sector_data.number_of_FATs = ((unsigned char) IORD_8DIRECT(device_pointer->base, 16));
   11524:	10c00423 	ldbuio	r3,16(r2)
   11528:	80c00485 	stb	r3,18(r16)
		boot_sector_data.max_number_of_dir_entires = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 18)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 17));
   1152c:	110004a3 	ldbuio	r4,18(r2)
   11530:	21003fcc 	andi	r4,r4,255
   11534:	10c00463 	ldbuio	r3,17(r2)
   11538:	2008923a 	slli	r4,r4,8
   1153c:	18c03fcc 	andi	r3,r3,255
   11540:	20c6b03a 	or	r3,r4,r3
   11544:	80c0050d 	sth	r3,20(r16)
		boot_sector_data.number_of_sectors_in_partition = (((unsigned short int)(((unsigned char) IORD_8DIRECT(device_pointer->base, 20)))) << 8 ) | ((unsigned char) IORD_8DIRECT(device_pointer->base, 19));
   11548:	10c00523 	ldbuio	r3,20(r2)
   1154c:	18c03fcc 	andi	r3,r3,255
   11550:	148004e3 	ldbuio	r18,19(r2)
   11554:	1806923a 	slli	r3,r3,8
   11558:	94803fcc 	andi	r18,r18,255
   1155c:	1ca4b03a 	or	r18,r3,r18
   11560:	8480058d 	sth	r18,22(r16)
		boot_sector_data.media_descriptor = ((unsigned char) IORD_8DIRECT(device_pointer->base, 21));
   11564:	10c00563 	ldbuio	r3,21(r2)
   11568:	80c00605 	stb	r3,24(r16)
		boot_sector_data.number_of_sectors_per_table = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 22));
   1156c:	10c005ab 	ldhuio	r3,22(r2)
   11570:	80c0068d 	sth	r3,26(r16)
		boot_sector_data.number_of_sectors_per_track = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 24));
   11574:	10c0062b 	ldhuio	r3,24(r2)
   11578:	80c0070d 	sth	r3,28(r16)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
   1157c:	10c006ab 	ldhuio	r3,26(r2)
   11580:	80c0078d 	sth	r3,30(r16)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
   11584:	10c00737 	ldwio	r3,28(r2)
   11588:	80c00815 	stw	r3,32(r16)
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
   1158c:	15000837 	ldwio	r20,32(r2)
   11590:	85000915 	stw	r20,36(r16)
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
   11594:	10800923 	ldbuio	r2,36(r2)
   11598:	80800a05 	stb	r2,40(r16)
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
   1159c:	98800a17 	ldw	r2,40(r19)
   115a0:	10800963 	ldbuio	r2,37(r2)
   115a4:	80800a45 	stb	r2,41(r16)
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
   115a8:	98800a17 	ldw	r2,40(r19)
   115ac:	108009a3 	ldbuio	r2,38(r2)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
   115b0:	8100050b 	ldhu	r4,20(r16)
		boot_sector_data.number_of_heads = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 26));
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
   115b4:	80800a85 	stb	r2,42(r16)
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
   115b8:	8440068b 	ldhu	r17,26(r16)
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
   115bc:	8080040b 	ldhu	r2,16(r16)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
   115c0:	8140030b 	ldhu	r5,12(r16)
   115c4:	2008917a 	slli	r4,r4,5
		boot_sector_data.number_of_hidden_sectors = ((unsigned int) IORD_32DIRECT(device_pointer->base, 28));
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
   115c8:	80801115 	stw	r2,68(r16)
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
   115cc:	1445883a 	add	r2,r2,r17
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
   115d0:	88a3883a 	add	r17,r17,r2
		boot_sector_data.total_sector_count_if_above_32MB = ((unsigned int) IORD_32DIRECT(device_pointer->base, 32));
		boot_sector_data.drive_number = ((unsigned char) IORD_8DIRECT(device_pointer->base, 36));
		boot_sector_data.current_head = ((unsigned char) IORD_8DIRECT(device_pointer->base, 37));
		boot_sector_data.boot_signature = ((unsigned char) IORD_8DIRECT(device_pointer->base, 38));
		boot_sector_data.first_fat_sector_offset = boot_sector_data.reserved_sectors;
		boot_sector_data.second_fat_sector_offset = boot_sector_data.first_fat_sector_offset + boot_sector_data.number_of_sectors_per_table;
   115d4:	80801215 	stw	r2,72(r16)
		boot_sector_data.root_directory_sector_offset = boot_sector_data.second_fat_sector_offset + boot_sector_data.number_of_sectors_per_table; 
   115d8:	84401315 	stw	r17,76(r16)
		boot_sector_data.data_sector_offset = boot_sector_data.root_directory_sector_offset + (32*boot_sector_data.max_number_of_dir_entires / boot_sector_data.sector_size_in_bytes);    
   115dc:	00109340 	call	10934 <__divsi3>
   115e0:	1445883a 	add	r2,r2,r17
   115e4:	80801415 	stw	r2,80(r16)
	    
		if (boot_sector_data.number_of_sectors_in_partition > 0)
   115e8:	913fffcc 	andi	r4,r18,65535
   115ec:	81400383 	ldbu	r5,14(r16)
   115f0:	20000226 	beq	r4,zero,115fc <Check_for_DOS_FAT+0x1a0>
		{
			num_clusters = (boot_sector_data.number_of_sectors_in_partition / boot_sector_data.sectors_per_cluster);
   115f4:	00109340 	call	10934 <__divsi3>
   115f8:	00000206 	br	11604 <Check_for_DOS_FAT+0x1a8>
		}
		else
		{
			num_clusters = (boot_sector_data.total_sector_count_if_above_32MB / boot_sector_data.sectors_per_cluster);
   115fc:	a009883a 	mov	r4,r20
   11600:	0010a2c0 	call	10a2c <__udivsi3>
		}
		if (num_clusters < 4087)
   11604:	00c3fd84 	movi	r3,4086
   11608:	18800216 	blt	r3,r2,11614 <Check_for_DOS_FAT+0x1b8>
		{
			boot_sector_data.bits_for_cluster_index = 12;
   1160c:	00800304 	movi	r2,12
   11610:	00000506 	br	11628 <Check_for_DOS_FAT+0x1cc>
		}
		else if (num_clusters <= 65517)
   11614:	00fffb54 	movui	r3,65517
   11618:	18800216 	blt	r3,r2,11624 <Check_for_DOS_FAT+0x1c8>
		{
			boot_sector_data.bits_for_cluster_index = 16;
   1161c:	00800404 	movi	r2,16
   11620:	00000106 	br	11628 <Check_for_DOS_FAT+0x1cc>
		}
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
   11624:	00800804 	movi	r2,32
   11628:	01000074 	movhi	r4,1
   1162c:	80801085 	stb	r2,66(r16)
   11630:	210e2fc4 	addi	r4,r4,14527
		int num_clusters = 0;

		boot_sector_data.jump_instruction[0] = (char) IORD_8DIRECT(device_pointer->base, 0);
		boot_sector_data.jump_instruction[1] = (char) IORD_8DIRECT(device_pointer->base, 1);
		boot_sector_data.jump_instruction[2] = (char) IORD_8DIRECT(device_pointer->base, 2);
		for (counter = 0; counter < 8; counter++)
   11634:	0007883a 	mov	r3,zero
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
   11638:	01400104 	movi	r5,4
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
   1163c:	98800a17 	ldw	r2,40(r19)
   11640:	108009c4 	addi	r2,r2,39
   11644:	10c5883a 	add	r2,r2,r3
   11648:	10800023 	ldbuio	r2,0(r2)
   1164c:	20800005 	stb	r2,0(r4)
		else
		{
			boot_sector_data.bits_for_cluster_index = 32;
		}
	    
		for (counter = 0; counter < 4; counter++)
   11650:	18c00044 	addi	r3,r3,1
   11654:	21000044 	addi	r4,r4,1
   11658:	197ff81e 	bne	r3,r5,1163c <_gp+0xffff61ac>
   1165c:	01000074 	movhi	r4,1
   11660:	210e30c4 	addi	r4,r4,14531
   11664:	0007883a 	mov	r3,zero
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
   11668:	014002c4 	movi	r5,11
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
   1166c:	98800a17 	ldw	r2,40(r19)
   11670:	10800ac4 	addi	r2,r2,43
   11674:	10c5883a 	add	r2,r2,r3
   11678:	10800023 	ldbuio	r2,0(r2)
   1167c:	20800005 	stb	r2,0(r4)
	    
		for (counter = 0; counter < 4; counter++)
		{
			boot_sector_data.volume_id[counter] = ((char) IORD_8DIRECT(device_pointer->base, 39+counter));
		}    
		for (counter = 0; counter < 11; counter++)
   11680:	18c00044 	addi	r3,r3,1
   11684:	21000044 	addi	r4,r4,1
   11688:	197ff81e 	bne	r3,r5,1166c <_gp+0xffff61dc>
   1168c:	01000074 	movhi	r4,1
   11690:	210e3384 	addi	r4,r4,14542
   11694:	0007883a 	mov	r3,zero
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
   11698:	01400204 	movi	r5,8
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
   1169c:	98800a17 	ldw	r2,40(r19)
   116a0:	10800d84 	addi	r2,r2,54
   116a4:	10c5883a 	add	r2,r2,r3
   116a8:	10800023 	ldbuio	r2,0(r2)
   116ac:	20800005 	stb	r2,0(r4)
		}    
		for (counter = 0; counter < 11; counter++)
		{
			boot_sector_data.volume_label[counter] = ((char) IORD_8DIRECT(device_pointer->base, 43+counter));
		}    
		for (counter = 0; counter < 8; counter++)
   116b0:	18c00044 	addi	r3,r3,1
   116b4:	21000044 	addi	r4,r4,1
   116b8:	197ff81e 	bne	r3,r5,1169c <_gp+0xffff620c>
   116bc:	00c00074 	movhi	r3,1
   116c0:	18ce4904 	addi	r3,r3,14628
   116c4:	0005883a 	mov	r2,zero
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
   116c8:	01000504 	movi	r4,20
		{
			active_files[counter].in_use = false;
   116cc:	18000015 	stw	zero,0(r3)
		for (counter = 0; counter < 8; counter++)
		{
			boot_sector_data.file_system_type[counter] = ((char) IORD_8DIRECT(device_pointer->base, 54+counter));
		}    
		// Clear file records
		for (counter = 0; counter < MAX_FILES_OPENED; counter++)
   116d0:	10800044 	addi	r2,r2,1
   116d4:	18c01004 	addi	r3,r3,64
   116d8:	113ffc1e 	bne	r2,r4,116cc <_gp+0xffff623c>
   116dc:	00800044 	movi	r2,1
   116e0:	00000106 	br	116e8 <Check_for_DOS_FAT+0x28c>
		}
		result = true;
	}
    else
    {
        result = false;
   116e4:	0005883a 	mov	r2,zero
    }
	return result;
}
   116e8:	dfc00517 	ldw	ra,20(sp)
   116ec:	dd000417 	ldw	r20,16(sp)
   116f0:	dcc00317 	ldw	r19,12(sp)
   116f4:	dc800217 	ldw	r18,8(sp)
   116f8:	dc400117 	ldw	r17,4(sp)
   116fc:	dc000017 	ldw	r16,0(sp)
   11700:	dec00604 	addi	sp,sp,24
   11704:	f800283a 	ret

00011708 <find_first_empty_cluster>:


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
   11708:	00800074 	movhi	r2,1
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
   1170c:	defffb04 	addi	sp,sp,-20
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
   11710:	108e2504 	addi	r2,r2,14484
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
   11714:	dc400115 	stw	r17,4(sp)
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
   11718:	14401117 	ldw	r17,68(r2)
}


bool find_first_empty_cluster(unsigned int *cluster_number)
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
   1171c:	dcc00315 	stw	r19,12(sp)
   11720:	dc800215 	stw	r18,8(sp)
   11724:	dc000015 	stw	r16,0(sp)
   11728:	dfc00415 	stw	ra,16(sp)
   1172c:	2027883a 	mov	r19,r4
   11730:	04000084 	movi	r16,2
   11734:	1025883a 	mov	r18,r2
	else
	{
		max_cluster_index = ((greater_than_32 - non_data_sectors) / boot_sector_data.sectors_per_cluster) + 1;
	}
    // Find an empty cluster for the file.
    while (sector != boot_sector_data.second_fat_sector_offset)
   11738:	90801217 	ldw	r2,72(r18)
   1173c:	88801026 	beq	r17,r2,11780 <find_first_empty_cluster+0x78>
    {
        if (Read_Sector_Data( sector, fat_partition_offset_in_512_byte_sectors))
   11740:	d160f317 	ldw	r5,-31796(gp)
   11744:	8809883a 	mov	r4,r17
   11748:	00111a80 	call	111a8 <Read_Sector_Data>
   1174c:	10000a26 	beq	r2,zero,11778 <find_first_empty_cluster+0x70>
        {
            do {
                cluster = ((unsigned short int) IORD_16DIRECT(device_pointer->base, 2*(cluster_index % 256)));
   11750:	d0e0f117 	ldw	r3,-31804(gp)
   11754:	80803fcc 	andi	r2,r16,255
   11758:	1085883a 	add	r2,r2,r2
   1175c:	18c00a17 	ldw	r3,40(r3)
   11760:	10c5883a 	add	r2,r2,r3
                if (cluster == 0)
   11764:	1080002f 	ldhio	r2,0(r2)
   11768:	10000726 	beq	r2,zero,11788 <find_first_empty_cluster+0x80>
                    // Free cluster found.
                    break;
                }
                else
                {
                    cluster_index++;
   1176c:	84000044 	addi	r16,r16,1
                } 
            } while ((cluster_index % 256) != 0);
   11770:	80803fcc 	andi	r2,r16,255
   11774:	003ff506 	br	1174c <_gp+0xffff62bc>
        }
        if (cluster == 0)
        {
            break;
        }
        sector++;
   11778:	8c400044 	addi	r17,r17,1
   1177c:	003fee06 	br	11738 <_gp+0xffff62a8>
// Find the first empty cluster. It will be marked by a 0 entry in the File Allocation Table.
{
    unsigned int sector = boot_sector_data.first_fat_sector_offset;
    unsigned int cluster_index = 2;
    short int cluster = -1;
    bool result = false;
   11780:	0005883a 	mov	r2,zero
   11784:	00000206 	br	11790 <find_first_empty_cluster+0x88>
        }
        sector++;
    }
    if ((cluster == 0) && (cluster <= max_cluster_index))
    {
        *cluster_number = cluster_index;
   11788:	9c000015 	stw	r16,0(r19)
		result = true;
   1178c:	00800044 	movi	r2,1
    }
    return result;
}
   11790:	dfc00417 	ldw	ra,16(sp)
   11794:	dcc00317 	ldw	r19,12(sp)
   11798:	dc800217 	ldw	r18,8(sp)
   1179c:	dc400117 	ldw	r17,4(sp)
   117a0:	dc000017 	ldw	r16,0(sp)
   117a4:	dec00504 	addi	sp,sp,20
   117a8:	f800283a 	ret

000117ac <find_first_empty_record_in_a_subdirectory>:


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
   117ac:	defff504 	addi	sp,sp,-44
   117b0:	dcc00515 	stw	r19,20(sp)
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   117b4:	04c00074 	movhi	r19,1
}


int find_first_empty_record_in_a_subdirectory(int start_cluster_index)
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
   117b8:	dd400715 	stw	r21,28(sp)
   117bc:	dd000615 	stw	r20,24(sp)
   117c0:	dc000215 	stw	r16,8(sp)
   117c4:	dfc00a15 	stw	ra,40(sp)
   117c8:	ddc00915 	stw	r23,36(sp)
   117cc:	dd800815 	stw	r22,32(sp)
   117d0:	dc800415 	stw	r18,16(sp)
   117d4:	dc400315 	stw	r17,12(sp)
   117d8:	2021883a 	mov	r16,r4
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   117dc:	9cce2504 	addi	r19,r19,14484
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                    if ((leading_char == 0x00e5) || (leading_char == 0))
   117e0:	05003944 	movi	r20,229
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
   117e4:	05400404 	movi	r21,16
// Search for a free spot in a subdirectory. Return an encoded location for the file record.
{
    int result = -1;
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   117e8:	99400383 	ldbu	r5,14(r19)
   117ec:	813fff84 	addi	r4,r16,-2
   117f0:	05c00074 	movhi	r23,1
   117f4:	0010ae80 	call	10ae8 <__mulsi3>
   117f8:	9c801417 	ldw	r18,80(r19)
   117fc:	bdce2504 	addi	r23,r23,14484
   11800:	14a5883a 	add	r18,r2,r18
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   11804:	902d883a 	mov	r22,r18
   11808:	b8800383 	ldbu	r2,14(r23)
   1180c:	b4a3c83a 	sub	r17,r22,r18
   11810:	8880040e 	bge	r17,r2,11824 <find_first_empty_record_in_a_subdirectory+0x78>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
   11814:	d160f317 	ldw	r5,-31796(gp)
   11818:	b009883a 	mov	r4,r22
   1181c:	00111a80 	call	111a8 <Read_Sector_Data>
   11820:	1000051e 	bne	r2,zero,11838 <find_first_empty_record_in_a_subdirectory+0x8c>
        // If this is the end of the cluster and the file has not been found, then see if there is another cluster
        // that holds data for the current directory.
        if (result < 0)
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
   11824:	d9400104 	addi	r5,sp,4
   11828:	8009883a 	mov	r4,r16
   1182c:	00112480 	call	11248 <get_cluster_flag>
   11830:	1000131e 	bne	r2,zero,11880 <find_first_empty_record_in_a_subdirectory+0xd4>
   11834:	00003406 	br	11908 <find_first_empty_record_in_a_subdirectory+0x15c>
   11838:	0007883a 	mov	r3,zero
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
   1183c:	d120f117 	ldw	r4,-31804(gp)
   11840:	1804917a 	slli	r2,r3,5
   11844:	21000a17 	ldw	r4,40(r4)
   11848:	1105883a 	add	r2,r2,r4
   1184c:	10800023 	ldbuio	r2,0(r2)
                    if ((leading_char == 0x00e5) || (leading_char == 0))
   11850:	10803fcc 	andi	r2,r2,255
   11854:	1500051e 	bne	r2,r20,1186c <find_first_empty_record_in_a_subdirectory+0xc0>
                    {
                        result = (cluster) | ((sector_index*16 + file_counter) << 16);
   11858:	8804913a 	slli	r2,r17,4
   1185c:	10c5883a 	add	r2,r2,r3
   11860:	1004943a 	slli	r2,r2,16
   11864:	1404b03a 	or	r2,r2,r16
                        return result;
   11868:	00002c06 	br	1191c <find_first_empty_record_in_a_subdirectory+0x170>
                {
                    unsigned short int leading_char;
                    
                    // Read file record.
                    leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                    if ((leading_char == 0x00e5) || (leading_char == 0))
   1186c:	103ffa26 	beq	r2,zero,11858 <_gp+0xffff63c8>
        {
            if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
   11870:	18c00044 	addi	r3,r3,1
   11874:	1d7ff11e 	bne	r3,r21,1183c <_gp+0xffff63ac>
   11878:	b5800044 	addi	r22,r22,1
   1187c:	003fe206 	br	11808 <_gp+0xffff6378>
        {
			unsigned short int new_cluster;
			if (get_cluster_flag(cluster, &new_cluster))
			{
                // The directory needs to be expanded to store more files.
				if ((new_cluster & 0x0000fff8) == 0x0000fff8)
   11880:	d880010b 	ldhu	r2,4(sp)
   11884:	00fffe14 	movui	r3,65528
   11888:	10bffe0c 	andi	r2,r2,65528
   1188c:	10c01e1e 	bne	r2,r3,11908 <find_first_empty_record_in_a_subdirectory+0x15c>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
   11890:	d809883a 	mov	r4,sp
   11894:	00117080 	call	11708 <find_first_empty_cluster>
   11898:	1000021e 	bne	r2,zero,118a4 <find_first_empty_record_in_a_subdirectory+0xf8>
    int cluster = start_cluster_index;
    do {
        int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
        int sector_index;
        
        for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   1189c:	00bfffc4 	movi	r2,-1
   118a0:	00001606 	br	118fc <find_first_empty_record_in_a_subdirectory+0x150>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
   118a4:	d940000f 	ldh	r5,0(sp)
   118a8:	01800044 	movi	r6,1
   118ac:	8009883a 	mov	r4,r16
   118b0:	00112c80 	call	112c8 <mark_cluster>
   118b4:	103ff926 	beq	r2,zero,1189c <_gp+0xffff640c>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
   118b8:	d9000017 	ldw	r4,0(sp)
   118bc:	01800044 	movi	r6,1
   118c0:	017fffc4 	movi	r5,-1
   118c4:	00112c80 	call	112c8 <mark_cluster>
				{
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
   118c8:	103ff426 	beq	r2,zero,1189c <_gp+0xffff640c>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
   118cc:	d940000f 	ldh	r5,0(sp)
   118d0:	000d883a 	mov	r6,zero
   118d4:	8009883a 	mov	r4,r16
   118d8:	00112c80 	call	112c8 <mark_cluster>
					unsigned int new_dir_cluster; 
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
   118dc:	103fef26 	beq	r2,zero,1189c <_gp+0xffff640c>
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
   118e0:	d9000017 	ldw	r4,0(sp)
   118e4:	000d883a 	mov	r6,zero
   118e8:	017fffc4 	movi	r5,-1
   118ec:	00112c80 	call	112c8 <mark_cluster>
					if (find_first_empty_cluster(&new_dir_cluster))
					{
						// Add the new cluster to the linked list of the given directory.
						if (mark_cluster(cluster, ((short int) (new_dir_cluster)), true) &&
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), true) &&
							mark_cluster(cluster, ((short int) (new_dir_cluster)), false) &&
   118f0:	103fea26 	beq	r2,zero,1189c <_gp+0xffff640c>
							mark_cluster(new_dir_cluster, ((short int) (0xffff)), false))
						{
							Save_Modified_Sector();
   118f4:	001118c0 	call	1118c <Save_Modified_Sector>
							// The new file will begin at the first entry of the directory.
							result = new_dir_cluster;                           
   118f8:	d8800017 	ldw	r2,0(sp)
						}
					}
					cluster = (new_cluster & 0x0000fff8);
   118fc:	dc00010b 	ldhu	r16,4(sp)
   11900:	843ffe0c 	andi	r16,r16,65528
   11904:	00000106 	br	1190c <find_first_empty_record_in_a_subdirectory+0x160>
   11908:	00bfffc4 	movi	r2,-1
			{
				// Error encountered.                 
				result = -1;
			}
        }              
    } while ((cluster < 0x0000fff8) && (result == -1)); 
   1190c:	00fffdd4 	movui	r3,65527
   11910:	1c000216 	blt	r3,r16,1191c <find_first_empty_record_in_a_subdirectory+0x170>
   11914:	00ffffc4 	movi	r3,-1
   11918:	10ffb326 	beq	r2,r3,117e8 <_gp+0xffff6358>
    return result; 
}
   1191c:	dfc00a17 	ldw	ra,40(sp)
   11920:	ddc00917 	ldw	r23,36(sp)
   11924:	dd800817 	ldw	r22,32(sp)
   11928:	dd400717 	ldw	r21,28(sp)
   1192c:	dd000617 	ldw	r20,24(sp)
   11930:	dcc00517 	ldw	r19,20(sp)
   11934:	dc800417 	ldw	r18,16(sp)
   11938:	dc400317 	ldw	r17,12(sp)
   1193c:	dc000217 	ldw	r16,8(sp)
   11940:	dec00b04 	addi	sp,sp,44
   11944:	f800283a 	ret

00011948 <find_first_empty_record_in_root_directory>:


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
   11948:	defffa04 	addi	sp,sp,-24
   1194c:	dc400115 	stw	r17,4(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11950:	04400074 	movhi	r17,1
   11954:	8c4e2504 	addi	r17,r17,14484
   11958:	8900050b 	ldhu	r4,20(r17)
   1195c:	8940030b 	ldhu	r5,12(r17)
}


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
   11960:	dd000415 	stw	r20,16(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11964:	2008917a 	slli	r4,r4,5
}


int find_first_empty_record_in_root_directory()
// Find a first unused record location to use. Return -1 if none is found.
{
   11968:	dcc00315 	stw	r19,12(sp)
   1196c:	dc800215 	stw	r18,8(sp)
   11970:	dc000015 	stw	r16,0(sp)
   11974:	dfc00515 	stw	ra,20(sp)
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11978:	00109340 	call	10934 <__divsi3>
   1197c:	1025883a 	mov	r18,r2
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11980:	0021883a 	mov	r16,zero
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                if ((leading_char == 0x00e5) || (leading_char == 0))
   11984:	04c03944 	movi	r19,229
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
   11988:	05000404 	movi	r20,16
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   1198c:	84800526 	beq	r16,r18,119a4 <find_first_empty_record_in_root_directory+0x5c>
    {
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
   11990:	89001317 	ldw	r4,76(r17)
   11994:	d160f317 	ldw	r5,-31796(gp)
   11998:	8109883a 	add	r4,r16,r4
   1199c:	00111a80 	call	111a8 <Read_Sector_Data>
   119a0:	1000021e 	bne	r2,zero,119ac <find_first_empty_record_in_root_directory+0x64>
        else
        {
            break;
        }
    }
    return result;
   119a4:	00bfffc4 	movi	r2,-1
   119a8:	00001106 	br	119f0 <find_first_empty_record_in_root_directory+0xa8>
   119ac:	0005883a 	mov	r2,zero
            for (file_counter = 0; file_counter < 16; file_counter++)
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
   119b0:	d120f117 	ldw	r4,-31804(gp)
   119b4:	1006917a 	slli	r3,r2,5
   119b8:	21000a17 	ldw	r4,40(r4)
   119bc:	1907883a 	add	r3,r3,r4
   119c0:	18c00023 	ldbuio	r3,0(r3)
                if ((leading_char == 0x00e5) || (leading_char == 0))
   119c4:	18c03fcc 	andi	r3,r3,255
   119c8:	1cc0041e 	bne	r3,r19,119dc <find_first_empty_record_in_root_directory+0x94>
                {
                    result = (sector_index*16 + file_counter) << 16;
   119cc:	8020913a 	slli	r16,r16,4
   119d0:	8085883a 	add	r2,r16,r2
   119d4:	1004943a 	slli	r2,r2,16
                    return result;
   119d8:	00000506 	br	119f0 <find_first_empty_record_in_root_directory+0xa8>
            {
                unsigned short int leading_char;
                
                // Read first character of the file record.
                leading_char = ((unsigned char) IORD_8DIRECT(device_pointer->base, file_counter*32));
                if ((leading_char == 0x00e5) || (leading_char == 0))
   119dc:	183ffb26 	beq	r3,zero,119cc <_gp+0xffff653c>
        if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                fat_partition_offset_in_512_byte_sectors))
        {
            int file_counter;
            
            for (file_counter = 0; file_counter < 16; file_counter++)
   119e0:	10800044 	addi	r2,r2,1
   119e4:	153ff21e 	bne	r2,r20,119b0 <_gp+0xffff6520>
{
    int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
    int sector_index;
    int result = -1;
    
    for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   119e8:	84000044 	addi	r16,r16,1
   119ec:	003fe706 	br	1198c <_gp+0xffff64fc>
        {
            break;
        }
    }
    return result;
}
   119f0:	dfc00517 	ldw	ra,20(sp)
   119f4:	dd000417 	ldw	r20,16(sp)
   119f8:	dcc00317 	ldw	r19,12(sp)
   119fc:	dc800217 	ldw	r18,8(sp)
   11a00:	dc400117 	ldw	r17,4(sp)
   11a04:	dc000017 	ldw	r16,0(sp)
   11a08:	dec00604 	addi	sp,sp,24
   11a0c:	f800283a 	ret

00011a10 <Read_File_Record_At_Offset>:

bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   11a10:	208007cc 	andi	r2,r4,31
   11a14:	10005a1e 	bne	r2,zero,11b80 <Read_File_Record_At_Offset+0x170>
}


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
   11a18:	defffb04 	addi	sp,sp,-20
   11a1c:	dcc00315 	stw	r19,12(sp)
   11a20:	dc800215 	stw	r18,8(sp)
   11a24:	dc400115 	stw	r17,4(sp)
   11a28:	dc000015 	stw	r16,0(sp)
   11a2c:	dfc00415 	stw	ra,16(sp)
   11a30:	3825883a 	mov	r18,r7
   11a34:	3027883a 	mov	r19,r6
   11a38:	2821883a 	mov	r16,r5
   11a3c:	2023883a 	mov	r17,r4
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   11a40:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   11a44:	1000021e 	bne	r2,zero,11a50 <Read_File_Record_At_Offset+0x40>


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
   11a48:	0005883a 	mov	r2,zero
   11a4c:	00004506 	br	11b64 <Read_File_Record_At_Offset+0x154>
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   11a50:	d0a0fa17 	ldw	r2,-31768(gp)
   11a54:	103ffc26 	beq	r2,zero,11a48 <_gp+0xffff65b8>
   11a58:	80800204 	addi	r2,r16,8
   11a5c:	8007883a 	mov	r3,r16
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
   11a60:	8c0dc83a 	sub	r6,r17,r16
   11a64:	d120f117 	ldw	r4,-31804(gp)
   11a68:	30cb883a 	add	r5,r6,r3
   11a6c:	21000a17 	ldw	r4,40(r4)
   11a70:	2909883a 	add	r4,r5,r4
   11a74:	21000023 	ldbuio	r4,0(r4)
   11a78:	19000005 	stb	r4,0(r3)
   11a7c:	18c00044 	addi	r3,r3,1
	bool result = false;
	if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
		int counter;

		for (counter = 0; counter < 8; counter++)
   11a80:	18bff81e 	bne	r3,r2,11a64 <_gp+0xffff65d4>
   11a84:	814002c4 	addi	r5,r16,11
   11a88:	8809883a 	mov	r4,r17
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
   11a8c:	d0e0f117 	ldw	r3,-31804(gp)
   11a90:	18c00a17 	ldw	r3,40(r3)
   11a94:	18c00204 	addi	r3,r3,8
   11a98:	1907883a 	add	r3,r3,r4
   11a9c:	18c00023 	ldbuio	r3,0(r3)
   11aa0:	10c00005 	stb	r3,0(r2)
   11aa4:	10800044 	addi	r2,r2,1
   11aa8:	21000044 	addi	r4,r4,1

		for (counter = 0; counter < 8; counter++)
		{
			record->name[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter);
		}        
		for (counter = 0; counter < 3; counter++)
   11aac:	28bff71e 	bne	r5,r2,11a8c <_gp+0xffff65fc>
		{
			record->extension[counter] = (char) IORD_8DIRECT(device_pointer->base, offset+counter+8);
		}        
		record->attributes          =   (char) IORD_8DIRECT(device_pointer->base, offset+11);
   11ab0:	d0a0f117 	ldw	r2,-31804(gp)
   11ab4:	10c00a17 	ldw	r3,40(r2)
   11ab8:	18c002c4 	addi	r3,r3,11
   11abc:	1c47883a 	add	r3,r3,r17
   11ac0:	18c00023 	ldbuio	r3,0(r3)
   11ac4:	80c002c5 	stb	r3,11(r16)
		/* Ignore reserved bytes at locations 12 and 13. */
		record->create_time         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+14);
   11ac8:	10c00a17 	ldw	r3,40(r2)
   11acc:	18c00384 	addi	r3,r3,14
   11ad0:	1c47883a 	add	r3,r3,r17
   11ad4:	18c0002b 	ldhuio	r3,0(r3)
   11ad8:	80c0030d 	sth	r3,12(r16)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
   11adc:	10c00a17 	ldw	r3,40(r2)
   11ae0:	18c00404 	addi	r3,r3,16
   11ae4:	1c47883a 	add	r3,r3,r17
   11ae8:	18c0002b 	ldhuio	r3,0(r3)
   11aec:	80c0038d 	sth	r3,14(r16)
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
   11af0:	10c00a17 	ldw	r3,40(r2)
   11af4:	18c00484 	addi	r3,r3,18
   11af8:	1c47883a 	add	r3,r3,r17
   11afc:	18c0002b 	ldhuio	r3,0(r3)
   11b00:	80c0040d 	sth	r3,16(r16)
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
   11b04:	10c00a17 	ldw	r3,40(r2)
   11b08:	18c00584 	addi	r3,r3,22
   11b0c:	1c47883a 	add	r3,r3,r17
   11b10:	18c0002b 	ldhuio	r3,0(r3)
   11b14:	80c0048d 	sth	r3,18(r16)
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
   11b18:	10c00a17 	ldw	r3,40(r2)
   11b1c:	18c00604 	addi	r3,r3,24
   11b20:	1c47883a 	add	r3,r3,r17
   11b24:	18c0002b 	ldhuio	r3,0(r3)
   11b28:	80c0050d 	sth	r3,20(r16)
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
   11b2c:	10c00a17 	ldw	r3,40(r2)
   11b30:	18c00684 	addi	r3,r3,26
   11b34:	1c47883a 	add	r3,r3,r17
   11b38:	18c0002b 	ldhuio	r3,0(r3)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
   11b3c:	10800a17 	ldw	r2,40(r2)
		record->create_date         =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+16);
		record->last_access_date    =   (unsigned short int) IORD_16DIRECT(device_pointer->base, offset+18);
		/* Ignore reserved bytes at locations 20 and 21. */
		record->last_modified_time  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+22);
		record->last_modified_date  =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+24);
		record->start_cluster_index =	(unsigned short int) IORD_16DIRECT(device_pointer->base, offset+26);
   11b40:	80c0058d 	sth	r3,22(r16)
		record->file_size_in_bytes  =	(unsigned int) IORD_32DIRECT(device_pointer->base, offset+28);
   11b44:	10800704 	addi	r2,r2,28
   11b48:	1445883a 	add	r2,r2,r17
   11b4c:	10800037 	ldwio	r2,0(r2)
   11b50:	80800615 	stw	r2,24(r16)
		record->file_record_cluster = cluster_index;
   11b54:	84c00a15 	stw	r19,40(r16)
		record->file_record_sector_in_cluster = sector_in_cluster;
   11b58:	84800b15 	stw	r18,44(r16)
		record->file_record_offset = offset;
   11b5c:	84400c0d 	sth	r17,48(r16)
   11b60:	00800044 	movi	r2,1
		result = true;
	}
	return result;
}
   11b64:	dfc00417 	ldw	ra,16(sp)
   11b68:	dcc00317 	ldw	r19,12(sp)
   11b6c:	dc800217 	ldw	r18,8(sp)
   11b70:	dc400117 	ldw	r17,4(sp)
   11b74:	dc000017 	ldw	r16,0(sp)
   11b78:	dec00504 	addi	sp,sp,20
   11b7c:	f800283a 	ret


bool Read_File_Record_At_Offset(int offset, t_file_record *record, unsigned int cluster_index, unsigned int sector_in_cluster)
// This function reads a file record
{
	bool result = false;
   11b80:	0005883a 	mov	r2,zero
		record->file_record_sector_in_cluster = sector_in_cluster;
		record->file_record_offset = offset;
		result = true;
	}
	return result;
}
   11b84:	f800283a 	ret

00011b88 <get_home_directory_cluster_for_file>:
}


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
   11b88:	deffef04 	addi	sp,sp,-68
   11b8c:	dd800d15 	stw	r22,52(sp)
   11b90:	dd400c15 	stw	r21,48(sp)
   11b94:	dd000b15 	stw	r20,44(sp)
   11b98:	dcc00a15 	stw	r19,40(sp)
   11b9c:	dc800915 	stw	r18,36(sp)
   11ba0:	dc400815 	stw	r17,32(sp)
   11ba4:	dc000715 	stw	r16,28(sp)
   11ba8:	dfc01015 	stw	ra,64(sp)
   11bac:	df000f15 	stw	fp,60(sp)
   11bb0:	ddc00e15 	stw	r23,56(sp)
   11bb4:	202b883a 	mov	r21,r4
   11bb8:	d9400515 	stw	r5,20(sp)
   11bbc:	3023883a 	mov	r17,r6
   11bc0:	05000074 	movhi	r20,1
    int home_dir_cluster = 0;
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
   11bc4:	0010de00 	call	10de0 <get_dir_divider_location>
   11bc8:	1021883a 	mov	r16,r2
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    int home_dir_cluster = 0;
    int location, index;
    int start_location = 0;
   11bcc:	0027883a 	mov	r19,zero

bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
    int home_dir_cluster = 0;
   11bd0:	002d883a 	mov	r22,zero


bool get_home_directory_cluster_for_file(char *file_name, int *home_directory_cluster, t_file_record *file_record)
// Scan the directories in given in the file name and find the root directory for the file.
{
    bool result = false;
   11bd4:	0025883a 	mov	r18,zero
   11bd8:	a50e2504 	addi	r20,r20,14484
    int location, index;
    int start_location = 0;
    
    /* Get Next Directory. */
    location = get_dir_divider_location( file_name );
    while (location > 0)
   11bdc:	0400850e 	bge	zero,r16,11df4 <get_home_directory_cluster_for_file+0x26c>
    {
        char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
   11be0:	01400074 	movhi	r5,1
   11be4:	01800204 	movi	r6,8
   11be8:	294c44c4 	addi	r5,r5,12563
   11bec:	d809883a 	mov	r4,sp
   11bf0:	001301c0 	call	1301c <memcpy>
        char extension[3] = { ' ', ' ', ' ' };
   11bf4:	01400074 	movhi	r5,1
   11bf8:	d9000204 	addi	r4,sp,8
   11bfc:	018000c4 	movi	r6,3
   11c00:	294c46c4 	addi	r5,r5,12571
   11c04:	001301c0 	call	1301c <memcpy>
        int ext_index = -1;
   11c08:	013fffc4 	movi	r4,-1
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
   11c0c:	0005883a 	mov	r2,zero
        {
            if (file_name[index+start_location] == '.')
   11c10:	01c00b84 	movi	r7,46
            {
                ext_index = index;
            }
            else if (ext_index < 0)
   11c14:	2011883a 	mov	r8,r4
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
        {
            if (file_name[index+start_location] == '.')
   11c18:	988b883a 	add	r5,r19,r2
   11c1c:	a94b883a 	add	r5,r21,r5
   11c20:	29800003 	ldbu	r6,0(r5)
   11c24:	31403fcc 	andi	r5,r6,255
   11c28:	2940201c 	xori	r5,r5,128
   11c2c:	297fe004 	addi	r5,r5,-128
   11c30:	29c00826 	beq	r5,r7,11c54 <get_home_directory_cluster_for_file+0xcc>
            {
                ext_index = index;
            }
            else if (ext_index < 0)
   11c34:	2200021e 	bne	r4,r8,11c40 <get_home_directory_cluster_for_file+0xb8>
            {
                name[index] = file_name[index+start_location];
   11c38:	d88b883a 	add	r5,sp,r2
   11c3c:	00000306 	br	11c4c <get_home_directory_cluster_for_file+0xc4>
            }
            else
            {
                extension[index-ext_index] = file_name[index+start_location];
   11c40:	110bc83a 	sub	r5,r2,r4
   11c44:	d8c00204 	addi	r3,sp,8
   11c48:	194b883a 	add	r5,r3,r5
   11c4c:	29800005 	stb	r6,0(r5)
   11c50:	00000106 	br	11c58 <get_home_directory_cluster_for_file+0xd0>
   11c54:	1009883a 	mov	r4,r2
        char extension[3] = { ' ', ' ', ' ' };
        int ext_index = -1;
        int new_cluster = home_dir_cluster;
        
        // Get the name of the directory in name/extension format.
        for (index = 0; index < location; index++)
   11c58:	10800044 	addi	r2,r2,1
   11c5c:	80bfee1e 	bne	r16,r2,11c18 <_gp+0xffff6788>
            {
                extension[index-ext_index] = file_name[index+start_location];
            }
        }
        
        if (home_dir_cluster == 0)
   11c60:	b000261e 	bne	r22,zero,11cfc <get_home_directory_cluster_for_file+0x174>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11c64:	a100050b 	ldhu	r4,20(r20)
   11c68:	a140030b 	ldhu	r5,12(r20)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11c6c:	002f883a 	mov	r23,zero
        }
        
        if (home_dir_cluster == 0)
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11c70:	2008917a 	slli	r4,r4,5
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
                            if (match)
                            {
                                new_cluster = file_record->start_cluster_index;
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
   11c74:	07000044 	movi	fp,1
        }
        
        if (home_dir_cluster == 0)
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11c78:	00109340 	call	10934 <__divsi3>
   11c7c:	d8800415 	stw	r2,16(sp)
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11c80:	d8c00417 	ldw	r3,16(sp)
   11c84:	b8c05926 	beq	r23,r3,11dec <get_home_directory_cluster_for_file+0x264>
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
   11c88:	a1001317 	ldw	r4,76(r20)
   11c8c:	d160f317 	ldw	r5,-31796(gp)
   11c90:	b909883a 	add	r4,r23,r4
   11c94:	00111a80 	call	111a8 <Read_Sector_Data>
   11c98:	10005426 	beq	r2,zero,11dec <get_home_directory_cluster_for_file+0x264>
   11c9c:	002d883a 	mov	r22,zero
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                       
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
   11ca0:	b80f883a 	mov	r7,r23
   11ca4:	000d883a 	mov	r6,zero
   11ca8:	880b883a 	mov	r5,r17
   11cac:	b009883a 	mov	r4,r22
   11cb0:	0011a100 	call	11a10 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   11cb4:	88800003 	ldbu	r2,0(r17)
   11cb8:	00c03944 	movi	r3,229
   11cbc:	10c00b26 	beq	r2,r3,11cec <get_home_directory_cluster_for_file+0x164>
   11cc0:	10000a26 	beq	r2,zero,11cec <get_home_directory_cluster_for_file+0x164>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
   11cc4:	d9800204 	addi	r6,sp,8
   11cc8:	d80b883a 	mov	r5,sp
   11ccc:	8809883a 	mov	r4,r17
   11cd0:	0010e380 	call	10e38 <match_file_record_to_name_ext>
                            if (match)
   11cd4:	10000526 	beq	r2,zero,11cec <get_home_directory_cluster_for_file+0x164>
                            {
                                new_cluster = file_record->start_cluster_index;
   11cd8:	8d80058b 	ldhu	r22,22(r17)
                                file_record->file_record_cluster = 1; // Home directory is a subdirectory in the root directory.
   11cdc:	8f000a15 	stw	fp,40(r17)
                }
                else
                {
                    break;
                }
                if (new_cluster != home_dir_cluster)
   11ce0:	b0003a1e 	bne	r22,zero,11dcc <get_home_directory_cluster_for_file+0x244>
        {
            /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
            int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
            int sector_index;
            
            for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11ce4:	bdc00044 	addi	r23,r23,1
   11ce8:	003fe506 	br	11c80 <_gp+0xffff67f0>
   11cec:	b5800804 	addi	r22,r22,32
            {
                if (Read_Sector_Data(sector_index+boot_sector_data.root_directory_sector_offset, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
   11cf0:	00808004 	movi	r2,512
   11cf4:	b0bfea1e 	bne	r22,r2,11ca0 <_gp+0xffff6810>
   11cf8:	003ffa06 	br	11ce4 <_gp+0xffff6854>
            // This is a subdirectory that can have any number of elements. So scan through it as though it was a file
            // and see if you can find the directory of interest.
            int cluster = home_dir_cluster;
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   11cfc:	b0ffff84 	addi	r3,r22,-2
   11d00:	d8c00615 	stw	r3,24(sp)
   11d04:	a1400383 	ldbu	r5,14(r20)
   11d08:	d9000617 	ldw	r4,24(sp)
   11d0c:	0010ae80 	call	10ae8 <__mulsi3>
   11d10:	a5c01417 	ldw	r23,80(r20)
   11d14:	15ef883a 	add	r23,r2,r23
   11d18:	ddc00415 	stw	r23,16(sp)
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   11d1c:	002f883a 	mov	r23,zero
   11d20:	a0800383 	ldbu	r2,14(r20)
   11d24:	b880050e 	bge	r23,r2,11d3c <get_home_directory_cluster_for_file+0x1b4>
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
   11d28:	d8c00417 	ldw	r3,16(sp)
   11d2c:	d160f317 	ldw	r5,-31796(gp)
   11d30:	1dc9883a 	add	r4,r3,r23
   11d34:	00111a80 	call	111a8 <Read_Sector_Data>
   11d38:	1000051e 	bne	r2,zero,11d50 <get_home_directory_cluster_for_file+0x1c8>
                // that holds data for the current directory.
                if (new_cluster == home_dir_cluster)
                {
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
   11d3c:	d9400304 	addi	r5,sp,12
   11d40:	b009883a 	mov	r4,r22
   11d44:	00112480 	call	11248 <get_cluster_flag>
   11d48:	1000181e 	bne	r2,zero,11dac <get_home_directory_cluster_for_file+0x224>
   11d4c:	00002706 	br	11dec <get_home_directory_cluster_for_file+0x264>
   11d50:	0039883a 	mov	fp,zero
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
                        {                         
                            // Read file record.
                            Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
   11d54:	b80f883a 	mov	r7,r23
   11d58:	b00d883a 	mov	r6,r22
   11d5c:	880b883a 	mov	r5,r17
   11d60:	e009883a 	mov	r4,fp
   11d64:	0011a100 	call	11a10 <Read_File_Record_At_Offset>
                            if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   11d68:	88800003 	ldbu	r2,0(r17)
   11d6c:	00c03944 	movi	r3,229
   11d70:	10c00926 	beq	r2,r3,11d98 <get_home_directory_cluster_for_file+0x210>
   11d74:	10000826 	beq	r2,zero,11d98 <get_home_directory_cluster_for_file+0x210>
                            {
								bool match = match_file_record_to_name_ext(file_record, name, extension);
   11d78:	d9800204 	addi	r6,sp,8
   11d7c:	d80b883a 	mov	r5,sp
   11d80:	8809883a 	mov	r4,r17
   11d84:	0010e380 	call	10e38 <match_file_record_to_name_ext>
                                if (match)
   11d88:	10000326 	beq	r2,zero,11d98 <get_home_directory_cluster_for_file+0x210>
                                {
                                    new_cluster = file_record->start_cluster_index;                                   
   11d8c:	8880058b 	ldhu	r2,22(r17)
                    }
                    else
                    {
                        break;
                    }
                    if (new_cluster != home_dir_cluster)
   11d90:	b0800426 	beq	r22,r2,11da4 <get_home_directory_cluster_for_file+0x21c>
   11d94:	00000c06 	br	11dc8 <get_home_directory_cluster_for_file+0x240>
   11d98:	e7000804 	addi	fp,fp,32
                {
                    if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                    {
                        int file_counter;
                        
                        for (file_counter = 0; file_counter < 16; file_counter++)
   11d9c:	00808004 	movi	r2,512
   11da0:	e0bfec1e 	bne	fp,r2,11d54 <_gp+0xffff68c4>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   11da4:	bdc00044 	addi	r23,r23,1
   11da8:	003fdd06 	br	11d20 <_gp+0xffff6890>
   11dac:	d880030b 	ldhu	r2,12(sp)
					unsigned short int next_cluster;

					if (get_cluster_flag(new_cluster, &next_cluster))
					{
						// The directory needs to be expanded to store more files.
						if ((next_cluster & 0x0000fff8) == 0x0000fff8)
   11db0:	013ffe14 	movui	r4,65528
   11db4:	10bffe0c 	andi	r2,r2,65528
   11db8:	11000c26 	beq	r2,r4,11dec <get_home_directory_cluster_for_file+0x264>
					{
						// Directory path is invalid.                 
						return false;
					}
                }              
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
   11dbc:	013ffdd4 	movui	r4,65527
   11dc0:	25800116 	blt	r4,r22,11dc8 <get_home_directory_cluster_for_file+0x240>
   11dc4:	b0bfcf26 	beq	r22,r2,11d04 <_gp+0xffff6874>
            
            do {
                int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
                int sector_index;
                
                for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   11dc8:	102d883a 	mov	r22,r2
            } while ((cluster < 0x0000fff8) && (new_cluster == home_dir_cluster));
            if (new_cluster != home_dir_cluster)
            {
                // A valid directory is found, so go to it.
                home_dir_cluster = new_cluster;
                start_location = start_location+location+1;
   11dcc:	84e1883a 	add	r16,r16,r19
   11dd0:	84c00044 	addi	r19,r16,1
            {
                // Directory path is invalid. 
                return false;
            }            
        }
        location = get_dir_divider_location(&(file_name[start_location]));
   11dd4:	acc9883a 	add	r4,r21,r19
   11dd8:	0010de00 	call	10de0 <get_dir_divider_location>
   11ddc:	1021883a 	mov	r16,r2
        if (location < 0)
   11de0:	103f7e0e 	bge	r2,zero,11bdc <_gp+0xffff674c>
        {
            // Directory has been located.
            result = true;
   11de4:	04800044 	movi	r18,1
   11de8:	003f7c06 	br	11bdc <_gp+0xffff674c>
                start_location = start_location+location+1;
            }
            else
            {
                // Directory path is invalid. 
                return false;
   11dec:	0005883a 	mov	r2,zero
   11df0:	00000706 	br	11e10 <get_home_directory_cluster_for_file+0x288>
            // Directory has been located.
            result = true;
        }
    }
    
    *home_directory_cluster = home_dir_cluster;
   11df4:	d8c00517 	ldw	r3,20(sp)
   11df8:	1d800015 	stw	r22,0(r3)
    if (home_dir_cluster == 0)
   11dfc:	b000031e 	bne	r22,zero,11e0c <get_home_directory_cluster_for_file+0x284>
    {
        file_record->file_record_cluster = 0; // Home directory is the root directory.
   11e00:	88000a15 	stw	zero,40(r17)
		result = true;
   11e04:	00800044 	movi	r2,1
   11e08:	00000106 	br	11e10 <get_home_directory_cluster_for_file+0x288>
   11e0c:	9005883a 	mov	r2,r18
    }
    return result;
}
   11e10:	dfc01017 	ldw	ra,64(sp)
   11e14:	df000f17 	ldw	fp,60(sp)
   11e18:	ddc00e17 	ldw	r23,56(sp)
   11e1c:	dd800d17 	ldw	r22,52(sp)
   11e20:	dd400c17 	ldw	r21,48(sp)
   11e24:	dd000b17 	ldw	r20,44(sp)
   11e28:	dcc00a17 	ldw	r19,40(sp)
   11e2c:	dc800917 	ldw	r18,36(sp)
   11e30:	dc400817 	ldw	r17,32(sp)
   11e34:	dc000717 	ldw	r16,28(sp)
   11e38:	dec01104 	addi	sp,sp,68
   11e3c:	f800283a 	ret

00011e40 <find_file_in_directory>:


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
   11e40:	defff204 	addi	sp,sp,-56
   11e44:	dc000415 	stw	r16,16(sp)
   11e48:	2021883a 	mov	r16,r4
    int location = get_dir_divider_location( file_name );
   11e4c:	2809883a 	mov	r4,r5
}


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
   11e50:	dfc00d15 	stw	ra,52(sp)
   11e54:	dd400915 	stw	r21,36(sp)
   11e58:	dd000815 	stw	r20,32(sp)
   11e5c:	dcc00715 	stw	r19,28(sp)
   11e60:	dc800615 	stw	r18,24(sp)
   11e64:	dc400515 	stw	r17,20(sp)
   11e68:	2825883a 	mov	r18,r5
   11e6c:	3027883a 	mov	r19,r6
   11e70:	df000c15 	stw	fp,48(sp)
   11e74:	ddc00b15 	stw	r23,44(sp)
   11e78:	dd800a15 	stw	r22,40(sp)
    int location = get_dir_divider_location( file_name );
   11e7c:	0010de00 	call	10de0 <get_dir_divider_location>
    int last_dir_separator = 0;
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
   11e80:	01400074 	movhi	r5,1
   11e84:	01800204 	movi	r6,8
   11e88:	294c44c4 	addi	r5,r5,12563
   11e8c:	d809883a 	mov	r4,sp


bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    int location = get_dir_divider_location( file_name );
   11e90:	1029883a 	mov	r20,r2
    int last_dir_separator = 0;
    char name[8] = { ' ', ' ', ' ', ' ', ' ', ' ', ' ', ' ' };
   11e94:	001301c0 	call	1301c <memcpy>
    char extension[3] = { ' ', ' ', ' ' };
   11e98:	01400074 	movhi	r5,1
   11e9c:	018000c4 	movi	r6,3
   11ea0:	294c46c4 	addi	r5,r5,12571
   11ea4:	d9000204 	addi	r4,sp,8
   11ea8:	001301c0 	call	1301c <memcpy>
    int ext_index = -1;
    int cluster = directory_start_cluster;
    int index;
	int length = strlen(file_name);
   11eac:	9009883a 	mov	r4,r18
   11eb0:	00102540 	call	10254 <strlen>
   11eb4:	102b883a 	mov	r21,r2

bool find_file_in_directory(int directory_start_cluster, char *file_name, t_file_record *file_record)
// Given a cluster and a file name, check if the file already exists. Return the file record if the file is found.
{
    int location = get_dir_divider_location( file_name );
    int last_dir_separator = 0;
   11eb8:	0023883a 	mov	r17,zero
    int index;
	int length = strlen(file_name);
    bool result = false;
    
    // Skip through all directory separators.
    while (location > 0)
   11ebc:	0500060e 	bge	zero,r20,11ed8 <find_file_in_directory+0x98>
    {
        last_dir_separator = last_dir_separator+location+1;
   11ec0:	a463883a 	add	r17,r20,r17
   11ec4:	8c400044 	addi	r17,r17,1
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
   11ec8:	9449883a 	add	r4,r18,r17
   11ecc:	0010de00 	call	10de0 <get_dir_divider_location>
   11ed0:	1029883a 	mov	r20,r2
   11ed4:	003ff906 	br	11ebc <_gp+0xffff6a2c>
   11ed8:	8807883a 	mov	r3,r17
   11edc:	00bfffc4 	movi	r2,-1
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
    {
        if (file_name[index] == '.')
   11ee0:	01800b84 	movi	r6,46
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
   11ee4:	1d40120e 	bge	r3,r21,11f30 <find_file_in_directory+0xf0>
    {
        if (file_name[index] == '.')
   11ee8:	90c9883a 	add	r4,r18,r3
   11eec:	21400003 	ldbu	r5,0(r4)
   11ef0:	29003fcc 	andi	r4,r5,255
   11ef4:	2100201c 	xori	r4,r4,128
   11ef8:	213fe004 	addi	r4,r4,-128
   11efc:	21800926 	beq	r4,r6,11f24 <find_file_in_directory+0xe4>
        {
            ext_index = index;
        }
        else if (ext_index < 0)
   11f00:	1000030e 	bge	r2,zero,11f10 <find_file_in_directory+0xd0>
        {
            name[index-last_dir_separator] = file_name[index];
   11f04:	1c49c83a 	sub	r4,r3,r17
   11f08:	d909883a 	add	r4,sp,r4
   11f0c:	00000306 	br	11f1c <find_file_in_directory+0xdc>
        }
        else
        {
            extension[index-ext_index-1] = file_name[index];
   11f10:	1889c83a 	sub	r4,r3,r2
   11f14:	d9c001c4 	addi	r7,sp,7
   11f18:	3909883a 	add	r4,r7,r4
   11f1c:	21400005 	stb	r5,0(r4)
   11f20:	00000106 	br	11f28 <find_file_in_directory+0xe8>
   11f24:	1805883a 	mov	r2,r3
        last_dir_separator = last_dir_separator+location+1;
        location = get_dir_divider_location( &(file_name[last_dir_separator]) );
    }
        
    // Get the name of the file in name/extension format.
    for (index = last_dir_separator; index < length; index++)
   11f28:	18c00044 	addi	r3,r3,1
   11f2c:	003fed06 	br	11ee4 <_gp+0xffff6a54>
   11f30:	04400074 	movhi	r17,1
   11f34:	8c4e2504 	addi	r17,r17,14484
            extension[index-ext_index-1] = file_name[index];
        }
    }

    // Look for the file.
    if (directory_start_cluster == 0)
   11f38:	80000426 	beq	r16,zero,11f4c <find_file_in_directory+0x10c>
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   11f3c:	05003944 	movi	r20,229
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
   11f40:	05408004 	movi	r21,512
   11f44:	05bffe04 	movi	r22,-8
   11f48:	00003b06 	br	12038 <find_file_in_directory+0x1f8>

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11f4c:	8900050b 	ldhu	r4,20(r17)
   11f50:	8940030b 	ldhu	r5,12(r17)
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11f54:	0021883a 	mov	r16,zero

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11f58:	2008917a 	slli	r4,r4,5
                
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   11f5c:	05403944 	movi	r21,229
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
   11f60:	05808004 	movi	r22,512

    // Look for the file.
    if (directory_start_cluster == 0)
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   11f64:	00109340 	call	10934 <__divsi3>
   11f68:	1029883a 	mov	r20,r2
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11f6c:	85004026 	beq	r16,r20,12070 <find_file_in_directory+0x230>
        {
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
   11f70:	89001317 	ldw	r4,76(r17)
   11f74:	d160f317 	ldw	r5,-31796(gp)
   11f78:	8109883a 	add	r4,r16,r4
   11f7c:	00111a80 	call	111a8 <Read_Sector_Data>
   11f80:	10003b26 	beq	r2,zero,12070 <find_file_in_directory+0x230>
   11f84:	0025883a 	mov	r18,zero
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
                {
                    // Read file record.
                    Read_File_Record_At_Offset(file_counter*32, file_record, 0, sector_index);
   11f88:	800f883a 	mov	r7,r16
   11f8c:	000d883a 	mov	r6,zero
   11f90:	980b883a 	mov	r5,r19
   11f94:	9009883a 	mov	r4,r18
   11f98:	0011a100 	call	11a10 <Read_File_Record_At_Offset>
                    if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   11f9c:	98800003 	ldbu	r2,0(r19)
   11fa0:	15400826 	beq	r2,r21,11fc4 <find_file_in_directory+0x184>
   11fa4:	10000726 	beq	r2,zero,11fc4 <find_file_in_directory+0x184>
                    {
                        bool match = match_file_record_to_name_ext(file_record, name, extension);
   11fa8:	d9800204 	addi	r6,sp,8
   11fac:	d80b883a 	mov	r5,sp
   11fb0:	9809883a 	mov	r4,r19
   11fb4:	0010e380 	call	10e38 <match_file_record_to_name_ext>

                        if (match)
   11fb8:	10000226 	beq	r2,zero,11fc4 <find_file_in_directory+0x184>
				if (get_cluster_flag(cluster, &new_cluster))
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
					{
						return false;
   11fbc:	00800044 	movi	r2,1
   11fc0:	00002c06 	br	12074 <find_file_in_directory+0x234>
   11fc4:	94800804 	addi	r18,r18,32
            if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
                                    fat_partition_offset_in_512_byte_sectors))
            {
                int file_counter;
                
                for (file_counter = 0; file_counter < 16; file_counter++)
   11fc8:	95bfef1e 	bne	r18,r22,11f88 <_gp+0xffff6af8>
    {
        /* We are in the root directory. Scan the directory (of predefined size) and see if you can find the specified file. */
        int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
        int sector_index;
        
        for (sector_index = 0; sector_index < max_root_dir_sectors; sector_index++)
   11fcc:	84000044 	addi	r16,r16,1
   11fd0:	003fe606 	br	11f6c <_gp+0xffff6adc>
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
   11fd4:	d160f317 	ldw	r5,-31796(gp)
   11fd8:	e489883a 	add	r4,fp,r18
   11fdc:	00111a80 	call	111a8 <Read_Sector_Data>
   11fe0:	10000d26 	beq	r2,zero,12018 <find_file_in_directory+0x1d8>
   11fe4:	002f883a 	mov	r23,zero
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
   11fe8:	900f883a 	mov	r7,r18
   11fec:	800d883a 	mov	r6,r16
   11ff0:	980b883a 	mov	r5,r19
   11ff4:	b809883a 	mov	r4,r23
   11ff8:	0011a100 	call	11a10 <Read_File_Record_At_Offset>
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   11ffc:	98800003 	ldbu	r2,0(r19)
   12000:	1500141e 	bne	r2,r20,12054 <find_file_in_directory+0x214>
   12004:	bdc00804 	addi	r23,r23,32
            {
                if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
                {
                    int file_counter;
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
   12008:	bd7ff71e 	bne	r23,r21,11fe8 <_gp+0xffff6b58>
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   1200c:	94800044 	addi	r18,r18,1
   12010:	88800383 	ldbu	r2,14(r17)
   12014:	90bfef16 	blt	r18,r2,11fd4 <_gp+0xffff6b44>
            // that holds data for the current directory.
            if (result == false)
            {
				unsigned short int new_cluster;

				if (get_cluster_flag(cluster, &new_cluster))
   12018:	d9400304 	addi	r5,sp,12
   1201c:	8009883a 	mov	r4,r16
   12020:	00112480 	call	11248 <get_cluster_flag>
   12024:	10001226 	beq	r2,zero,12070 <find_file_in_directory+0x230>
   12028:	dc00030b 	ldhu	r16,12(sp)
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
   1202c:	00bffe14 	movui	r2,65528
   12030:	b420703a 	and	r16,r22,r16
   12034:	80800e26 	beq	r16,r2,12070 <find_file_in_directory+0x230>
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   12038:	89400383 	ldbu	r5,14(r17)
   1203c:	813fff84 	addi	r4,r16,-2
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   12040:	0025883a 	mov	r18,zero
        }
    }
    else
    {          
        do {
            int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   12044:	0010ae80 	call	10ae8 <__mulsi3>
   12048:	8f001417 	ldw	fp,80(r17)
   1204c:	1739883a 	add	fp,r2,fp
            int sector_index;
            
            for (sector_index = 0; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   12050:	003fef06 	br	12010 <_gp+0xffff6b80>
                    
                    for (file_counter = 0; file_counter < 16; file_counter++)
                    {
                        // Read file record.
                        Read_File_Record_At_Offset(file_counter*32, file_record, cluster, sector_index);
                        if ((file_record->name[0] != 0xe5) && (file_record->name[0] != 0x00))
   12054:	103feb26 	beq	r2,zero,12004 <_gp+0xffff6b74>
                        {
                            bool match = match_file_record_to_name_ext(file_record, name, extension);
   12058:	d9800204 	addi	r6,sp,8
   1205c:	d80b883a 	mov	r5,sp
   12060:	9809883a 	mov	r4,r19
   12064:	0010e380 	call	10e38 <match_file_record_to_name_ext>

                            if (match)
   12068:	103fe626 	beq	r2,zero,12004 <_gp+0xffff6b74>
   1206c:	003fd306 	br	11fbc <_gp+0xffff6b2c>
				if (get_cluster_flag(cluster, &new_cluster))
				{
					// The directory needs to be expanded to store more files.
					if ((new_cluster & 0x0000fff8) == 0x0000fff8)
					{
						return false;
   12070:	0005883a 	mov	r2,zero
            }              
        } while ((cluster < 0x0000fff8) && (result == false));
    }
    
    return result;   
}
   12074:	dfc00d17 	ldw	ra,52(sp)
   12078:	df000c17 	ldw	fp,48(sp)
   1207c:	ddc00b17 	ldw	r23,44(sp)
   12080:	dd800a17 	ldw	r22,40(sp)
   12084:	dd400917 	ldw	r21,36(sp)
   12088:	dd000817 	ldw	r20,32(sp)
   1208c:	dcc00717 	ldw	r19,28(sp)
   12090:	dc800617 	ldw	r18,24(sp)
   12094:	dc400517 	ldw	r17,20(sp)
   12098:	dc000417 	ldw	r16,16(sp)
   1209c:	dec00e04 	addi	sp,sp,56
   120a0:	f800283a 	ret

000120a4 <Write_File_Record_At_Offset>:

bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   120a4:	208007cc 	andi	r2,r4,31
   120a8:	1000551e 	bne	r2,zero,12200 <Write_File_Record_At_Offset+0x15c>
}


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
   120ac:	defffd04 	addi	sp,sp,-12
   120b0:	dc400115 	stw	r17,4(sp)
   120b4:	dc000015 	stw	r16,0(sp)
   120b8:	dfc00215 	stw	ra,8(sp)
   120bc:	2821883a 	mov	r16,r5
   120c0:	2023883a 	mov	r17,r4
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   120c4:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   120c8:	1000021e 	bne	r2,zero,120d4 <Write_File_Record_At_Offset+0x30>


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
   120cc:	0005883a 	mov	r2,zero
   120d0:	00004606 	br	121ec <Write_File_Record_At_Offset+0x148>
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   120d4:	d0a0fa17 	ldw	r2,-31768(gp)
   120d8:	103ffc26 	beq	r2,zero,120cc <_gp+0xffff6c3c>
   120dc:	81000044 	addi	r4,r16,1
   120e0:	80800204 	addi	r2,r16,8
   120e4:	8007883a 	mov	r3,r16
        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
   120e8:	8c11c83a 	sub	r8,r17,r16
   120ec:	d160f117 	ldw	r5,-31804(gp)
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
   120f0:	21800003 	ldbu	r6,0(r4)
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
   120f4:	29400a17 	ldw	r5,40(r5)
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
        {
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
   120f8:	300e923a 	slli	r7,r6,8
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
   120fc:	40cd883a 	add	r6,r8,r3
   12100:	314b883a 	add	r5,r6,r5
   12104:	19800003 	ldbu	r6,0(r3)
   12108:	398cb03a 	or	r6,r7,r6
   1210c:	2980002d 	sthio	r6,0(r5)
   12110:	18c00084 	addi	r3,r3,2
   12114:	21000084 	addi	r4,r4,2
    bool result = false;
    if (((offset & 0x01f) == 0) && (alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
    {
        int counter;

        for (counter = 0; counter < 8; counter=counter+2)
   12118:	10fff41e 	bne	r2,r3,120ec <_gp+0xffff6c5c>
   1211c:	814002c4 	addi	r5,r16,11
   12120:	8807883a 	mov	r3,r17
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
   12124:	d120f117 	ldw	r4,-31804(gp)
   12128:	11800003 	ldbu	r6,0(r2)
   1212c:	21000a17 	ldw	r4,40(r4)
   12130:	1909883a 	add	r4,r3,r4
   12134:	21800225 	stbio	r6,8(r4)
   12138:	10800044 	addi	r2,r2,1
   1213c:	18c00044 	addi	r3,r3,1
            short int two_chars = (short int) record->name[counter+1];
            two_chars = two_chars << 8;
            two_chars = two_chars | record->name[counter];
            IOWR_16DIRECT(device_pointer->base, offset+counter, two_chars);
        }        
        for (counter = 0; counter < 3; counter++)
   12140:	28bff81e 	bne	r5,r2,12124 <_gp+0xffff6c94>
        {
            IOWR_8DIRECT(device_pointer->base, offset+counter+8, record->extension[counter]);
        }        
        IOWR_8DIRECT(device_pointer->base, offset+11, record->attributes);
   12144:	d0a0f117 	ldw	r2,-31804(gp)
   12148:	80c002c3 	ldbu	r3,11(r16)
   1214c:	10800a17 	ldw	r2,40(r2)
   12150:	8885883a 	add	r2,r17,r2
   12154:	10c002e5 	stbio	r3,11(r2)
        /* Ignore reserved bytes at locations 12 and 13. */
        IOWR_16DIRECT(device_pointer->base, offset+14, record->create_time);
   12158:	d0a0f117 	ldw	r2,-31804(gp)
   1215c:	80c0030b 	ldhu	r3,12(r16)
   12160:	10800a17 	ldw	r2,40(r2)
   12164:	8885883a 	add	r2,r17,r2
   12168:	10c003ad 	sthio	r3,14(r2)
        IOWR_16DIRECT(device_pointer->base, offset+16, record->create_date);
   1216c:	d0a0f117 	ldw	r2,-31804(gp)
   12170:	80c0038b 	ldhu	r3,14(r16)
   12174:	10800a17 	ldw	r2,40(r2)
   12178:	8885883a 	add	r2,r17,r2
   1217c:	10c0042d 	sthio	r3,16(r2)
        IOWR_16DIRECT(device_pointer->base, offset+18, record->last_access_date);
   12180:	d0a0f117 	ldw	r2,-31804(gp)
   12184:	80c0040b 	ldhu	r3,16(r16)
   12188:	10800a17 	ldw	r2,40(r2)
   1218c:	8885883a 	add	r2,r17,r2
   12190:	10c004ad 	sthio	r3,18(r2)
        /* Ignore reserved bytes at locations 20 and 21. */
        IOWR_16DIRECT(device_pointer->base, offset+22, record->last_modified_time);
   12194:	d0a0f117 	ldw	r2,-31804(gp)
   12198:	80c0048b 	ldhu	r3,18(r16)
   1219c:	10800a17 	ldw	r2,40(r2)
   121a0:	8885883a 	add	r2,r17,r2
   121a4:	10c005ad 	sthio	r3,22(r2)
        IOWR_16DIRECT(device_pointer->base, offset+24, record->last_modified_date);
   121a8:	d0a0f117 	ldw	r2,-31804(gp)
   121ac:	80c0050b 	ldhu	r3,20(r16)
   121b0:	10800a17 	ldw	r2,40(r2)
   121b4:	8885883a 	add	r2,r17,r2
   121b8:	10c0062d 	sthio	r3,24(r2)
        IOWR_16DIRECT(device_pointer->base, offset+26, record->start_cluster_index);
   121bc:	d0a0f117 	ldw	r2,-31804(gp)
   121c0:	80c0058b 	ldhu	r3,22(r16)
   121c4:	10800a17 	ldw	r2,40(r2)
   121c8:	8885883a 	add	r2,r17,r2
   121cc:	10c006ad 	sthio	r3,26(r2)
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
   121d0:	d0a0f117 	ldw	r2,-31804(gp)
   121d4:	11000a17 	ldw	r4,40(r2)
   121d8:	80800617 	ldw	r2,24(r16)
   121dc:	8923883a 	add	r17,r17,r4
   121e0:	88800735 	stwio	r2,28(r17)
        current_sector_modified = true;                  
   121e4:	00800044 	movi	r2,1
   121e8:	d0a0f015 	stw	r2,-31808(gp)
        result = true;
    }
    return result;
}
   121ec:	dfc00217 	ldw	ra,8(sp)
   121f0:	dc400117 	ldw	r17,4(sp)
   121f4:	dc000017 	ldw	r16,0(sp)
   121f8:	dec00304 	addi	sp,sp,12
   121fc:	f800283a 	ret


bool Write_File_Record_At_Offset(int offset, t_file_record *record)
// This function writes a file record at a given offset. The offset is given in bytes.
{
    bool result = false;
   12200:	0005883a 	mov	r2,zero
        IOWR_32DIRECT(device_pointer->base, offset+28, record->file_size_in_bytes);
        current_sector_modified = true;                  
        result = true;
    }
    return result;
}
   12204:	f800283a 	ret

00012208 <create_file>:

}

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
   12208:	defff904 	addi	sp,sp,-28
   1220c:	dd000515 	stw	r20,20(sp)
   12210:	2029883a 	mov	r20,r4
    unsigned int cluster_number;
    bool result = false;
    
    if (find_first_empty_cluster(&cluster_number))
   12214:	d809883a 	mov	r4,sp

}

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
   12218:	dcc00415 	stw	r19,16(sp)
   1221c:	dc000115 	stw	r16,4(sp)
   12220:	dfc00615 	stw	ra,24(sp)
   12224:	dc800315 	stw	r18,12(sp)
   12228:	dc400215 	stw	r17,8(sp)
   1222c:	2821883a 	mov	r16,r5
   12230:	3027883a 	mov	r19,r6
    unsigned int cluster_number;
    bool result = false;
    
    if (find_first_empty_cluster(&cluster_number))
   12234:	00117080 	call	11708 <find_first_empty_cluster>
   12238:	1000021e 	bne	r2,zero,12244 <create_file+0x3c>

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    unsigned int cluster_number;
    bool result = false;
   1223c:	0005883a 	mov	r2,zero
   12240:	00004b06 	br	12370 <create_file+0x168>
    
    if (find_first_empty_cluster(&cluster_number))
    {
        int record_index;
        
        if (home_dir->file_record_cluster == 0)
   12244:	98800a17 	ldw	r2,40(r19)
   12248:	1000021e 	bne	r2,zero,12254 <create_file+0x4c>
        {
            // Put a file in the root directory.
            record_index = find_first_empty_record_in_root_directory();
   1224c:	00119480 	call	11948 <find_first_empty_record_in_root_directory>
   12250:	00000206 	br	1225c <create_file+0x54>
        }
        else
        {
            // Put a file in a subdirectory.
            record_index = find_first_empty_record_in_a_subdirectory(home_dir->start_cluster_index);           
   12254:	9900058b 	ldhu	r4,22(r19)
   12258:	00117ac0 	call	117ac <find_first_empty_record_in_a_subdirectory>
   1225c:	1023883a 	mov	r17,r2
        }
        if (record_index >= 0)
   12260:	103ff616 	blt	r2,zero,1223c <_gp+0xffff6dac>
        {   
            unsigned int file_record_sector;
            int location = get_dir_divider_location( name );
   12264:	a009883a 	mov	r4,r20
   12268:	0010de00 	call	10de0 <get_dir_divider_location>
            int last_dir_separator = 0;
   1226c:	0025883a 	mov	r18,zero

            // Skip through all directory separators.
            while (location > 0)
   12270:	0080050e 	bge	zero,r2,12288 <create_file+0x80>
            {
                last_dir_separator = last_dir_separator+location+1;
   12274:	14a5883a 	add	r18,r2,r18
   12278:	94800044 	addi	r18,r18,1
                location = get_dir_divider_location( &(name[last_dir_separator]) );
   1227c:	a489883a 	add	r4,r20,r18
   12280:	0010de00 	call	10de0 <get_dir_divider_location>
   12284:	003ffa06 	br	12270 <_gp+0xffff6de0>
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
   12288:	a489883a 	add	r4,r20,r18
   1228c:	81800204 	addi	r6,r16,8
   12290:	800b883a 	mov	r5,r16
   12294:	0010f240 	call	10f24 <convert_filename_to_name_extension>
            file_record->create_time = 0;
            file_record->create_date = 0;
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
   12298:	d8800017 	ldw	r2,0(sp)
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
   1229c:	893fffcc 	andi	r4,r17,65535
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
   122a0:	8822d43a 	srli	r17,r17,16
                location = get_dir_divider_location( &(name[last_dir_separator]) );
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
   122a4:	800002c5 	stb	zero,11(r16)
            file_record->create_time = 0;
            file_record->create_date = 0;
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
   122a8:	8080058d 	sth	r2,22(r16)
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
   122ac:	8825d13a 	srai	r18,r17,4
            file_record->last_access_date = 0;
            file_record->last_modified_time = 0;
            file_record->last_modified_date = 0;
            file_record->start_cluster_index = cluster_number;
            file_record->file_size_in_bytes = 0;
            file_record->current_cluster_index = cluster_number;
   122b0:	80800715 	stw	r2,28(r16)
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
   122b4:	8c4003cc 	andi	r17,r17,15
            file_record->home_directory_cluster = home_dir->start_cluster_index;
   122b8:	9880058b 	ldhu	r2,22(r19)
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
   122bc:	8822917a 	slli	r17,r17,5
            }
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
            file_record->create_time = 0;
   122c0:	8000030d 	sth	zero,12(r16)
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
   122c4:	80800d15 	stw	r2,52(r16)
            file_record->in_use = true;
   122c8:	00800044 	movi	r2,1
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
            file_record->current_byte_position = 0;
            file_record->file_record_cluster = record_index & 0x0000ffff;
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
   122cc:	84400c0d 	sth	r17,48(r16)
            
            convert_filename_to_name_extension(&(name[last_dir_separator]), (char *)file_record->name, (char *)file_record->extension);
                         
            file_record->attributes = 0;
            file_record->create_time = 0;
            file_record->create_date = 0;
   122d0:	8000038d 	sth	zero,14(r16)
   122d4:	04400074 	movhi	r17,1
            file_record->last_access_date = 0;
   122d8:	8000040d 	sth	zero,16(r16)
            file_record->last_modified_time = 0;
   122dc:	8000048d 	sth	zero,18(r16)
            file_record->last_modified_date = 0;
   122e0:	8000050d 	sth	zero,20(r16)
            file_record->start_cluster_index = cluster_number;
            file_record->file_size_in_bytes = 0;
   122e4:	80000615 	stw	zero,24(r16)
            file_record->current_cluster_index = cluster_number;
            file_record->current_sector_in_cluster = 0;
   122e8:	80000815 	stw	zero,32(r16)
            file_record->current_byte_position = 0;
   122ec:	80000915 	stw	zero,36(r16)
            file_record->file_record_cluster = record_index & 0x0000ffff;
   122f0:	81000a15 	stw	r4,40(r16)
            file_record->file_record_sector_in_cluster = ((record_index >> 16) & 0x0000ffff) / 16;
   122f4:	84800b15 	stw	r18,44(r16)
            file_record->file_record_offset = (((record_index >> 16) & 0x0000ffff) % 16)*32;   
            file_record->home_directory_cluster = home_dir->start_cluster_index;
            file_record->in_use = true;
   122f8:	80800f15 	stw	r2,60(r16)
            file_record->modified = true;
   122fc:	80800e15 	stw	r2,56(r16)
   12300:	8c4e2504 	addi	r17,r17,14484
            // Now write the record at the specified location.
            file_record_sector = (file_record->file_record_cluster == 0) ? 
                                    (boot_sector_data.root_directory_sector_offset + file_record->file_record_sector_in_cluster):  
   12304:	2000031e 	bne	r4,zero,12314 <create_file+0x10c>
   12308:	89001317 	ldw	r4,76(r17)
   1230c:	9109883a 	add	r4,r18,r4
   12310:	00000606 	br	1232c <create_file+0x124>
   12314:	89400383 	ldbu	r5,14(r17)
   12318:	213fff84 	addi	r4,r4,-2
   1231c:	0010ae80 	call	10ae8 <__mulsi3>
   12320:	89001417 	ldw	r4,80(r17)
   12324:	1105883a 	add	r2,r2,r4
   12328:	1489883a 	add	r4,r2,r18
                                    (boot_sector_data.data_sector_offset + (file_record->file_record_cluster-2)*boot_sector_data.sectors_per_cluster +
                                     file_record->file_record_sector_in_cluster);

			if (Read_Sector_Data(file_record_sector, fat_partition_offset_in_512_byte_sectors))
   1232c:	d160f317 	ldw	r5,-31796(gp)
   12330:	00111a80 	call	111a8 <Read_Sector_Data>
   12334:	103fc126 	beq	r2,zero,1223c <_gp+0xffff6dac>
            {
                if (Write_File_Record_At_Offset(file_record->file_record_offset, file_record))
   12338:	81000c0f 	ldh	r4,48(r16)
   1233c:	800b883a 	mov	r5,r16
   12340:	00120a40 	call	120a4 <Write_File_Record_At_Offset>
   12344:	103fbd26 	beq	r2,zero,1223c <_gp+0xffff6dac>
                {
                    Save_Modified_Sector();
   12348:	001118c0 	call	1118c <Save_Modified_Sector>
                    // Mark the first cluster of the file as the last cluster at first.
                    mark_cluster(cluster_number, ((short int) (0xffff)), true);
   1234c:	d9000017 	ldw	r4,0(sp)
   12350:	01800044 	movi	r6,1
   12354:	017fffc4 	movi	r5,-1
   12358:	00112c80 	call	112c8 <mark_cluster>
                    if (mark_cluster(cluster_number, ((short int) (0xffff)), false))
   1235c:	d9000017 	ldw	r4,0(sp)
   12360:	000d883a 	mov	r6,zero
   12364:	017fffc4 	movi	r5,-1
   12368:	00112c80 	call	112c8 <mark_cluster>

bool create_file(char *name, t_file_record *file_record, t_file_record *home_dir)
// Create a file in a given directory. Expand the directory if needed.
{
    unsigned int cluster_number;
    bool result = false;
   1236c:	1004c03a 	cmpne	r2,r2,zero
            }
        }

    }
    return result;           
}
   12370:	dfc00617 	ldw	ra,24(sp)
   12374:	dd000517 	ldw	r20,20(sp)
   12378:	dcc00417 	ldw	r19,16(sp)
   1237c:	dc800317 	ldw	r18,12(sp)
   12380:	dc400217 	ldw	r17,8(sp)
   12384:	dc000117 	ldw	r16,4(sp)
   12388:	dec00704 	addi	sp,sp,28
   1238c:	f800283a 	ret

00012390 <Look_for_FAT16>:
}


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
   12390:	deffff04 	addi	sp,sp,-4
   12394:	dfc00015 	stw	ra,0(sp)
	bool result = false;

	if (alt_up_sd_card_is_Present())
   12398:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   1239c:	1000021e 	bne	r2,zero,123a8 <Look_for_FAT16+0x18>


bool Look_for_FAT16(void)
// Read the SD card to determine if it contains a FAT16 partition.
{
	bool result = false;
   123a0:	0005883a 	mov	r2,zero
   123a4:	00001d06 	br	1241c <Look_for_FAT16+0x8c>

	if (alt_up_sd_card_is_Present())
	{
		short int csd_file_format = *CSD_register_w0;
   123a8:	d0a0f717 	ldw	r2,-31780(gp)
   123ac:	1080000b 	ldhu	r2,0(r2)
        
		fat_partition_offset_in_512_byte_sectors = 0;
   123b0:	d020f315 	stw	zero,-31796(gp)
		fat_partition_size_in_512_byte_sectors = 0;              
   123b4:	d020f215 	stw	zero,-31800(gp)

		if (((csd_file_format & 0x8000) == 0) && ((csd_file_format & 0x0c00) != 0x0c00))
   123b8:	10ffffcc 	andi	r3,r2,65535
   123bc:	18e0001c 	xori	r3,r3,32768
   123c0:	18e00004 	addi	r3,r3,-32768
   123c4:	183ff616 	blt	r3,zero,123a0 <_gp+0xffff6f10>
   123c8:	1083000c 	andi	r2,r2,3072
   123cc:	00c30004 	movi	r3,3072
   123d0:	10fff326 	beq	r2,r3,123a0 <_gp+0xffff6f10>
		{
			if ((csd_file_format & 0x0c00) == 0x0400)
   123d4:	00c10004 	movi	r3,1024
   123d8:	10c0021e 	bne	r2,r3,123e4 <Look_for_FAT16+0x54>
			{
				/* SD Card contains files stored in a DOS FAT (floppy like) file format, without a partition table */
				result = Check_for_DOS_FAT(0);
   123dc:	0009883a 	mov	r4,zero
   123e0:	00000406 	br	123f4 <Look_for_FAT16+0x64>
			}
			if ((csd_file_format & 0x0c00) == 0x0000)
   123e4:	103fee1e 	bne	r2,zero,123a0 <_gp+0xffff6f10>
			{
				/* SD Card contains files stored in a Hard disk-like file format that contains a partition table */
				if (Check_for_Master_Boot_Record())
   123e8:	00113540 	call	11354 <Check_for_Master_Boot_Record>
   123ec:	103fec26 	beq	r2,zero,123a0 <_gp+0xffff6f10>
				{
					result = Check_for_DOS_FAT(fat_partition_offset_in_512_byte_sectors);
   123f0:	d120f317 	ldw	r4,-31796(gp)
   123f4:	001145c0 	call	1145c <Check_for_DOS_FAT>
				}                        
			}
			if (result == true)
   123f8:	00c00044 	movi	r3,1
   123fc:	10c0071e 	bne	r2,r3,1241c <Look_for_FAT16+0x8c>
			{
				// Accept only FAT16, not FAT12.
				if (boot_sector_data.bits_for_cluster_index != 16)
   12400:	00c00074 	movhi	r3,1
   12404:	18ce2504 	addi	r3,r3,14484
   12408:	19401083 	ldbu	r5,66(r3)
   1240c:	01000404 	movi	r4,16
   12410:	293fe31e 	bne	r5,r4,123a0 <_gp+0xffff6f10>
				{
					result = false;
				}
				else
				{
					fat_partition_size_in_512_byte_sectors = boot_sector_data.number_of_sectors_in_partition;
   12414:	18c0058b 	ldhu	r3,22(r3)
   12418:	d0e0f215 	stw	r3,-31800(gp)
				}
			}
		}
	}
	return result;
}
   1241c:	dfc00017 	ldw	ra,0(sp)
   12420:	dec00104 	addi	sp,sp,4
   12424:	f800283a 	ret

00012428 <alt_up_sd_card_is_FAT16>:
/* This function reads the SD card data in an effort to determine if the card is formated as a FAT16
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
   12428:	deffff04 	addi	sp,sp,-4
   1242c:	dfc00015 	stw	ra,0(sp)
	bool result = false;

	if (alt_up_sd_card_is_Present())
   12430:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   12434:	10000a26 	beq	r2,zero,12460 <alt_up_sd_card_is_FAT16+0x38>
	{
		// Check if an SD Card is in the SD Card slot.
		if (initialized == false)
   12438:	d0a0fb17 	ldw	r2,-31764(gp)
   1243c:	1000061e 	bne	r2,zero,12458 <alt_up_sd_card_is_FAT16+0x30>
		{
			// Now determine if the card is formatted as FAT 16.
			is_sd_card_formated_as_FAT16 = Look_for_FAT16();
   12440:	00123900 	call	12390 <Look_for_FAT16>
   12444:	d0a0fa15 	stw	r2,-31768(gp)
			initialized = is_sd_card_formated_as_FAT16;
   12448:	d0a0fb15 	stw	r2,-31764(gp)
			search_data.valid = false;
   1244c:	00800074 	movhi	r2,1
   12450:	108e2004 	addi	r2,r2,14464
   12454:	10000415 	stw	zero,16(r2)
		}
		result = is_sd_card_formated_as_FAT16;
   12458:	d0a0fa17 	ldw	r2,-31768(gp)
   1245c:	00000306 	br	1246c <alt_up_sd_card_is_FAT16+0x44>
	}
	else
	{
		// If not then you may as well not open the device.
		initialized = false;
   12460:	d020fb15 	stw	zero,-31764(gp)
		is_sd_card_formated_as_FAT16 = false;
   12464:	d020fa15 	stw	zero,-31768(gp)
 * volume. Please note that FAT12 has a similar format, but will not be supported by this driver.
 * If the card contains a FAT16 volume, the local data structures will be initialized to allow reading and writing
 * to the SD card as though it was a hard drive.
 */
{
	bool result = false;
   12468:	0005883a 	mov	r2,zero
		initialized = false;
		is_sd_card_formated_as_FAT16 = false;
	}

	return result;
}
   1246c:	dfc00017 	ldw	ra,0(sp)
   12470:	dec00104 	addi	sp,sp,4
   12474:	f800283a 	ret

00012478 <alt_up_sd_card_find_next>:
 *		-1 - end of directory.
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
   12478:	deffe404 	addi	sp,sp,-112
   1247c:	dd401715 	stw	r21,92(sp)
   12480:	dfc01b15 	stw	ra,108(sp)
   12484:	df001a15 	stw	fp,104(sp)
   12488:	ddc01915 	stw	r23,100(sp)
   1248c:	dd801815 	stw	r22,96(sp)
   12490:	dd001615 	stw	r20,88(sp)
   12494:	dcc01515 	stw	r19,84(sp)
   12498:	dc801415 	stw	r18,80(sp)
   1249c:	dc401315 	stw	r17,76(sp)
   124a0:	dc001215 	stw	r16,72(sp)
   124a4:	202b883a 	mov	r21,r4
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   124a8:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   124ac:	10006c26 	beq	r2,zero,12660 <alt_up_sd_card_find_next+0x1e8>
   124b0:	d0a0fa17 	ldw	r2,-31768(gp)
   124b4:	10006a26 	beq	r2,zero,12660 <alt_up_sd_card_find_next+0x1e8>
	{
		if (search_data.valid)
   124b8:	04400074 	movhi	r17,1
   124bc:	8c4e2004 	addi	r17,r17,14464
   124c0:	88800417 	ldw	r2,16(r17)
   124c4:	10006826 	beq	r2,zero,12668 <alt_up_sd_card_find_next+0x1f0>
		{
			t_file_record file_record;
			int cluster = search_data.current_cluster_index;
   124c8:	8c800117 	ldw	r18,4(r17)
   124cc:	05000074 	movhi	r20,1
   124d0:	a50e2504 	addi	r20,r20,14484
   124d4:	8c00030f 	ldh	r16,12(r17)

			if (cluster == 0)
   124d8:	9000251e 	bne	r18,zero,12570 <alt_up_sd_card_find_next+0xf8>
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   124dc:	a100050b 	ldhu	r4,20(r20)
   124e0:	a140030b 	ldhu	r5,12(r20)
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
   124e4:	84000044 	addi	r16,r16,1
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   124e8:	2008917a 	slli	r4,r4,5
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
   124ec:	05c003c4 	movi	r23,15
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
   124f0:	07003944 	movi	fp,229
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   124f4:	00109340 	call	10934 <__divsi3>
				int sector_index = search_data.current_sector_in_cluster;
   124f8:	8c800217 	ldw	r18,8(r17)
			int cluster = search_data.current_cluster_index;

			if (cluster == 0)
			{
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
   124fc:	102d883a 	mov	r22,r2
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
   12500:	9580050e 	bge	r18,r22,12518 <alt_up_sd_card_find_next+0xa0>
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
   12504:	a1001317 	ldw	r4,76(r20)
   12508:	d160f317 	ldw	r5,-31796(gp)
   1250c:	9109883a 	add	r4,r18,r4
   12510:	00111a80 	call	111a8 <Read_Sector_Data>
   12514:	1000021e 	bne	r2,zero,12520 <alt_up_sd_card_find_next+0xa8>
					else
					{
						break;
					}
				}
				result = -1;
   12518:	04ffffc4 	movi	r19,-1
   1251c:	00004e06 	br	12658 <alt_up_sd_card_find_next+0x1e0>
   12520:	8026917a 	slli	r19,r16,5
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
   12524:	bc000f16 	blt	r23,r16,12564 <alt_up_sd_card_find_next+0xec>
						{
							if (Read_File_Record_At_Offset(file_counter*32, &file_record, 0, sector_index))
   12528:	900f883a 	mov	r7,r18
   1252c:	000d883a 	mov	r6,zero
   12530:	d80b883a 	mov	r5,sp
   12534:	9809883a 	mov	r4,r19
   12538:	0011a100 	call	11a10 <Read_File_Record_At_Offset>
   1253c:	10000626 	beq	r2,zero,12558 <alt_up_sd_card_find_next+0xe0>
							{
								if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
   12540:	d8800003 	ldbu	r2,0(sp)
   12544:	10000426 	beq	r2,zero,12558 <alt_up_sd_card_find_next+0xe0>
   12548:	17000326 	beq	r2,fp,12558 <alt_up_sd_card_find_next+0xe0>
								{
									/* Update search structure. */
									search_data.file_index_in_sector = file_counter;
   1254c:	8c00030d 	sth	r16,12(r17)
									search_data.current_sector_in_cluster = sector_index;
   12550:	8c800215 	stw	r18,8(r17)
   12554:	00002906 	br	125fc <alt_up_sd_card_find_next+0x184>
				for (; sector_index < max_root_dir_sectors; sector_index++)
				{
					if (Read_Sector_Data(   sector_index + boot_sector_data.root_directory_sector_offset,
											fat_partition_offset_in_512_byte_sectors))
					{
						for (; file_counter < 16; file_counter++)
   12558:	84000044 	addi	r16,r16,1
   1255c:	9cc00804 	addi	r19,r19,32
   12560:	003ff006 	br	12524 <_gp+0xffff7094>
				// Searching through the root directory
				int max_root_dir_sectors = ((32*boot_sector_data.max_number_of_dir_entires) / boot_sector_data.sector_size_in_bytes);
				int sector_index = search_data.current_sector_in_cluster;
				int file_counter = search_data.file_index_in_sector+1;
    
				for (; sector_index < max_root_dir_sectors; sector_index++)
   12564:	94800044 	addi	r18,r18,1
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
								}
							}
						}
						file_counter = 0;
   12568:	0021883a 	mov	r16,zero
   1256c:	003fe406 	br	12500 <_gp+0xffff7070>
				}
				result = -1;
			}
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
   12570:	84000044 	addi	r16,r16,1
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
	short int result = 2;
   12574:	04c00084 	movi	r19,2
						{        
							for (; file_counter < 16; file_counter++)
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
   12578:	05c03944 	movi	r23,229
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   1257c:	a1400383 	ldbu	r5,14(r20)
   12580:	913fff84 	addi	r4,r18,-2
   12584:	0010ae80 	call	10ae8 <__mulsi3>
   12588:	a7001417 	ldw	fp,80(r20)
					int sector_index = search_data.current_sector_in_cluster;
   1258c:	8d800217 	ldw	r22,8(r17)
			else
			{
				int file_counter = search_data.file_index_in_sector+1;
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
   12590:	1739883a 	add	fp,r2,fp
   12594:	00000206 	br	125a0 <alt_up_sd_card_find_next+0x128>
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   12598:	b5800044 	addi	r22,r22,1
										copy_file_record_name_to_string(&file_record, file_name);
										return 0;
									}
								}
							}
							file_counter = 0;
   1259c:	0021883a 	mov	r16,zero
				do 
				{
					int start_sector = ( cluster - 2 ) * ( boot_sector_data.sectors_per_cluster ) + boot_sector_data.data_sector_offset;
					int sector_index = search_data.current_sector_in_cluster;
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
   125a0:	a0800383 	ldbu	r2,14(r20)
   125a4:	b0801a0e 	bge	r22,r2,12610 <alt_up_sd_card_find_next+0x198>
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
   125a8:	d160f317 	ldw	r5,-31796(gp)
   125ac:	e589883a 	add	r4,fp,r22
   125b0:	00111a80 	call	111a8 <Read_Sector_Data>
   125b4:	10001626 	beq	r2,zero,12610 <alt_up_sd_card_find_next+0x198>
   125b8:	8010917a 	slli	r8,r16,5
						{        
							for (; file_counter < 16; file_counter++)
   125bc:	008003c4 	movi	r2,15
   125c0:	143ff516 	blt	r2,r16,12598 <_gp+0xffff7108>
							{
								if (Read_File_Record_At_Offset(file_counter*32, &file_record, cluster, sector_index))
   125c4:	4009883a 	mov	r4,r8
   125c8:	b00f883a 	mov	r7,r22
   125cc:	900d883a 	mov	r6,r18
   125d0:	d80b883a 	mov	r5,sp
   125d4:	da001115 	stw	r8,68(sp)
   125d8:	0011a100 	call	11a10 <Read_File_Record_At_Offset>
   125dc:	da001117 	ldw	r8,68(sp)
   125e0:	10000e26 	beq	r2,zero,1261c <alt_up_sd_card_find_next+0x1a4>
								{
									if ((file_record.name[0] != 0) && (file_record.name[0] != 0xe5))
   125e4:	d8800003 	ldbu	r2,0(sp)
   125e8:	10000c26 	beq	r2,zero,1261c <alt_up_sd_card_find_next+0x1a4>
   125ec:	15c00b26 	beq	r2,r23,1261c <alt_up_sd_card_find_next+0x1a4>
									{
										/* Update search structure. */
										search_data.current_cluster_index = cluster;
   125f0:	8c800115 	stw	r18,4(r17)
										search_data.file_index_in_sector = file_counter;
   125f4:	8c00030d 	sth	r16,12(r17)
										search_data.current_sector_in_cluster = sector_index;
   125f8:	8d800215 	stw	r22,8(r17)

										/* Copy file name.*/
										copy_file_record_name_to_string(&file_record, file_name);
   125fc:	a80b883a 	mov	r5,r21
   12600:	d809883a 	mov	r4,sp
   12604:	0010fbc0 	call	10fbc <copy_file_record_name_to_string>
									search_data.file_index_in_sector = file_counter;
									search_data.current_sector_in_cluster = sector_index;

									/* Copy file name.*/
									copy_file_record_name_to_string(&file_record, file_name);
									return 0;
   12608:	0005883a 	mov	r2,zero
   1260c:	00001706 	br	1266c <alt_up_sd_card_find_next+0x1f4>
							break;
						}
					}
					// If this is the end of the cluster and the file has not been found, then see if there is another cluster
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
   12610:	a0800383 	ldbu	r2,14(r20)
   12614:	b0800e16 	blt	r22,r2,12650 <alt_up_sd_card_find_next+0x1d8>
   12618:	00000306 	br	12628 <alt_up_sd_card_find_next+0x1b0>
			        
					for (; sector_index < boot_sector_data.sectors_per_cluster; sector_index++)
					{
						if (Read_Sector_Data(sector_index + start_sector, fat_partition_offset_in_512_byte_sectors))
						{        
							for (; file_counter < 16; file_counter++)
   1261c:	84000044 	addi	r16,r16,1
   12620:	42000804 	addi	r8,r8,32
   12624:	003fe506 	br	125bc <_gp+0xffff712c>
					// that holds data for the current directory.
					if (sector_index >= boot_sector_data.sectors_per_cluster)
					{
						unsigned short int new_cluster;

						if (get_cluster_flag(cluster, &new_cluster))
   12628:	d9401004 	addi	r5,sp,64
   1262c:	9009883a 	mov	r4,r18
   12630:	00112480 	call	11248 <get_cluster_flag>
   12634:	10000526 	beq	r2,zero,1264c <alt_up_sd_card_find_next+0x1d4>
   12638:	dc80100b 	ldhu	r18,64(sp)
						{
							if ((new_cluster & 0x0000fff8) == 0x0000fff8)
   1263c:	00bffe14 	movui	r2,65528
   12640:	94bffe0c 	andi	r18,r18,65528
   12644:	9080021e 	bne	r18,r2,12650 <alt_up_sd_card_find_next+0x1d8>
							{
								result = -1;
								search_data.valid = false;
   12648:	88000415 	stw	zero,16(r17)
							cluster = ((new_cluster) & 0x0000fff8);
						}
						else
						{
							// Error encountered.                 
							result = -1;
   1264c:	04ffffc4 	movi	r19,-1
						}
					}              
				} while (cluster < 0x0000fff8);
   12650:	00bffdd4 	movui	r2,65527
   12654:	14bfc90e 	bge	r2,r18,1257c <_gp+0xffff70ec>
   12658:	9805883a 	mov	r2,r19
   1265c:	00000306 	br	1266c <alt_up_sd_card_find_next+0x1f4>
 *		0 - success
 *		2 - No card or incorrect card format.
 *		3 - find_first has not been called successfully.
 */
{
	short int result = 2;
   12660:	00800084 	movi	r2,2
   12664:	00000106 	br	1266c <alt_up_sd_card_find_next+0x1f4>
			}
		}
		else
		{
			// Call Find_First first.
			result = 3;
   12668:	008000c4 	movi	r2,3
		}
	}
	return result;
}
   1266c:	dfc01b17 	ldw	ra,108(sp)
   12670:	df001a17 	ldw	fp,104(sp)
   12674:	ddc01917 	ldw	r23,100(sp)
   12678:	dd801817 	ldw	r22,96(sp)
   1267c:	dd401717 	ldw	r21,92(sp)
   12680:	dd001617 	ldw	r20,88(sp)
   12684:	dcc01517 	ldw	r19,84(sp)
   12688:	dc801417 	ldw	r18,80(sp)
   1268c:	dc401317 	ldw	r17,76(sp)
   12690:	dc001217 	ldw	r16,72(sp)
   12694:	dec01c04 	addi	sp,sp,112
   12698:	f800283a 	ret

0001269c <alt_up_sd_card_find_first>:
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
   1269c:	deffec04 	addi	sp,sp,-80
   126a0:	dc001215 	stw	r16,72(sp)
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   126a4:	d9001115 	stw	r4,68(sp)
 * "first/sub/." - look through a directory named "sub", that is located within the subdirectory named "first". "first" is located in the root directory.
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
   126a8:	dfc01315 	stw	ra,76(sp)
   126ac:	2821883a 	mov	r16,r5
	short int result = 2;
	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   126b0:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   126b4:	d9001117 	ldw	r4,68(sp)
   126b8:	10001526 	beq	r2,zero,12710 <alt_up_sd_card_find_first+0x74>
   126bc:	d0a0fa17 	ldw	r2,-31768(gp)
   126c0:	10001326 	beq	r2,zero,12710 <alt_up_sd_card_find_first+0x74>
	{
		int home_directory_cluster;
		t_file_record file_record;

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
   126c4:	d80d883a 	mov	r6,sp
   126c8:	d9401004 	addi	r5,sp,64
   126cc:	0011b880 	call	11b88 <get_home_directory_cluster_for_file>
   126d0:	10000d26 	beq	r2,zero,12708 <alt_up_sd_card_find_first+0x6c>
		{
			search_data.directory_root_cluster = home_directory_cluster;
   126d4:	d8c01017 	ldw	r3,64(sp)
   126d8:	00800074 	movhi	r2,1
   126dc:	108e2004 	addi	r2,r2,14464
   126e0:	10c00015 	stw	r3,0(r2)
			search_data.current_cluster_index = home_directory_cluster;
   126e4:	10c00115 	stw	r3,4(r2)
			search_data.current_sector_in_cluster = 0;
			search_data.file_index_in_sector = -1;
   126e8:	00ffffc4 	movi	r3,-1
   126ec:	10c0030d 	sth	r3,12(r2)
			search_data.valid = true;
			result = alt_up_sd_card_find_next(file_name);
   126f0:	8009883a 	mov	r4,r16
		{
			search_data.directory_root_cluster = home_directory_cluster;
			search_data.current_cluster_index = home_directory_cluster;
			search_data.current_sector_in_cluster = 0;
			search_data.file_index_in_sector = -1;
			search_data.valid = true;
   126f4:	00c00044 	movi	r3,1
   126f8:	10c00415 	stw	r3,16(r2)

		if (get_home_directory_cluster_for_file(directory_to_search_through, &home_directory_cluster, &file_record))
		{
			search_data.directory_root_cluster = home_directory_cluster;
			search_data.current_cluster_index = home_directory_cluster;
			search_data.current_sector_in_cluster = 0;
   126fc:	10000215 	stw	zero,8(r2)
			search_data.file_index_in_sector = -1;
			search_data.valid = true;
			result = alt_up_sd_card_find_next(file_name);
   12700:	00124780 	call	12478 <alt_up_sd_card_find_next>
   12704:	00000306 	br	12714 <alt_up_sd_card_find_first+0x78>
		}
		else
		{
			result = 1;
   12708:	00800044 	movi	r2,1
   1270c:	00000106 	br	12714 <alt_up_sd_card_find_first+0x78>
 * Invalid examples include:
 * "/.", "/////." - this is not the root directory.
 * "/first/." - the first character may not be a '/'.
 */
{
	short int result = 2;
   12710:	00800084 	movi	r2,2
		{
			result = 1;
		}
	}
	return result;
}
   12714:	dfc01317 	ldw	ra,76(sp)
   12718:	dc001217 	ldw	r16,72(sp)
   1271c:	dec01404 	addi	sp,sp,80
   12720:	f800283a 	ret

00012724 <alt_up_sd_card_fopen>:
 *      create - a flag set to true to create a file if it does not already exist
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
   12724:	deffe804 	addi	sp,sp,-96
   12728:	dd401615 	stw	r21,88(sp)
   1272c:	dd001515 	stw	r20,84(sp)
   12730:	dfc01715 	stw	ra,92(sp)
   12734:	dcc01415 	stw	r19,80(sp)
   12738:	dc801315 	stw	r18,76(sp)
   1273c:	dc401215 	stw	r17,72(sp)
   12740:	dc001115 	stw	r16,68(sp)
   12744:	2029883a 	mov	r20,r4
   12748:	282b883a 	mov	r21,r5
	short int file_record_index = -1;

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   1274c:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   12750:	10004f26 	beq	r2,zero,12890 <alt_up_sd_card_fopen+0x16c>
   12754:	d0a0fa17 	ldw	r2,-31768(gp)
   12758:	10004d26 	beq	r2,zero,12890 <alt_up_sd_card_fopen+0x16c>
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
   1275c:	a009883a 	mov	r4,r20
{
	short int file_record_index = -1;

	if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
	{
        unsigned int home_directory_cluster = 0;
   12760:	d8001015 	stw	zero,64(sp)
         * Rules:
         *  - no spaces
         *  - at most 12 chatacters per name, with a period in 9th position.
         *  - a / or a \ every at most 12 characters.
         */
        filename_to_upper_case(name);
   12764:	0010cb00 	call	10cb0 <filename_to_upper_case>
        if (check_file_name_for_FAT16_compliance(name))
   12768:	a009883a 	mov	r4,r20
   1276c:	0010d040 	call	10d04 <check_file_name_for_FAT16_compliance>
   12770:	1000021e 	bne	r2,zero,1277c <alt_up_sd_card_fopen+0x58>
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
	short int file_record_index = -1;
   12774:	047fffc4 	movi	r17,-1
   12778:	00004306 	br	12888 <alt_up_sd_card_fopen+0x164>
        if (check_file_name_for_FAT16_compliance(name))
        {
			int index;

            /* Get home directory cluster location for the specified file. 0 means root directory. */
            if (!get_home_directory_cluster_for_file(name, (int *) &home_directory_cluster, &home_dir))
   1277c:	d80d883a 	mov	r6,sp
   12780:	d9401004 	addi	r5,sp,64
   12784:	a009883a 	mov	r4,r20
   12788:	0011b880 	call	11b88 <get_home_directory_cluster_for_file>
   1278c:	10004026 	beq	r2,zero,12890 <alt_up_sd_card_fopen+0x16c>
   12790:	04800074 	movhi	r18,1
   12794:	948e4904 	addi	r18,r18,14628
   12798:	9005883a 	mov	r2,r18
   1279c:	0027883a 	mov	r19,zero
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
   127a0:	00c00504 	movi	r3,20
    		{
    			if (active_files[index].in_use == false)
   127a4:	11000017 	ldw	r4,0(r2)
   127a8:	20000b1e 	bne	r4,zero,127d8 <alt_up_sd_card_fopen+0xb4>
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
   127ac:	982091ba 	slli	r16,r19,6
   127b0:	00c00074 	movhi	r3,1
   127b4:	18ce3a04 	addi	r3,r3,14568
   127b8:	d9001017 	ldw	r4,64(sp)
   127bc:	80e1883a 	add	r16,r16,r3
   127c0:	800d883a 	mov	r6,r16
   127c4:	a00b883a 	mov	r5,r20
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
    		{
    			if (active_files[index].in_use == false)
    			{
    				file_record_index = index;
   127c8:	9823883a 	mov	r17,r19
    		{
    			/* If file record is found, then look for the specified file. If the create flag is set to true 
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
   127cc:	0011e400 	call	11e40 <find_file_in_directory>
   127d0:	1000051e 	bne	r2,zero,127e8 <alt_up_sd_card_fopen+0xc4>
   127d4:	00002106 	br	1285c <alt_up_sd_card_fopen+0x138>
            {
                return file_record_index;
            }
            
    		/* Find a free file slot to store file specs in. */
    		for (index = 0; index < MAX_FILES_OPENED; index++)
   127d8:	9cc00044 	addi	r19,r19,1
   127dc:	10801004 	addi	r2,r2,64
   127e0:	98fff01e 	bne	r19,r3,127a4 <_gp+0xffff7314>
   127e4:	003fe306 	br	12774 <_gp+0xffff72e4>
    			 * and the file is not found, then it should be created in the current directory. 
    			 */
                
                if (find_file_in_directory(home_directory_cluster, name, &(active_files[file_record_index])))
                {
                    if (create)
   127e8:	a800291e 	bne	r21,zero,12890 <alt_up_sd_card_fopen+0x16c>
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
   127ec:	8080058b 	ldhu	r2,22(r16)
                    active_files[file_record_index].current_sector_in_cluster = 0;
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
   127f0:	00c00044 	movi	r3,1
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
                    active_files[file_record_index].current_sector_in_cluster = 0;
   127f4:	80000815 	stw	zero,32(r16)
                    if (create)
                    {
                        /* Do not allow overwriting existing files for now. */
                        return -1;
                    }
                    active_files[file_record_index].current_cluster_index = active_files[file_record_index].start_cluster_index;
   127f8:	80800715 	stw	r2,28(r16)
                    active_files[file_record_index].current_sector_in_cluster = 0;
                    active_files[file_record_index].current_byte_position = 0;
   127fc:	80000915 	stw	zero,36(r16)
                    active_files[file_record_index].in_use = true;
   12800:	80c00f15 	stw	r3,60(r16)
    				active_files[file_record_index].modified = false;
   12804:	80000e15 	stw	zero,56(r16)
					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
   12808:	81400a04 	addi	r5,r16,40
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
   1280c:	81800b04 	addi	r6,r16,44
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
   12810:	0005883a 	mov	r2,zero
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
   12814:	84000c04 	addi	r16,r16,48
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
   12818:	01000504 	movi	r4,20
					{
						if ((file_record_index != index) && (active_files[index].in_use == true))
   1281c:	98800b26 	beq	r19,r2,1284c <alt_up_sd_card_fopen+0x128>
   12820:	91c00017 	ldw	r7,0(r18)
   12824:	38c0091e 	bne	r7,r3,1284c <alt_up_sd_card_fopen+0x128>
						{
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
   12828:	2a000017 	ldw	r8,0(r5)
   1282c:	91fffb17 	ldw	r7,-20(r18)
   12830:	41c0061e 	bne	r8,r7,1284c <alt_up_sd_card_fopen+0x128>
   12834:	32000017 	ldw	r8,0(r6)
   12838:	91fffc17 	ldw	r7,-16(r18)
   1283c:	41c0031e 	bne	r8,r7,1284c <alt_up_sd_card_fopen+0x128>
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
   12840:	8200000f 	ldh	r8,0(r16)
   12844:	91fffd0f 	ldh	r7,-12(r18)
   12848:	41c00e26 	beq	r8,r7,12884 <alt_up_sd_card_fopen+0x160>
                    active_files[file_record_index].current_byte_position = 0;
                    active_files[file_record_index].in_use = true;
    				active_files[file_record_index].modified = false;

					/* Check if the file has already been opened. */
					for (index = 0; index < MAX_FILES_OPENED; index++)
   1284c:	10800044 	addi	r2,r2,1
   12850:	94801004 	addi	r18,r18,64
   12854:	113ff11e 	bne	r2,r4,1281c <_gp+0xffff738c>
   12858:	00000b06 	br	12888 <alt_up_sd_card_fopen+0x164>
							}
						}
					}

                }
                else if (create)
   1285c:	a83fc526 	beq	r21,zero,12774 <_gp+0xffff72e4>
                {
                    /* Create file if needed. */
                    if (create_file(name, &(active_files[file_record_index]), &home_dir))
   12860:	d80d883a 	mov	r6,sp
   12864:	800b883a 	mov	r5,r16
   12868:	a009883a 	mov	r4,r20
   1286c:	00122080 	call	12208 <create_file>
   12870:	103fc026 	beq	r2,zero,12774 <_gp+0xffff72e4>
                    {
                        active_files[file_record_index].in_use = true;
   12874:	00800044 	movi	r2,1
   12878:	80800f15 	stw	r2,60(r16)
    					active_files[file_record_index].modified = true;
   1287c:	80800e15 	stw	r2,56(r16)
   12880:	00000106 	br	12888 <alt_up_sd_card_fopen+0x164>
							if ((active_files[file_record_index].file_record_cluster == active_files[index].file_record_cluster) &&
								(active_files[file_record_index].file_record_sector_in_cluster == active_files[index].file_record_sector_in_cluster) &&
								(active_files[file_record_index].file_record_offset == active_files[index].file_record_offset))
							{
								// file already in use.
								file_record_index = -2;
   12884:	047fff84 	movi	r17,-2
   12888:	8805883a 	mov	r2,r17
   1288c:	00000106 	br	12894 <alt_up_sd_card_fopen+0x170>
 * Output:
 *      An index to the file record assigned to the specified file. -1 is returned if the file could not be opened.
 *		Return -2 if the specified file has already been opened previously.
 */
{
	short int file_record_index = -1;
   12890:	00bfffc4 	movi	r2,-1
    		}
        }
	}

	return file_record_index;
}
   12894:	dfc01717 	ldw	ra,92(sp)
   12898:	dd401617 	ldw	r21,88(sp)
   1289c:	dd001517 	ldw	r20,84(sp)
   128a0:	dcc01417 	ldw	r19,80(sp)
   128a4:	dc801317 	ldw	r18,76(sp)
   128a8:	dc401217 	ldw	r17,72(sp)
   128ac:	dc001117 	ldw	r16,68(sp)
   128b0:	dec01804 	addi	sp,sp,96
   128b4:	f800283a 	ret

000128b8 <alt_up_sd_card_set_attributes>:

void alt_up_sd_card_set_attributes(short int file_handle, short int attributes)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
   128b8:	20bfffcc 	andi	r2,r4,65535
   128bc:	00c004c4 	movi	r3,19
   128c0:	18800a36 	bltu	r3,r2,128ec <alt_up_sd_card_set_attributes+0x34>
    {
        if (active_files[file_handle].in_use)
   128c4:	213fffcc 	andi	r4,r4,65535
   128c8:	2120001c 	xori	r4,r4,32768
   128cc:	21200004 	addi	r4,r4,-32768
   128d0:	200891ba 	slli	r4,r4,6
   128d4:	00800074 	movhi	r2,1
   128d8:	108e3a04 	addi	r2,r2,14568
   128dc:	1109883a 	add	r4,r2,r4
   128e0:	20800f17 	ldw	r2,60(r4)
   128e4:	10000126 	beq	r2,zero,128ec <alt_up_sd_card_set_attributes+0x34>
        {
            active_files[file_handle].attributes = ((char)(attributes & 0x00ff));
   128e8:	214002c5 	stb	r5,11(r4)
   128ec:	f800283a 	ret

000128f0 <alt_up_sd_card_get_attributes>:
short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
	short int result = -1;
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
   128f0:	20bfffcc 	andi	r2,r4,65535
   128f4:	00c004c4 	movi	r3,19
   128f8:	18800b36 	bltu	r3,r2,12928 <alt_up_sd_card_get_attributes+0x38>
    {
        if (active_files[file_handle].in_use)
   128fc:	213fffcc 	andi	r4,r4,65535
   12900:	2120001c 	xori	r4,r4,32768
   12904:	21200004 	addi	r4,r4,-32768
   12908:	200891ba 	slli	r4,r4,6
   1290c:	00800074 	movhi	r2,1
   12910:	108e3a04 	addi	r2,r2,14568
   12914:	1109883a 	add	r4,r2,r4
   12918:	20800f17 	ldw	r2,60(r4)
   1291c:	10000226 	beq	r2,zero,12928 <alt_up_sd_card_get_attributes+0x38>
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
   12920:	208002c3 	ldbu	r2,11(r4)
   12924:	f800283a 	ret

short int alt_up_sd_card_get_attributes(short int file_handle)
/* Return file attributes, or -1 if the file_handle is invalid.
 */
{
	short int result = -1;
   12928:	00bfffc4 	movi	r2,-1
		{
			result = ((active_files[file_handle].attributes) & 0x00ff);
		}
	}
	return result;
}
   1292c:	f800283a 	ret

00012930 <alt_up_sd_card_read>:
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
   12930:	20bfffcc 	andi	r2,r4,65535
   12934:	00c004c4 	movi	r3,19
   12938:	18805036 	bltu	r3,r2,12a7c <alt_up_sd_card_read+0x14c>
    {
        if (active_files[file_handle].in_use)
   1293c:	213fffcc 	andi	r4,r4,65535
   12940:	2120001c 	xori	r4,r4,32768
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
   12944:	defff504 	addi	sp,sp,-44
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12948:	21200004 	addi	r4,r4,-32768
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
   1294c:	dc800315 	stw	r18,12(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12950:	202491ba 	slli	r18,r4,6
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
   12954:	dc000115 	stw	r16,4(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12958:	04000074 	movhi	r16,1
   1295c:	840e3a04 	addi	r16,r16,14568
   12960:	8485883a 	add	r2,r16,r18
   12964:	10c00f17 	ldw	r3,60(r2)
}

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
   12968:	dfc00a15 	stw	ra,40(sp)
   1296c:	df000915 	stw	fp,36(sp)
   12970:	ddc00815 	stw	r23,32(sp)
   12974:	dd800715 	stw	r22,28(sp)
   12978:	dd400615 	stw	r21,24(sp)
   1297c:	dd000515 	stw	r20,20(sp)
   12980:	dcc00415 	stw	r19,16(sp)
   12984:	dc400215 	stw	r17,8(sp)
    short int ch = -1;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12988:	18003e26 	beq	r3,zero,12a84 <alt_up_sd_card_read+0x154>
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
   1298c:	15400917 	ldw	r21,36(r2)
   12990:	10c00617 	ldw	r3,24(r2)
   12994:	a8c03b2e 	bgeu	r21,r3,12a84 <alt_up_sd_card_read+0x154>
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12998:	05800074 	movhi	r22,1
   1299c:	15000704 	addi	r20,r2,28
   129a0:	b58e2504 	addi	r22,r22,14484
   129a4:	a7000017 	ldw	fp,0(r20)
   129a8:	b5c00383 	ldbu	r23,14(r22)
                                  active_files[file_handle].current_sector_in_cluster;
   129ac:	14400804 	addi	r17,r2,32
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   129b0:	e13fff84 	addi	r4,fp,-2
   129b4:	b80b883a 	mov	r5,r23
   129b8:	0010ae80 	call	10ae8 <__mulsi3>
                                  active_files[file_handle].current_sector_in_cluster;
   129bc:	8cc00017 	ldw	r19,0(r17)
    {
        if (active_files[file_handle].in_use)
        {
            if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
            {
                int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   129c0:	b1001417 	ldw	r4,80(r22)
   129c4:	9909883a 	add	r4,r19,r4
   129c8:	1109883a 	add	r4,r2,r4
                                  active_files[file_handle].current_sector_in_cluster;
                
                if ((active_files[file_handle].current_byte_position > 0) && ((active_files[file_handle].current_byte_position % 512) == 0))
   129cc:	a8001826 	beq	r21,zero,12a30 <alt_up_sd_card_read+0x100>
   129d0:	ad407fcc 	andi	r21,r21,511
   129d4:	a800161e 	bne	r21,zero,12a30 <alt_up_sd_card_read+0x100>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
   129d8:	bdffffc4 	addi	r23,r23,-1
   129dc:	9dc0111e 	bne	r19,r23,12a24 <alt_up_sd_card_read+0xf4>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
   129e0:	d80b883a 	mov	r5,sp
   129e4:	e009883a 	mov	r4,fp
   129e8:	00112480 	call	11248 <get_cluster_flag>
   129ec:	10002126 	beq	r2,zero,12a74 <alt_up_sd_card_read+0x144>
                        {
                            if ((next_cluster & 0x0000fff8) == 0x0000fff8)
   129f0:	d900000b 	ldhu	r4,0(sp)
   129f4:	00bffe14 	movui	r2,65528
   129f8:	20fffe0c 	andi	r3,r4,65528
   129fc:	18802126 	beq	r3,r2,12a84 <alt_up_sd_card_read+0x154>
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12a00:	b1400383 	ldbu	r5,14(r22)
                                /* End of file */
                                return -1;
                            } 
                            else
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
   12a04:	213fffcc 	andi	r4,r4,65535
   12a08:	a1000015 	stw	r4,0(r20)
								active_files[file_handle].current_sector_in_cluster = 0;
   12a0c:	88000015 	stw	zero,0(r17)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12a10:	213fff84 	addi	r4,r4,-2
   12a14:	0010ae80 	call	10ae8 <__mulsi3>
   12a18:	b1001417 	ldw	r4,80(r22)
   12a1c:	1109883a 	add	r4,r2,r4
   12a20:	00000306 	br	12a30 <alt_up_sd_card_read+0x100>
                            return -2;
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
   12a24:	9cc00044 	addi	r19,r19,1
   12a28:	8cc00015 	stw	r19,0(r17)
                        data_sector = data_sector + 1;
   12a2c:	21000044 	addi	r4,r4,1
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
   12a30:	d160f317 	ldw	r5,-31796(gp)
   12a34:	d0a0ef17 	ldw	r2,-31812(gp)
   12a38:	2147883a 	add	r3,r4,r5
   12a3c:	18800b1e 	bne	r3,r2,12a6c <alt_up_sd_card_read+0x13c>
                    {
						return -2;
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
   12a40:	84a1883a 	add	r16,r16,r18
   12a44:	84000904 	addi	r16,r16,36
   12a48:	80c00017 	ldw	r3,0(r16)
   12a4c:	d120f417 	ldw	r4,-31792(gp)
   12a50:	18807fcc 	andi	r2,r3,511
   12a54:	2085883a 	add	r2,r4,r2
   12a58:	10800023 	ldbuio	r2,0(r2)
                active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
   12a5c:	18c00044 	addi	r3,r3,1
   12a60:	80c00015 	stw	r3,0(r16)
                    {
						return -2;
                    }
                }

                ch = (unsigned char) IORD_8DIRECT(buffer_memory, (active_files[file_handle].current_byte_position % 512));
   12a64:	10803fcc 	andi	r2,r2,255
   12a68:	00000706 	br	12a88 <alt_up_sd_card_read+0x158>
                    }
                }
                // Reading te first byte of the file.
                if (current_sector_index != (data_sector + fat_partition_offset_in_512_byte_sectors))
                {
                    if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
   12a6c:	00111a80 	call	111a8 <Read_Sector_Data>
   12a70:	103ff31e 	bne	r2,zero,12a40 <_gp+0xffff75b0>
                    {
						return -2;
   12a74:	00bfff84 	movi	r2,-2
   12a78:	00000306 	br	12a88 <alt_up_sd_card_read+0x158>

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
   12a7c:	00bfffc4 	movi	r2,-1
            }
        }
    }
    
    return ch;
}
   12a80:	f800283a 	ret

short int alt_up_sd_card_read(short int file_handle)
/* Read a single character from a given file. Return -1 if at the end of a file. Any other negative number
 * means that the file could not be read. A number between 0 and 255 is an ASCII character read from the SD Card. */
{
    short int ch = -1;
   12a84:	00bfffc4 	movi	r2,-1
            }
        }
    }
    
    return ch;
}
   12a88:	dfc00a17 	ldw	ra,40(sp)
   12a8c:	df000917 	ldw	fp,36(sp)
   12a90:	ddc00817 	ldw	r23,32(sp)
   12a94:	dd800717 	ldw	r22,28(sp)
   12a98:	dd400617 	ldw	r21,24(sp)
   12a9c:	dd000517 	ldw	r20,20(sp)
   12aa0:	dcc00417 	ldw	r19,16(sp)
   12aa4:	dc800317 	ldw	r18,12(sp)
   12aa8:	dc400217 	ldw	r17,8(sp)
   12aac:	dc000117 	ldw	r16,4(sp)
   12ab0:	dec00b04 	addi	sp,sp,44
   12ab4:	f800283a 	ret

00012ab8 <alt_up_sd_card_write>:
bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
   12ab8:	20bfffcc 	andi	r2,r4,65535
   12abc:	00c004c4 	movi	r3,19
   12ac0:	1880a536 	bltu	r3,r2,12d58 <alt_up_sd_card_write+0x2a0>
    {
        if (active_files[file_handle].in_use)
   12ac4:	213fffcc 	andi	r4,r4,65535
   12ac8:	2120001c 	xori	r4,r4,32768
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
   12acc:	defff104 	addi	sp,sp,-60
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12ad0:	21200004 	addi	r4,r4,-32768
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
   12ad4:	dc400615 	stw	r17,24(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12ad8:	202291ba 	slli	r17,r4,6
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
   12adc:	dd000915 	stw	r20,36(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12ae0:	05000074 	movhi	r20,1
   12ae4:	a50e3a04 	addi	r20,r20,14568
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
   12ae8:	df000d15 	stw	fp,52(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12aec:	a479883a 	add	fp,r20,r17
   12af0:	e0800f17 	ldw	r2,60(fp)
}


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
   12af4:	dfc00e15 	stw	ra,56(sp)
   12af8:	ddc00c15 	stw	r23,48(sp)
   12afc:	dd800b15 	stw	r22,44(sp)
   12b00:	dd400a15 	stw	r21,40(sp)
   12b04:	dcc00815 	stw	r19,32(sp)
   12b08:	dc800715 	stw	r18,28(sp)
   12b0c:	dc000515 	stw	r16,20(sp)
    bool result = false;
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
   12b10:	1000021e 	bne	r2,zero,12b1c <alt_up_sd_card_write+0x64>


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
   12b14:	0005883a 	mov	r2,zero
   12b18:	00008306 	br	12d28 <alt_up_sd_card_write+0x270>
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12b1c:	05000074 	movhi	r20,1
   12b20:	a50e2504 	addi	r20,r20,14484
   12b24:	e5800704 	addi	r22,fp,28
   12b28:	b2000017 	ldw	r8,0(r22)
   12b2c:	a4c00383 	ldbu	r19,14(r20)
   12b30:	d9400115 	stw	r5,4(sp)
   12b34:	413fff84 	addi	r4,r8,-2
                              active_files[file_handle].current_sector_in_cluster;
   12b38:	e5400804 	addi	r21,fp,32
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12b3c:	980b883a 	mov	r5,r19
                              active_files[file_handle].current_sector_in_cluster;
   12b40:	adc00017 	ldw	r23,0(r21)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12b44:	da000415 	stw	r8,16(sp)
   12b48:	0010ae80 	call	10ae8 <__mulsi3>
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
   12b4c:	e1800917 	ldw	r6,36(fp)
   12b50:	a1c0030b 	ldhu	r7,12(r20)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12b54:	a4001417 	ldw	r16,80(r20)
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
   12b58:	3009883a 	mov	r4,r6
   12b5c:	380b883a 	mov	r5,r7
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12b60:	bc21883a 	add	r16,r23,r16
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
   12b64:	d9800215 	stw	r6,8(sp)
   12b68:	d9c00315 	stw	r7,12(sp)
    
    if ((file_handle >= 0) && (file_handle < MAX_FILES_OPENED))
    {
        if (active_files[file_handle].in_use)
        {
            int data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12b6c:	1421883a 	add	r16,r2,r16
                              active_files[file_handle].current_sector_in_cluster;
			short int buffer_offset = active_files[file_handle].current_byte_position % boot_sector_data.sector_size_in_bytes;
   12b70:	0010a900 	call	10a90 <__umodsi3>
   12b74:	1025883a 	mov	r18,r2

			if (active_files[file_handle].current_byte_position < active_files[file_handle].file_size_in_bytes)
   12b78:	d9800217 	ldw	r6,8(sp)
   12b7c:	e0800617 	ldw	r2,24(fp)
   12b80:	d9c00317 	ldw	r7,12(sp)
   12b84:	a039883a 	mov	fp,r20
   12b88:	da000417 	ldw	r8,16(sp)
   12b8c:	3080192e 	bgeu	r6,r2,12bf4 <alt_up_sd_card_write+0x13c>
            {
                if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
   12b90:	30004526 	beq	r6,zero,12ca8 <alt_up_sd_card_write+0x1f0>
   12b94:	90bfffcc 	andi	r2,r18,65535
   12b98:	10a0001c 	xori	r2,r2,32768
   12b9c:	10a00004 	addi	r2,r2,-32768
   12ba0:	1000411e 	bne	r2,zero,12ca8 <alt_up_sd_card_write+0x1f0>
                {
                    // Read in a new sector of data.
                    if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
   12ba4:	9cffffc4 	addi	r19,r19,-1
   12ba8:	bcc00e1e 	bne	r23,r19,12be4 <alt_up_sd_card_write+0x12c>
                    {
                        // Go to the next cluster.
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
   12bac:	d80b883a 	mov	r5,sp
   12bb0:	4009883a 	mov	r4,r8
   12bb4:	00112480 	call	11248 <get_cluster_flag>
   12bb8:	10005b26 	beq	r2,zero,12d28 <alt_up_sd_card_write+0x270>
                        {
                            if (next_cluster < 0x0000fff8)
   12bbc:	d900000b 	ldhu	r4,0(sp)
   12bc0:	00bffdd4 	movui	r2,65527
   12bc4:	11003836 	bltu	r2,r4,12ca8 <alt_up_sd_card_write+0x1f0>
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
								active_files[file_handle].current_sector_in_cluster = 0;
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12bc8:	a1400383 	ldbu	r5,14(r20)
                        unsigned short int next_cluster;
                        if (get_cluster_flag(active_files[file_handle].current_cluster_index, &next_cluster))
                        {
                            if (next_cluster < 0x0000fff8)
                            {
                                active_files[file_handle].current_cluster_index = next_cluster;
   12bcc:	b1000015 	stw	r4,0(r22)
								active_files[file_handle].current_sector_in_cluster = 0;
   12bd0:	a8000015 	stw	zero,0(r21)
                                data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12bd4:	213fff84 	addi	r4,r4,-2
   12bd8:	0010ae80 	call	10ae8 <__mulsi3>
   12bdc:	a4001417 	ldw	r16,80(r20)
   12be0:	00003006 	br	12ca4 <alt_up_sd_card_write+0x1ec>
                            return false;
                        }
                    }
                    else
                    {
                        active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_sector_in_cluster + 1;
   12be4:	b8c00044 	addi	r3,r23,1
   12be8:	a8c00015 	stw	r3,0(r21)
                        data_sector = data_sector + 1;
   12bec:	84000044 	addi	r16,r16,1
   12bf0:	00002d06 	br	12ca8 <alt_up_sd_card_write+0x1f0>
                }
            }
			else
			{
				/* You are adding data to the end of the file, so increment its size and look for an additional data cluster if needed. */
				if ((active_files[file_handle].current_byte_position > 0) && (buffer_offset == 0))
   12bf4:	30002c26 	beq	r6,zero,12ca8 <alt_up_sd_card_write+0x1f0>
   12bf8:	90bfffcc 	andi	r2,r18,65535
   12bfc:	10a0001c 	xori	r2,r2,32768
   12c00:	10a00004 	addi	r2,r2,-32768
   12c04:	1000281e 	bne	r2,zero,12ca8 <alt_up_sd_card_write+0x1f0>
				{
					if (active_files[file_handle].current_sector_in_cluster == boot_sector_data.sectors_per_cluster - 1)
   12c08:	9cffffc4 	addi	r19,r19,-1
   12c0c:	bcc0171e 	bne	r23,r19,12c6c <alt_up_sd_card_write+0x1b4>
					{
						/* Find a new cluster if possible. */
						unsigned int cluster_number;

						if (find_first_empty_cluster(&cluster_number))
   12c10:	d809883a 	mov	r4,sp
   12c14:	00117080 	call	11708 <find_first_empty_cluster>
   12c18:	10004326 	beq	r2,zero,12d28 <alt_up_sd_card_write+0x270>
						{
							// mark clusters in both File Allocation Tables.
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
   12c1c:	d940000f 	ldh	r5,0(sp)
   12c20:	b1000017 	ldw	r4,0(r22)
   12c24:	01800044 	movi	r6,1
   12c28:	00112c80 	call	112c8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, true);
   12c2c:	d9000017 	ldw	r4,0(sp)
   12c30:	01800044 	movi	r6,1
   12c34:	017fffc4 	movi	r5,-1
   12c38:	00112c80 	call	112c8 <mark_cluster>
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
   12c3c:	d940000f 	ldh	r5,0(sp)
   12c40:	b1000017 	ldw	r4,0(r22)
   12c44:	000d883a 	mov	r6,zero
   12c48:	00112c80 	call	112c8 <mark_cluster>
							mark_cluster(cluster_number, 0xffff, false);
   12c4c:	d9000017 	ldw	r4,0(sp)
   12c50:	000d883a 	mov	r6,zero
   12c54:	017fffc4 	movi	r5,-1
   12c58:	00112c80 	call	112c8 <mark_cluster>
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
   12c5c:	d8800017 	ldw	r2,0(sp)
							active_files[file_handle].current_sector_in_cluster = 0;
   12c60:	a8000015 	stw	zero,0(r21)
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), true);
							mark_cluster(cluster_number, 0xffff, true);
							mark_cluster(active_files[file_handle].current_cluster_index, ((unsigned short int) (cluster_number & 0x0000ffff)), false);
							mark_cluster(cluster_number, 0xffff, false);
							// Change cluster index and sector index to compute a new data sector.
							active_files[file_handle].current_cluster_index = cluster_number;
   12c64:	b0800015 	stw	r2,0(r22)
   12c68:	00000406 	br	12c7c <alt_up_sd_card_write+0x1c4>
						}
					}
					else
					{
						/* Read the next sector in the cluster and modify it. We only need to change the data_sector value. The actual read happens a few lines below. */
						active_files[file_handle].current_sector_in_cluster = active_files[file_handle].current_byte_position / boot_sector_data.sector_size_in_bytes;
   12c6c:	380b883a 	mov	r5,r7
   12c70:	3009883a 	mov	r4,r6
   12c74:	0010a2c0 	call	10a2c <__udivsi3>
   12c78:	a8800015 	stw	r2,0(r21)
					}
					data_sector = boot_sector_data.data_sector_offset + (active_files[file_handle].current_cluster_index - 2)*boot_sector_data.sectors_per_cluster +
   12c7c:	00800074 	movhi	r2,1
   12c80:	108e3a04 	addi	r2,r2,14568
   12c84:	1467883a 	add	r19,r2,r17
   12c88:	99000717 	ldw	r4,28(r19)
   12c8c:	e1400383 	ldbu	r5,14(fp)
   12c90:	213fff84 	addi	r4,r4,-2
   12c94:	0010ae80 	call	10ae8 <__mulsi3>
   12c98:	98c00817 	ldw	r3,32(r19)
   12c9c:	e4001417 	ldw	r16,80(fp)
   12ca0:	80e1883a 	add	r16,r16,r3
   12ca4:	1421883a 	add	r16,r2,r16
                          active_files[file_handle].current_sector_in_cluster;
				}
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
   12ca8:	d160f317 	ldw	r5,-31796(gp)
   12cac:	d0a0ef17 	ldw	r2,-31812(gp)
   12cb0:	8147883a 	add	r3,r16,r5
   12cb4:	1880161e 	bne	r3,r2,12d10 <alt_up_sd_card_write+0x258>
                {
					return false;
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
   12cb8:	d0a0f417 	ldw	r2,-31792(gp)
   12cbc:	94bfffcc 	andi	r18,r18,65535
   12cc0:	94a0001c 	xori	r18,r18,32768
   12cc4:	94a00004 	addi	r18,r18,-32768
   12cc8:	14a5883a 	add	r18,r2,r18
   12ccc:	d8800117 	ldw	r2,4(sp)
   12cd0:	90800025 	stbio	r2,0(r18)
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
   12cd4:	00800074 	movhi	r2,1
   12cd8:	108e3a04 	addi	r2,r2,14568
   12cdc:	1463883a 	add	r17,r2,r17
   12ce0:	88800904 	addi	r2,r17,36
   12ce4:	10c00017 	ldw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
   12ce8:	89400604 	addi	r5,r17,24
   12cec:	01000044 	movi	r4,1
					return false;
                }
            }
            // Write a byte of data to the buffer.
			IOWR_8DIRECT(buffer_memory, buffer_offset, byte_of_data);
			active_files[file_handle].current_byte_position = active_files[file_handle].current_byte_position + 1;
   12cf0:	18c00044 	addi	r3,r3,1
   12cf4:	10c00015 	stw	r3,0(r2)

			// Modify the file record only when necessary.
			if (active_files[file_handle].current_byte_position >= active_files[file_handle].file_size_in_bytes)
   12cf8:	28800017 	ldw	r2,0(r5)
   12cfc:	18800836 	bltu	r3,r2,12d20 <alt_up_sd_card_write+0x268>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
   12d00:	10800044 	addi	r2,r2,1
   12d04:	28800015 	stw	r2,0(r5)
				active_files[file_handle].modified = true;
   12d08:	89000e15 	stw	r4,56(r17)
   12d0c:	00000406 	br	12d20 <alt_up_sd_card_write+0x268>
			}
            // Reading a data sector into the buffer. Note that changes to the most recently modified sector will be saved before
			// a new sector is read from the SD Card.
            if (current_sector_index != data_sector + fat_partition_offset_in_512_byte_sectors)
            {
                if (!Read_Sector_Data(data_sector, fat_partition_offset_in_512_byte_sectors))
   12d10:	8009883a 	mov	r4,r16
   12d14:	00111a80 	call	111a8 <Read_Sector_Data>
   12d18:	103fe71e 	bne	r2,zero,12cb8 <_gp+0xffff7828>
   12d1c:	003f7d06 	br	12b14 <_gp+0xffff7684>
			{
				active_files[file_handle].file_size_in_bytes = active_files[file_handle].file_size_in_bytes + 1;
				active_files[file_handle].modified = true;
			}
            // Invaldiate the buffer to ensure that the buffer contents are written to the SD card whe nthe file is closed.
            current_sector_modified = true;
   12d20:	d120f015 	stw	r4,-31808(gp)
			result = true;
   12d24:	00800044 	movi	r2,1
		}
    }
    
    return result;
}
   12d28:	dfc00e17 	ldw	ra,56(sp)
   12d2c:	df000d17 	ldw	fp,52(sp)
   12d30:	ddc00c17 	ldw	r23,48(sp)
   12d34:	dd800b17 	ldw	r22,44(sp)
   12d38:	dd400a17 	ldw	r21,40(sp)
   12d3c:	dd000917 	ldw	r20,36(sp)
   12d40:	dcc00817 	ldw	r19,32(sp)
   12d44:	dc800717 	ldw	r18,28(sp)
   12d48:	dc400617 	ldw	r17,24(sp)
   12d4c:	dc000517 	ldw	r16,20(sp)
   12d50:	dec00f04 	addi	sp,sp,60
   12d54:	f800283a 	ret


bool alt_up_sd_card_write(short int file_handle, char byte_of_data)
/* Write a single character to a given file. Return true if successful, and false otherwise. */
{
    bool result = false;
   12d58:	0005883a 	mov	r2,zero
			result = true;
		}
    }
    
    return result;
}
   12d5c:	f800283a 	ret

00012d60 <alt_up_sd_card_fclose>:


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
   12d60:	defffc04 	addi	sp,sp,-16
   12d64:	dc000015 	stw	r16,0(sp)
   12d68:	dfc00315 	stw	ra,12(sp)
   12d6c:	dc800215 	stw	r18,8(sp)
   12d70:	dc400115 	stw	r17,4(sp)
   12d74:	2021883a 	mov	r16,r4
    bool result = false;
    if ((alt_up_sd_card_is_Present()) && (is_sd_card_formated_as_FAT16))
   12d78:	00110a40 	call	110a4 <alt_up_sd_card_is_Present>
   12d7c:	10002726 	beq	r2,zero,12e1c <alt_up_sd_card_fclose+0xbc>
   12d80:	d0a0fa17 	ldw	r2,-31768(gp)
   12d84:	10002526 	beq	r2,zero,12e1c <alt_up_sd_card_fclose+0xbc>
    {
        if (active_files[file_handle].in_use) 
   12d88:	813fffcc 	andi	r4,r16,65535
   12d8c:	2120001c 	xori	r4,r4,32768
   12d90:	21200004 	addi	r4,r4,-32768
   12d94:	202091ba 	slli	r16,r4,6
   12d98:	04800074 	movhi	r18,1
   12d9c:	948e3a04 	addi	r18,r18,14568
   12da0:	9407883a 	add	r3,r18,r16
   12da4:	18800f17 	ldw	r2,60(r3)
   12da8:	10001c26 	beq	r2,zero,12e1c <alt_up_sd_card_fclose+0xbc>
        {
			if (active_files[file_handle].modified)
   12dac:	18800e17 	ldw	r2,56(r3)
   12db0:	10001626 	beq	r2,zero,12e0c <alt_up_sd_card_fclose+0xac>
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
				if (active_files[file_handle].file_record_cluster == 0)
   12db4:	19800a17 	ldw	r6,40(r3)
   12db8:	01400074 	movhi	r5,1
    {
        if (active_files[file_handle].in_use) 
        {
			if (active_files[file_handle].modified)
			{
				unsigned int record_sector = active_files[file_handle].file_record_sector_in_cluster;
   12dbc:	19000b17 	ldw	r4,44(r3)
   12dc0:	294e2504 	addi	r5,r5,14484
				if (active_files[file_handle].file_record_cluster == 0)
   12dc4:	3000031e 	bne	r6,zero,12dd4 <alt_up_sd_card_fclose+0x74>
				{
					record_sector = record_sector + boot_sector_data.root_directory_sector_offset;
   12dc8:	28c01317 	ldw	r3,76(r5)
   12dcc:	20c9883a 	add	r4,r4,r3
   12dd0:	00000606 	br	12dec <alt_up_sd_card_fclose+0x8c>
				}
				else
				{
					record_sector = record_sector + boot_sector_data.data_sector_offset + 
   12dd4:	28c01417 	ldw	r3,80(r5)
   12dd8:	29400383 	ldbu	r5,14(r5)
   12ddc:	20e3883a 	add	r17,r4,r3
   12de0:	313fff84 	addi	r4,r6,-2
   12de4:	0010ae80 	call	10ae8 <__mulsi3>
   12de8:	1449883a 	add	r4,r2,r17
									(active_files[file_handle].file_record_cluster - 2)*boot_sector_data.sectors_per_cluster;
				}
				if (Read_Sector_Data(record_sector, fat_partition_offset_in_512_byte_sectors))
   12dec:	d160f317 	ldw	r5,-31796(gp)
   12df0:	00111a80 	call	111a8 <Read_Sector_Data>
   12df4:	10000526 	beq	r2,zero,12e0c <alt_up_sd_card_fclose+0xac>
				{
					if (Write_File_Record_At_Offset(active_files[file_handle].file_record_offset, &(active_files[file_handle])))
   12df8:	940b883a 	add	r5,r18,r16
   12dfc:	29000c0f 	ldh	r4,48(r5)
   12e00:	00120a40 	call	120a4 <Write_File_Record_At_Offset>
   12e04:	10000126 	beq	r2,zero,12e0c <alt_up_sd_card_fclose+0xac>
					{
						// Make sure that the Data has been saved to the SD Card.
						result = Save_Modified_Sector();
   12e08:	001118c0 	call	1118c <Save_Modified_Sector>
					}
				}
			}
			active_files[file_handle].in_use = false;
   12e0c:	9421883a 	add	r16,r18,r16
   12e10:	80000f15 	stw	zero,60(r16)
			result = true;
   12e14:	00800044 	movi	r2,1
   12e18:	00000106 	br	12e20 <alt_up_sd_card_fclose+0xc0>


bool alt_up_sd_card_fclose(short int file_handle)
// This function closes an opened file and saves data to SD Card if necessary.
{
    bool result = false;
   12e1c:	0005883a 	mov	r2,zero
			result = true;
        }
    }
    
    return result;
}
   12e20:	dfc00317 	ldw	ra,12(sp)
   12e24:	dc800217 	ldw	r18,8(sp)
   12e28:	dc400117 	ldw	r17,4(sp)
   12e2c:	dc000017 	ldw	r16,0(sp)
   12e30:	dec00404 	addi	sp,sp,16
   12e34:	f800283a 	ret

00012e38 <altera_avalon_jtag_uart_write>:
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
  unsigned int base = sp->base;
   12e38:	21000017 	ldw	r4,0(r4)
 * one FIFOs worth of data.  But you said you didn't want to use interrupts :-)
 */

int altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
   12e3c:	3005883a 	mov	r2,r6
  unsigned int base = sp->base;

  const char * end = ptr + count;
   12e40:	298d883a 	add	r6,r5,r6

  while (ptr < end)
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   12e44:	21c00104 	addi	r7,r4,4
{
  unsigned int base = sp->base;

  const char * end = ptr + count;

  while (ptr < end)
   12e48:	2980072e 	bgeu	r5,r6,12e68 <altera_avalon_jtag_uart_write+0x30>
    if ((IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base) & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) != 0)
   12e4c:	38c00037 	ldwio	r3,0(r7)
   12e50:	18ffffec 	andhi	r3,r3,65535
   12e54:	183ffc26 	beq	r3,zero,12e48 <_gp+0xffff79b8>
      IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, *ptr++);
   12e58:	28c00007 	ldb	r3,0(r5)
   12e5c:	20c00035 	stwio	r3,0(r4)
   12e60:	29400044 	addi	r5,r5,1
   12e64:	003ff806 	br	12e48 <_gp+0xffff79b8>

  return count;
}
   12e68:	f800283a 	ret

00012e6c <alt_busy_sleep>:
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   12e6c:	014666b4 	movhi	r5,6554
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   12e70:	defffe04 	addi	sp,sp,-8
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   12e74:	29666644 	addi	r5,r5,-26215
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
   12e78:	dc000015 	stw	r16,0(sp)
   12e7c:	dfc00115 	stw	ra,4(sp)
   12e80:	2021883a 	mov	r16,r4
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
   12e84:	0010a2c0 	call	10a2c <__udivsi3>
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
   12e88:	10001026 	beq	r2,zero,12ecc <alt_busy_sleep+0x60>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   12e8c:	01600034 	movhi	r5,32768
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   12e90:	013999b4 	movhi	r4,58982
   12e94:	0007883a 	mov	r3,zero
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   12e98:	297fffc4 	addi	r5,r5,-1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   12e9c:	211999c4 	addi	r4,r4,26215
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
   12ea0:	297fffc4 	addi	r5,r5,-1
   12ea4:	283ffe1e 	bne	r5,zero,12ea0 <_gp+0xffff7a10>
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   12ea8:	18c00044 	addi	r3,r3,1
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
   12eac:	8121883a 	add	r16,r16,r4
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
   12eb0:	18bffb16 	blt	r3,r2,12ea0 <_gp+0xffff7a10>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   12eb4:	01400144 	movi	r5,5
   12eb8:	8009883a 	mov	r4,r16
   12ebc:	0010ae80 	call	10ae8 <__mulsi3>
   12ec0:	10bfffc4 	addi	r2,r2,-1
   12ec4:	103ffe1e 	bne	r2,zero,12ec0 <_gp+0xffff7a30>
   12ec8:	00000506 	br	12ee0 <alt_busy_sleep+0x74>
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
   12ecc:	01400144 	movi	r5,5
   12ed0:	8009883a 	mov	r4,r16
   12ed4:	0010ae80 	call	10ae8 <__mulsi3>
   12ed8:	10bfffc4 	addi	r2,r2,-1
   12edc:	00bffe16 	blt	zero,r2,12ed8 <_gp+0xffff7a48>
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
}
   12ee0:	0005883a 	mov	r2,zero
   12ee4:	dfc00117 	ldw	ra,4(sp)
   12ee8:	dc000017 	ldw	r16,0(sp)
   12eec:	dec00204 	addi	sp,sp,8
   12ef0:	f800283a 	ret

00012ef4 <alt_dcache_flush_all>:
/*
 * alt_dcache_flush_all() is called to flush the entire data cache.
 */

void alt_dcache_flush_all (void)
{
   12ef4:	f800283a 	ret

00012ef8 <alt_dev_null_write>:
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
  return len;
}
   12ef8:	3005883a 	mov	r2,r6
   12efc:	f800283a 	ret

00012f00 <alt_dev_llist_insert>:
{
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
   12f00:	20000226 	beq	r4,zero,12f0c <alt_dev_llist_insert+0xc>
   12f04:	20800217 	ldw	r2,8(r4)
   12f08:	1000101e 	bne	r2,zero,12f4c <alt_dev_llist_insert+0x4c>
   12f0c:	d0a00717 	ldw	r2,-32740(gp)
   12f10:	10000926 	beq	r2,zero,12f38 <alt_dev_llist_insert+0x38>
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
   12f14:	deffff04 	addi	sp,sp,-4
   12f18:	dfc00015 	stw	ra,0(sp)
   12f1c:	103ee83a 	callr	r2
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
   12f20:	00c00584 	movi	r3,22
   12f24:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   12f28:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   12f2c:	dfc00017 	ldw	ra,0(sp)
   12f30:	dec00104 	addi	sp,sp,4
   12f34:	f800283a 	ret
   12f38:	d0a0ea04 	addi	r2,gp,-31832
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
  {
    ALT_ERRNO = EINVAL;
   12f3c:	00c00584 	movi	r3,22
   12f40:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
   12f44:	00bffa84 	movi	r2,-22
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
}
   12f48:	f800283a 	ret

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
  entry->next     = list->next;
   12f4c:	28800017 	ldw	r2,0(r5)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
   12f50:	21400115 	stw	r5,4(r4)
  entry->next     = list->next;
   12f54:	20800015 	stw	r2,0(r4)

  list->next->previous = entry;
   12f58:	28800017 	ldw	r2,0(r5)
   12f5c:	11000115 	stw	r4,4(r2)
  list->next           = entry;
   12f60:	29000015 	stw	r4,0(r5)
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);

  return 0;  
   12f64:	0005883a 	mov	r2,zero
   12f68:	f800283a 	ret

00012f6c <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
   12f6c:	defffb04 	addi	sp,sp,-20
   12f70:	dcc00315 	stw	r19,12(sp)
   12f74:	dc800215 	stw	r18,8(sp)
   12f78:	dc400115 	stw	r17,4(sp)
   12f7c:	dc000015 	stw	r16,0(sp)
   12f80:	dfc00415 	stw	ra,16(sp)
   12f84:	2027883a 	mov	r19,r4
   12f88:	2823883a 	mov	r17,r5
  alt_dev* next = (alt_dev*) llist->next;
   12f8c:	2c000017 	ldw	r16,0(r5)
  alt_32 len;

  len  = strlen(name) + 1;
   12f90:	00102540 	call	10254 <strlen>
   12f94:	14800044 	addi	r18,r2,1
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
   12f98:	84400726 	beq	r16,r17,12fb8 <alt_find_dev+0x4c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
   12f9c:	81000217 	ldw	r4,8(r16)
   12fa0:	900d883a 	mov	r6,r18
   12fa4:	980b883a 	mov	r5,r19
   12fa8:	0012fec0 	call	12fec <memcmp>
   12fac:	10000426 	beq	r2,zero,12fc0 <alt_find_dev+0x54>
    {
      /* match found */

      return next;
    }
    next = (alt_dev*) next->llist.next;
   12fb0:	84000017 	ldw	r16,0(r16)
   12fb4:	003ff806 	br	12f98 <_gp+0xffff7b08>
  }
  
  /* No match found */
  
  return NULL;
   12fb8:	0005883a 	mov	r2,zero
   12fbc:	00000106 	br	12fc4 <alt_find_dev+0x58>
   12fc0:	8005883a 	mov	r2,r16
}
   12fc4:	dfc00417 	ldw	ra,16(sp)
   12fc8:	dcc00317 	ldw	r19,12(sp)
   12fcc:	dc800217 	ldw	r18,8(sp)
   12fd0:	dc400117 	ldw	r17,4(sp)
   12fd4:	dc000017 	ldw	r16,0(sp)
   12fd8:	dec00504 	addi	sp,sp,20
   12fdc:	f800283a 	ret

00012fe0 <alt_icache_flush_all>:
/*
 * alt_icache_flush_all() is called to flush the entire instruction cache.
 */

void alt_icache_flush_all (void)
{
   12fe0:	f800283a 	ret

00012fe4 <altera_nios2_gen2_irq_init>:
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_gen2_irq_init(void) 
{
    NIOS2_WRITE_IENABLE(0);
   12fe4:	000170fa 	wrctl	ienable,zero
   12fe8:	f800283a 	ret

00012fec <memcmp>:
   12fec:	218d883a 	add	r6,r4,r6
   12ff0:	21800826 	beq	r4,r6,13014 <memcmp+0x28>
   12ff4:	20800003 	ldbu	r2,0(r4)
   12ff8:	28c00003 	ldbu	r3,0(r5)
   12ffc:	10c00226 	beq	r2,r3,13008 <memcmp+0x1c>
   13000:	10c5c83a 	sub	r2,r2,r3
   13004:	f800283a 	ret
   13008:	21000044 	addi	r4,r4,1
   1300c:	29400044 	addi	r5,r5,1
   13010:	003ff706 	br	12ff0 <_gp+0xffff7b60>
   13014:	0005883a 	mov	r2,zero
   13018:	f800283a 	ret

0001301c <memcpy>:
   1301c:	2005883a 	mov	r2,r4
   13020:	2007883a 	mov	r3,r4
   13024:	218d883a 	add	r6,r4,r6
   13028:	19800526 	beq	r3,r6,13040 <memcpy+0x24>
   1302c:	29000003 	ldbu	r4,0(r5)
   13030:	18c00044 	addi	r3,r3,1
   13034:	29400044 	addi	r5,r5,1
   13038:	193fffc5 	stb	r4,-1(r3)
   1303c:	003ffa06 	br	13028 <_gp+0xffff7b98>
   13040:	f800283a 	ret
